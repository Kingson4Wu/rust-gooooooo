总结来说:
1、在堆中分配的变量, 在使用方法调用之后, 其所有权转移到方法中(相当于被移动到方法中去了), 并在方法调用之后失效;
2、在栈中分配的变量, 其值只是被拷贝到调用的方法中, 在方法调用之后仍然可用

java Python js 只有class的概念 go 只有struct概念 c++都有 区别是struct可以在栈中定义

Gc语言，调用栈和内存一直在变化，不stw无法算出没引用的变量
Rust通过作用域的规则判断自动回收
无gc不代表不在堆分配，是代表没有stw的垃圾回收机制

Java分为Error和Exception，异常又分为运行时异常和检查性异常。抛出与捕获。
这点和go是类似的，go也区分简单返回的错误error和抛出的恐慌panic。

生命周期似乎其实不必要？编译器应该要能自动检测出签名入参的生命周期限制？
无法根据代码逻辑自行推导？

任何引用都有一个生命周期，并且需要为使用引用的函数或结构体指定生命周期参数。

因为随着Rust自身的开发，可能会有更多确定性的模式被添加到编译器中。在未来，需要手动标注的生命周期也许会越来越少。

第一条规则是，每一个引用参数都会拥有自己的生命周期参数。换句话说，单参数函数拥有一个生命周期参数：fn foo<'a>(x: &'a i32)；双参数函数拥有两个不同的生命周期参数：fn foo<'a, 'b>(x: &'a i32, y: &'b i32)；以此类推。
第二条规则是，当只存在一个输入生命周期参数时，这个生命周期会被赋予给所有输出生命周期参数，例如fn foo<'a>(x: &'a i32) -> &'a i32。
第三条规则是，当拥有多个输入生命周期参数，而其中一个是&self或&mut self时，self的生命周期会被赋予给所有的输出生命周期参数。这条规则使方法更加易于阅读和编写，因为它省略了一些不必要的符号。


下面是选择使用Box<T>、Rc<T>还是RefCell<T>的依据：
• Rc<T>允许一份数据有多个所有者，而Box<T>和RefCell<T>都只有一个所有者。
• Box<T>允许在编译时检查的可变或不可变借用，Rc<T>仅允许编译时检查的不可变借用，RefCell<T>允许运行时检查的可变或不可变借用。
• 由于RefCell<T>允许我们在运行时检查可变借用，所以即便RefCell<T>本身是不可变的，我们仍然能够更改其中存储的值。
内部可变性模式允许用户更改一个不可变值的内部数据。


Rust和Java支持函数式链式编程，类似stream
Go不支持，要自己实现

 依赖管理
跟Go类似直接定位到具体的包，但同样包名的只能保留一个版本，Go会选择最高版本，所以库不兼容则会有问题
Rust项目依赖a包高版本，依赖的b包间接依赖a包的低版本，a的高低版本不兼容，这种怎么处理？todo

我们看到cargo为A选择的版本是C v1.3.0，而为B选择的C版本是C v2.4.0，也就是说C的两个不兼容版本在app中可以同时存在。
针对依赖同一个库的不同版本的情况，我通过示例说明了Cargo的处理方式：如果版本相同或兼容，Cargo会选择满足要求的当前最高版本；如果版本不兼容，Cargo允许在项目中同时使用这些不兼容的版本，可以通过别名来区分使用。

个人看法总结：Rust能做到同时使用同一个库的不同版本，是因为那个项目都有独立的依赖库配置以及引入别名机制，关键的是打包能根据这些信息直接生成二进制。而java是生成 字节码文件，并打包时丢失这方面的信息，虚拟机可能目前由于历史和后续兼容等原因也暂不支持。



Rust为了减少运行时，默认使用线程模型的并发。
Go是绿色线程。
Java一般也是线程模型。

主线程结束，不管其他线程是否结束，进程都会结束，这点Rust和Go一样。（go是绿色线程）
Java也是即使主线程结束，其他线程不结束，进程就不会退出。

较新版本的 Rust 中会默认添加  move 所以该错误不会出现了


面向对象

Java中的单继承其实简化了继承的使用方式， Go和Rust，算是彻底抛弃了使用类继承的方式，选择了接口继承。

模式匹配
最新版的rust中，这个语法被废弃了， 得使用..=代替了， 但是好的一点是rust编译器会告诉你它被废弃了， 应该用新的语法

----


Rust 第十二章代码和说明 TODO

停机问题（Halting Problem）

内部可变性：可变地借用一个不可变的值
代码示例实践

循环依赖
这段文字容易令人以为是a.tail()引起的死循环，其实不然，这里只是因为打印遍历造成的死循环，就算把参数改为a也一样会发生死循环

如果本章的内容引起了你的兴趣并希望立即开始实现智能指针的话，那么你可以参考Rust官方网站上的The Rustonomicon来获得更多有用的信息。

找书的全部代码示例

第17章代码和说明 TODO

Rust 第20章代码和说明 TODO


后面有时间再跟着rust圣经学学。
        推荐跟着trpl或rust圣经进行学习：
        1. [Rust 程序设计语言 简体中文版](https://kaisery.github.io/trpl-zh-cn/)
        2. [Rust语言圣经(Rust Course)](https://course.rs/)
        xdm，咱们rcore labs见！


这本书的最新英文版可以看下面链接，用浏览器自动翻译就挺好的
https://doc.rust-lang.org/book/


Rust解决了三个问题:
1. 通过所有权解决了无GC模式下内存垃圾管理问题。
2. 通过生命周期解决了无效引用问题。
3. 还有一个解决并发安全问题，怎么解决的没仔细看。
Rust一个重要设计理念是零抽象成本。在不损失性能的条件下，提供各种安全功能。
总之，Rust的两大特点就是安全和高性能。

---

https://github.com/bendell02/book_the_rust_programming_language
https://gitee.com/bendell02/book_the_rust_programming_language
https://xiaochai.github.io/2021/11/20/the-rust-programming-language/


https://github.com/sunface/rust-course
https://rusty.course.rs/

