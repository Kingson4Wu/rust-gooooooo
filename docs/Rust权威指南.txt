Rust权威指南
史蒂夫·克拉伯尼克 卡罗尔·尼科尔斯
169个笔记
前言
 
而在Rust的世界里，大部分的错误（甚至包括并发环境中产生的错误）都可以在编译阶段被编译器发现并拦截。得益于编译器这种类似于守门员的角色，开发团队可以在更多的时间内专注于业务逻辑而非错误调试。
 
 
Cargo提供了一套内置的依赖管理与构建工具
变量与可变性
 
Rust的编译器能够保证那些声明为不可变的值一定不会发生改变。这也意味着你无须在阅读和编写代码时追踪一个变量会如何变化，从而使代码逻辑更加易于理解和推导。
 
 
变量默认是不可变的，但你可以通过在声明的变量名称前添加mut关键字来使其可变。
 
 
在某些情况下，相较于不可变变量而言，可变变量会让代码变得更加易于编写。
 
 
除了避免出现bug，设计一个变量的可变性还需要考量许多因素。例如当你在使用某些重型数据结构时，适当地使用可变性去修改一个实例，可能比赋值和重新返回一个新分配的实例要更有效率；而当数据结构较为轻量的时候，采用更偏向函数式的风格，通过创建新变量来进行赋值，可能会使代码更加易于理解。在类似这样的情形下，为了可读性而损失少许的性能也许是值得的。
 
 
使用const关键字而不是let关键字来声明一个常量。在声明的同时，你必须显式地标注值的类型。
 
 
最后，你只能将常量绑定到一个常量表达式上，而无法将一个函数的返回值，或其他需要在运行时计算的值绑定到常量上。
 
 
在第2章的“比较猜测数字与保密数字”一节中，我们曾经看到一个新声明的变量可以覆盖掉旧的同名变量。在Rust世界中，我们把这一现象描述为：第一个变量被第二个变量隐藏（shadow）了。
 
 
隐藏机制不同于将一个变量声明为mut
 
 
隐藏机制与mut的另一个区别在于：由于重复使用let关键字会创建出新的变量，所以我们可以在复用变量名称的同时改变它的类型。
数据类型
 
标量类型（scalar）和复合类型（compound）。
 
 
标量类型是单个值类型的统称。Rust中内建了4种基础的标量类型：整数、浮点数、布尔值及字符。
 
 
[插图]
 
 
isize和usize两种特殊的整数类型，它们的长度取决于程序运行的目标平台。在64位架构上，它们就是64位的，而在32位架构上，它们就是32位的。
 
 
除了Byte，其余所有的字面量都可以使用类型后缀，比如57u8，代表一个使用了u8类型的整数57。
 
 
同时你也可以使用_作为分隔符以方便读数，比如1_000。
 
 
Rust对于整数字面量的默认推导类型i32通常就是一个很好的选择：它在大部分情形下都是运算速度最快的那一个，即便是在64位系统上也是如此
 
 
。较为特殊的两个整数类型usize和isize则主要用作某些集合的索引。
 
 
如果你在编译时使用了带有--release标记的发布（release）模式，那么Rust就不会包含那些可能会触发panic的检查代码。作为替代，Rust会在溢出发生时执行二进制补码环绕。简而言之，任何超出类型最大值的数值都会被“环绕”为类型最小值。以u8为例，256会变为0，257会变为1，以此类推
 
 
假如你确实希望显式地进行环绕行为，那么你可以使用标准库中的类型Wrapping。
 
 
由于在现代CPU中f64与f32的运行效率相差无几，却拥有更高的精度，所以在Rust中，默认会将浮点数字面量的类型推导为f64。
 
 
f32和f64类型分别对应着标准中的单精度浮点数和双精度浮点数。
 
 
Rust中的char类型占4字节，是一个Unicode标量值，这也意味着它可以表示比ASCII多得多的字符内容。
 
 
复合类型（compound type）可以将多个不同类型的值组合为一个类型。
 
 
Rust提供了两种内置的基础复合类型：元组（tuple）和数组（array）。
 
 
元组还拥有一个固定的长度：你无法在声明结束后增加或减少其中的元素数量。
 
 
元组每个位置的值都有一个类型，这些类型不需要是相同的。
 
 
使用模式匹配来解构元组
 
 
src/main.rsfn main() {     let tup = (500, 6.4, 1);      let (x, y, z) = tup;      println!("The value of y is: {}", y); } 
 
 
这段程序首先创建了一个元组x，随后又通过索引访问元组的各个元素，并将它们的值绑定到新的变量上。和大多数编程语言一样，元组的索引从0开始。
 
 
数组类型
 
 
与元组不同，数组中的每一个元素都必须是相同的类型。Rust中的数组拥有固定的长度，一旦声明就再也不能随意更改大小，这与其他某些语言有所不同。
 
 
通常而言，当你想在栈上而不是堆上为数据分配空间时，或者想要确保总有固定数量的元素时，数组是一个非常有用的工具
 
 
Rust标准库也提供了一个更加灵活的动态数组（vector）类型。动态数组是一个类似于数组的集合结构，但它允许用户自由地调整数组长度。
 
 
这样撰写数组类型的方式有些类似于另一种初始化数组的语法，即假如你想要创建一个含有相同元素的数组，那么你可以在方括号中指定元素的值，并接着填入一个分号及数组的长度，如下所示：let a = [3; 5]；以a命名的数组将会拥有5个元素，而这些元素全部拥有相同的初始值3。这一写法等价于let a = [3, 3, 3, 3, 3];，但却更加精简。
 
 
数组由一整块分配在栈上的内存组成
函数
 
Rust代码使用蛇形命名法（snake case）来作为规范函数和变量名称的风格
 
 
。蛇形命名法只使用小写的字母进行命名，并以下画线分隔单词。
 
 
Rust不关心你在何处定义函数，只要这些定义对于使用区域是可见的即可。
 
 
在英语技术文档中，参数变量和传入的具体参数值有自己分别对应的名称parameter和argument，但我们通常会混用两者并将它们统一地称为参数而不加以区别。
 
 
由于Rust是一门基于表达式的语言，所以它将语句（statement）与表达式（expression）区别为两个不同的概念
 
 
语句指那些执行操作但不返回值的指令，而表达式则是指会进行计算并产生一个值作为结果的指令。
 
 
语句let y = 6;中的字面量6就是一个表达式，它返回6作为自己的计算结果。调用函数是表达式，调用宏是表达式，我们用来创建新作用域的花括号（{}）同样也是表达式
 
 
fn main() {     let x = 5;   ❶ let y = {❷          let x = 3;      ❸  x + 1     };      println!("The value of y is: {}", y); } 表达式❷是一个代码块。在这个例子中，它会计算出4作为结果。而这个结果会作为let语句❶的一部分被绑定到变量y上。注意结尾处❸的表达式x + 1没有添加分号，这与我们之前见过的大部分代码不同。
 
 
假如我们在表达式的末尾加上了分号，这一段代码就变为了语句而不会返回任何值
 
 
st中，函数的返回值等同于函数体最后一个表达式的值。你可以
 
 
使用return关键字并指定一个值来提前从函数中返回，但大多数函数都隐式地返回了最后的表达式。
 
 
但由于语句并不会产生值，所以Rust默认返回了一个空元组，也就是上面描述中的()
 
 
。实际的返回值类型与函数定义产生了矛盾，进而触发了编译时错误。
控制流
 
由于if是一个表达式，所以我们可以在let语句的右侧使用它来生成一个值
 
 
let number = if condition {         5     } else {         6     }; 
 
 
Rust提供了3种循环：loop、while和for。
 
 
我们可以将需要返回的值添加到break表达式后面，也就是我们用来终止循环的表达式后面
 
 
fn main() {     let mut counter = 0;      let result = loop {         counter += 1;          if counter == 10 {             break counter * 2;         }     };      println!("The result is {}", result); } 
 
 
在循环之后，我们还使用了一个分号来结束当前的语句，这会将循环的返回结果赋值给result。
 
 
使用for循环这种更简明的方法来遍历集合中的每一个元素
 
 
for循环的安全性和简捷性使它成为了Rust中最为常用的循环结构
第4章 认识所有权
 
所有权可以说是Rust中最为独特的一个功能了。
 
 
正是所有权概念和相关工具的引入，Rust才能够在没有垃圾回收机制的前提下保障内存安全。
 
 
借用、切片，以及Rust在内存中布局数据的方式
什么是所有权
 
一般来讲，所有的程序都需要管理自己在运行时使用的计算机内存空间。某些使用垃圾回收机制的语言会在运行时定期检查并回收那些没有被继续使用的内存；而在另外一些语言中，程序员需要手动地分配和释放内存。
 
 
Rust采用了与众不同的第三种方式：它使用包含特定规则的所有权系统来管理内存，这套规则允许编译器在编译过程中执行检查工作，而不会产生任何的运行时开销。
 
 
在许多编程语言中，程序员不需要频繁地考虑栈空间和堆空间的区别。
 
 
但对于Rust这样的系统级编程语言来说，一个值被存储在栈上还是被存储在堆上会极大地影响到语言的行为，进而影响到我们编写代码时的设计抉择。
 
 
所有存储在栈中的数据都必须拥有一个已知且固定的大小。对于那些在编译期无法确定大小的数据，你就只能将它们存储在堆中。
 
 
由于指针的大小是固定的且可以在编译期确定，所以可以将指针存储在栈中。
 
 
向栈上推入数据要比在堆上进行分配更有效率一些，因为操作系统省去了搜索新数据存储位置的工作；这个位置永远处于栈的顶端。
 
 
由于多了指针跳转的环节，所以访问堆上的数据要慢于访问栈上的数据
 
 
处理器在操作排布紧密的数据（比如在栈上）时要比操作排布稀疏的数据（比如在堆上）有效率得多
 
 
许多系统编程语言都需要你记录代码中分配的堆空间，最小化堆上的冗余数据，并及时清理堆上的无用数据以避免耗尽空间
 
 
。而所有权概念则解决了这些问题。一旦你熟练地掌握了所有权及其相关工具，就可以将这些问题交给Rust处理，减轻用于思考栈和堆的心智负担。不过，知晓如何使用和管理堆内存可以帮助我们理解所有权存在的意义及其背后的工作原理。
 
 
所有权规则
 
 
• Rust中的每一个值都有一个对应的变量作为它的所有者。• 在同一时间内，值有且仅有一个所有者。• 当所有者离开自己的作用域时，它持有的值就会被释放掉。
 
 
之前接触的那些类型会将数据存储在栈上，并在离开自己的作用域时将数据弹出栈空间
 
 
Rust提供了第二种字符串类型String。这个类型会在堆上分配到自己需要的存储空间，所以它能够处理在编译时未知大小的文本
 
 
为什么String是可变的，而字符串字面量不是？这是因为它们采用了不同的内存处理方式。
 
 
对于字符串字面量而言，由于我们在编译时就知道其内容，所以这部分硬编码的文本被直接嵌入到了最终的可执行文件中。这就是访问字符串字面量异常高效的原因，而这些性质完全得益于字符串字面量的不可变性
 
 
• 我们使用的内存是由操作系统在运行时动态分配出来的。• 当使用完String时，我们需要通过某种方式来将这些内存归还给操作系统。
 
 
在调用String::from时完成，这个函数会请求自己需要的内存空间。
 
 
假如我们忘记释放内存，那么就会造成内存泄漏；假如我们过早地释放内存，那么就会产生一个非法变量；假如我们重复释放同一块内存，那么就会产生无法预知的后果。为了程序的稳定运行，我们必须严格地将分配和释放操作一一对应起来。
 
 
Rust提供了另一套解决方案：内存会自动地在拥有它的变量离开作用域后进行释放
 
 
Rust在变量离开作用域时，会调用一个叫作drop的特殊函数。
 
 
String类型的作者可以在这个函数中编写释放内存的代码。记住，Rust会在作用域结束的地方（即}处）自动调用drop函数。
 
 
在C++中，这种在对象生命周期结束时释放资源的模式有时也被称作资源获取即初始化（Resource Acquisition Is Initialization， RAII）
 
 
变量和数据交互的方式：移动
 
 
一个指向存放字符串内容的指针（ptr）、一个长度（len）及一个容量（capacity），这部分的数据存储在了栈中
 
 
当我们将s1赋值给s2时，便复制了一次String的数据，这意味着我们复制了它存储在栈上的指针、长度及容量字段。但需要注意的是，我们没有复制指针指向的堆数据。
 
 
Rust不会在复制值时深度地复制堆上的数据，
 
 
为了确保内存安全，同时也避免复制分配的内存，Rust在这种场景下会简单地将s1废弃，不再视其为一个有效的变量
 
 
。因此，Rust也不需要在s1离开作用域后清理任何东西。
 
 
假如你在其他语言中接触过浅度拷贝（shallow copy）和深度拷贝（deep copy）这两个术语，那么你也许会将这里复制指针、长度及容量字段的行为视作浅度拷贝。但由于Rust同时使第一个变量无效了，所以我们使用了新的术语移动（move）来描述这一行为，而不再使用浅度拷贝。
 
 
既然只有s2有效，那么也就只有它会在离开自己的作用域时释放空间，所以再也没有二次释放的可能性了。
 
 
Rust永远不会自动地创建数据的深度拷贝。因此在Rust中，任何自动的赋值操作都可以被视为高效的。
 
 
当你确实需要去深度拷贝String堆上的数据，而不仅仅是栈数据时，就可以使用一个名为clone的方法。
 
 
当你看到某处调用了clone时，你就应该知道某些特定的代码将会被执行，而且这些代码可能会相当消耗资源。
 
 
栈上数据的复制上面的讨论中遗留了一个没有提及的知识点。我们在示例4-2中曾经使用整型编写出了如下所示的合法代码：let x = 5;let y = x;println!("x = {}, y = {}", x, y);这与我们刚刚学到的内容似乎有些矛盾：即便代码没有调用clone，x在被赋值给y后也依然有效，且没有发生移动现象。这是因为类似于整型的类型可以在编译时确定自己的大小，并且能够将自己的数据完整地存储在栈中，对于这些值的复制操作永远都是非常快速的。这也同样意味着，在创建变量y后，我们没有任何理由去阻止变量x继续保持有效。换句话说，对于这些类型而言，深度拷贝与浅度拷贝没有任何区别，调用clone并不会与直接的浅度拷贝有任何行为上的区别。因此，我们完全不需要在类似的场景中考虑上面的问题。
 
 
Rust提供了一个名为Copy的trait，它可以用于整数这类完全存储在栈上的数据类型
 
 
一旦某种类型拥有了Copy这种trait，那么它的变量就可以在赋值给其他变量之后保持可用性。如果一种类型本身或这种类型的任意成员实现了Drop这种trait，那么Rust就不允许其实现Copy这种trait。
 
 
尝试给某个需要在离开作用域时执行特殊指令的类型实现Copy这种trait会导致编译时错误。
 
 
任何简单标量的组合类型都可以是Copy的，任何需要分配内存或某种资源的类型都不会是Copy的。
 
 
将变量传递给函数将会触发移动或复制，就像是赋值语句一样
 
 
变量所有权的转移总是遵循相同的模式：将一个值赋值给另一个变量时就会转移所有权。当一个持有堆数据的变量离开作用域时，它的数据就会被drop清理回收，除非这些数据的所有权移动到了另一个变量上。
 
 
假如你希望在调用函数时保留参数的所有权，那么就不得不将传入的值作为结果返回
 
 
可以利用元组来同时返回多个值
 
 
幸运的是，Rust针对这类场景提供了一个名为引用的功能。
引用与借用
 
新的函数签名使用了String的引用作为参数而没有直接转移值的所有权
 
 
表的就是引用语义，它们允许你在不获取所有权的前提下使用值。
 
 
与使用&进行引用相反的操作被称为解引用（dereferencing），它使用*作为运算符。
 
 
这里的&s1语法允许我们在不转移所有权的前提下，创建一个指向s1值的引用。由于引用不持有值的所有权，所以当引用离开当前作用域时，它指向的值也不会被丢弃。
 
 
当一个函数使用引用而不是值本身作为参数时，我们便不需要为了归还所有权而特意去返回值，毕竟在这种情况下，我们根本没有取得所有权。
 
 
这种通过引用传递参数给函数的方法也被称为借用（borrowing）
 
 
如果我们尝试着修改借用的值又会发生什么呢？不妨尝试一下示例4-6中的代码。剧透：这段代码无法通过编译！
 
 
与变量类似，引用是默认不可变的，Rust不允许我们去修改引用指向的值。
 
 
我们使用&mut s来给函数传入一个可变引用，并将函数签名修改为some_string: &mut String来使其可以接收一个可变引用作为参数。
 
 
但可变引用在使用上有一个很大的限制：对于特定作用域中的特定数据来说，一次只能声明一个可变引用。
 
 
在Rust中遵循这条限制性规则可以帮助我们在编译时避免数据竞争
 
 
。数据竞争（data race）与竞态条件十分类似，它会在指令满足以下3种情形时发生：• 两个或两个以上的指针同时访问同一空间。• 其中至少有一个指针会向空间中写入数据。• 没有同步数据访问的机制。
 
 
我们不能在拥有不可变引用的同时创建可变引用
 
 
Rust编译器可以为我们提早（在编译时而不是运行时）暴露那些潜在的bug，并且明确指出出现问题的地方。你不再需要去追踪调试为何数据会在运行时发生了非预期的变化。
 
 
悬垂引用使用拥有指针概念的语言会非常容易错误地创建出悬垂指针。这类指针指向曾经存在的某处内存地址，但该内存已经被释放掉甚至是被重新分配另作他用了。而在Rust语言中，编译器会确保引用永远不会进入这种悬垂状态。假如我们当前持有某个数据的引用，那么编译器可以保证这个数据不会在引用被销毁前离开自己的作用域。
 
 
• 在任何一段给定的时间里，你要么只能拥有一个可变引用，要么只能拥有任意数量的不可变引用。• 引用总是有效的。
切片
 
as_bytes方法❶将String转换为字节数组
 
 
enumerate则将iter的每个输出作为元素逐一封装在对应的元组中返回。元组的第一个元素是索引，第二个元素是指向集合中字节的引用。使用enumerate可以较为方便地获得迭代索引。
 
 
字符串切片是指向String对象中某个连续部分的引用
 
 
字符串切片的边界必须位于有效的UTF-8字符边界内
 
 
回忆一下借用规则，当我们拥有了某个变量的不可变引用时，我们就无法同时取得该变量的可变引用。由于clear需要截断当前的String实例，所以调用clear需要传入一个可变引用。
 
 
比较有经验的Rust开发者往往会采用下面的写法，这种改进后的签名使函数可以同时处理String与&str：fn first_word(s: &str) -> &str {
 
 
在定义函数时使用字符串切片来代替字符串引用会使我们的API更加通用，且不会损失任何功能
 
 
这里的切片类型是&[i32]，它在内部存储了一个指向起始元素的引用及长度，这与字符串切片的工作机制完全一样。你将在各
总结
 
所有权、借用和切片的概念是Rust可以在编译时保证内存安全的关键所在。
 
 
像其他系统级语言一样，Rust语言给予了程序员完善的内存使用控制能力。
定义并实例化结构体
 
一旦实例可变，那么实例中的所有字段都将是可变的。Rust不允许我们单独声明某一部分字段的可变性。
 
 
在变量名与字段名相同时使用简化版的字段初始化方法
 
 
参数与结构体字段拥有完全一致的名称，所以我们可以使用名为字段初始化简写（field init shorthand）的语法来重构build_user函数。这种语法不会改变函数的行为，但却能让我们免于在代码中重复书写email和username，
 
 
示例5-5所示。fn build_user(email: String, username: String) -> User {    User {        email,        username,        active: true,        sign_in_count: 1,    }}
 
 
使用结构体更新语法根据其他实例创建新实例
 
 
这里的双点号..表明剩下的那些还未被显式赋值的字段都与给定实例拥有相同的值。
 
 
let user2 = User {    email: String::from("another@example.com"),    username: String::from("anotherusername567"),    ..user1};
 
 
元组结构体同样拥有用于表明自身含义的名称，但你无须在声明它时对其字段进行命名，仅保留字段的类型即可
 
 
定义元组结构体时依然使用struct关键字开头，并由结构体名称及元组中的类型定义组成。
 
 
元组结构体实例的行为就像元组一样：你可以通过模式匹配将它们解构为单独的部分，你也可以通过. 及索引来访问特定字段。
 
 
当你想要在某些类型上实现一个trait，却不需要在该类型中存储任何数据时，空结构体就可以发挥相应的作用。
 
 
在结构体中存储指向其他数据的引用，不过这需要用到Rust中独有的生命周期功能
 
 
生命周期保证了结构体实例中引用数据的有效期不短于实例本身。
一个使用结构体的示例程序
 
在函数签名和调用过程中使用&进行引用是因为我们希望借用结构体，而不是获取它的所有权，这样main函数就可以保留rect1的所有权并继续使用它。
 
 
println! 宏可以执行多种不同的文本格式化命令，而作为默认选项，格式化文本中的花括号会告知println! 使用名为Display的格式化方法：这类输出可以被展示给直接的终端用户。
 
 
为了完成该声明，我们在结构体定义前添加了#[derive(Debug)]注解
 
 
Rust提供了许多可以通过derive注解来派生的trait，它们可以为自定义的类型增加许多有用的功能。
方法
 
方法与函数依然是两个不同的概念，因为方法总是被定义在某个结构体（或者枚举类型、trait对象，我们会在第6章和第17章分别介绍它们）的上下文中，并且它们的第一个参数永远都是self，用于指代调用该方法的结构体实例。
 
 
虽然Rust没有提供类似的->运算符，但作为替代，我们设计了一种名为自动引用和解引用的功能。方法调用是Rust中少数几个拥有这种行为的地方之一。
 
 
它的工作模式如下：当你使用object.something()调用方法时，Rust会自动为调用者object添加&、&mut或*，以使其能够符合方法的签名。换句话说，下面两种方法调用是等价的：p1.distance(&p2);(&p1).distance(&p2);
 
 
第一种调用看上去要简捷得多。这种自动引用行为之所以能够行得通，是因为方法有一个明确的作用对象：self的类型。在给出调用者和方法名的前提下，Rust可以准确地推导出方法是否是只读的（&self），是否需要修改数据（&mut self），是否会获取数据的所有权（self）。这种针对方法调用者的隐式借用在实践中可以让所有权系统更加友好且易于使用。
 
 
关联函数常常被用作构造器来返回一个结构体的新实例
 
 
我们可以在类型名称后添加::来调用关联函数
 
 
这里的::语法不仅被用于关联函数，还被用于模块创建的命名空间。
 
 
每个结构体可以拥有多个impl块。
总结
 
方法可以让我们为结构体实例指定行为，而关联函数则可以将那些不需要实例的特定功能放置到结构体的命名空间中。
第6章 枚举与模式匹配
 
Option，它常常被用来描述某些可能不存在的值
 
 
Rust中的枚举更类似于F#、OCaml和Haskell这类函数式编程语言中的代数数据类型（algebraic data type）
定义枚举
 
枚举的变体全都位于其标识符的命名空间中，并使用两个冒号来将标识符和变体分隔开来
 
 
枚举允许我们直接将其关联的数据嵌入枚举变体内
 
 
每个变体可以拥有不同类型和数量的关联数据
第7章 使用包、单元包及模块来管理日渐复杂的项目
 
一个包（package）可以拥有多个二进制单元包及一个可选的库单元包。
 
 
对于那些特别巨大的、拥有多个相互关联的包的项目，Cargo提供了另外一种解决方案：工作空间（workspace）
 
 
另外一个与组织和封装密切相关的概念被称为作用域（scope）：在编写代码的嵌套上下文中有一系列被定义在“作用域内”的名字。
 
 
• 包（package）：一个用于构建、测试并分享单元包的Cargo功能。• 单元包（crate）：一个用于生成库或可执行文件的树形模块结构。• 模块（module）及use关键字：它们被用于控制文件结构、作用域及路径的私有性。• 路径（path）：一种用于命名条目的方法，这些条目包括结构体、函数和模块等。
包与单元包
 
单元包可以被用于生成二进制程序或库。
 
 
首先，一个包中只能拥有最多一个库单元包。其次，包可以拥有任意多个二进制单元包。最后，包内必须存在至少一个单元包（库单元包或二进制单元包）。
微信读书