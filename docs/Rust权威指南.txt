《Rust权威指南》

史蒂夫·克拉伯尼克 卡罗尔·尼科尔斯
835个笔记

点评

◆ 2024/06/16 认为好看

花了很长时间入个门，大致全面了解个大概。有时间有兴趣可以看看。鉴于内容比较多（看完不牢固容易忘记）以及大家说的书版本比较旧。后续要继续深入还是任重道远。


第六章 前言

◆ 而在Rust的世界里，大部分的错误（甚至包括并发环境中产生的错误）都可以在编译阶段被编译器发现并拦截。得益于编译器这种类似于守门员的角色，开发团队可以在更多的时间内专注于业务逻辑而非错误调试。

◆ Cargo提供了一套内置的依赖管理与构建工具


第九章 第1章 入门指南

◆ 第1章入门指南



第一十章 安装

◆ 安装工具在执行的过程中会在本地生成一份离线的文档，你可以通过命令rustup doc在网页浏览器中打开它。



第一十一章 Hello, World!

◆ 标准Rust风格使用4个空格而不是Tab来实现缩进。

◆ Rust中所有以！结尾的调用都意味着你正在使用一个宏而不是普通函数。


第一十二章 Hello, Cargo!

◆ Cargo是Rust工具链中内置的构建系统及包管理器

◆ 在Rust中，我们把代码的集合称作包（crate）[1

◆ 首次使用命令cargo build构建的时候，它还会在项目根目录下创建一个名为Cargo.lock的新文件，这个文件记录了当前项目所有依赖库的具体版本号

◆ Cargo还提供了一个叫作cargo check的命令，你可以使用这个命令来快速检查当前的代码是否可以通过编译，而不需要花费额外的时间去真正生成可执行程序

◆ 通常来讲，由于cargo check跳过了生成可执行程序的步骤，所以它的运行速度要远远快于cargo build。假如你在编码的过程中需要不断通过编译器检查错误，那么使用cargo check就会极大地加速这个过程。事实上，大部分Rust用户在编写程序的过程中都会周期性地调用cargo check以保证自己的程序可以通过编译，只有真正需要生成可执行程序时才会调用cargo build。

◆ • 我们可以通过cargo build或cargo check来构建一个项目。
• 我们可以通过cargo run来构建并运行一个项目。
• 构建产生的结果会被Cargo存储在target/debug目录下，而非代码所处的位置。

◆ 当准备好发布自己的项目时，你可以使用命令cargo build --release在优化模式下构建并生成可执行程序。它生成的可执行文件会被放置在target/release目录下

◆ 这种模式会以更长的编译时间为代价来优化代码，从而使代码拥有更好的运行时性能。这也是存在两种不同的构建模式的原因。一种模式用于开发，它允许你快速地反复执行构建操作。而另一种模式则用于构建交付给用户的最终程序，这种构建场景不会经常发生，但却需要生成的代码拥有尽可能高效的运行时表现。值得指出的是，假如你想要对代码的运行效率进行基准测试，那么请确保你会通过cargo run --release命令进行构建，并使用target/release目录下的可执行程序完成基准测试

◆ crate是Rust中最小的编译单元，package是单个或多个crate的集合，crate和package都可以被叫作包，因为单个crate也是一个package，但package通常倾向于多个crate的组合。


第一十四章 第2章 编写一个猜数游戏

◆ 第2章编写一个猜数游戏


第二十一章 第3章 通用编程概念

◆ 第3章通用编程概念


第二十二章 变量与可变性

◆ Rust中的变量默认是不可变的

◆ 当一个变量是不可变的时，一旦它被绑定到某个值上面，这个值就再也无法被改变。

◆ Rust的编译器能够保证那些声明为不可变的值一定不会发生改变。这也意味着你无须在阅读和编写代码时追踪一个变量会如何变化，从而使代码逻辑更加易于理解和推导。

◆ 变量默认是不可变的，但你可以通过在声明的变量名称前添加mut关键字来使其可变。

◆ 在某些情况下，相较于不可变变量而言，可变变量会让代码变得更加易于编写。

◆ 除了避免出现bug，设计一个变量的可变性还需要考量许多因素。例如当你在使用某些重型数据结构时，适当地使用可变性去修改一个实例，可能比赋值和重新返回一个新分配的实例要更有效率；而当数据结构较为轻量的时候，采用更偏向函数式的风格，通过创建新变量来进行赋值，可能会使代码更加易于理解。在类似这样的情形下，为了可读性而损失少许的性能也许是值得的。

◆ 使用const关键字而不是let关键字来声明一个常量。在声明的同时，你必须显式地标注值的类型。

◆ 最后，你只能将常量绑定到一个常量表达式上，而无法将一个函数的返回值，或其他需要在运行时计算的值绑定到常量上。

◆ 在第2章的“比较猜测数字与保密数字”一节中，我们曾经看到一个新声明的变量可以覆盖掉旧的同名变量。在Rust世界中，我们把这一现象描述为：第一个变量被第二个变量隐藏（shadow）了。

◆ 隐藏机制不同于将一个变量声明为mut

◆ 隐藏机制与mut的另一个区别在于：由于重复使用let关键字会创建出新的变量，所以我们可以在复用变量名称的同时改变它的类型。


第二十三章 数据类型

◆ 标量类型（scalar）和复合类型（compound）。

◆ 标量类型是单个值类型的统称。Rust中内建了4种基础的标量类型：整数、浮点数、布尔值及字符。

◆ [插图]

◆ isize和usize两种特殊的整数类型，它们的长度取决于程序运行的目标平台。在64位架构上，它们就是64位的，而在32位架构上，它们就是32位的。

◆ 除了Byte，其余所有的字面量都可以使用类型后缀，比如57u8，代表一个使用了u8类型的整数57。

◆ 同时你也可以使用_作为分隔符以方便读数，比如1_000。

◆ Rust对于整数字面量的默认推导类型i32通常就是一个很好的选择：它在大部分情形下都是运算速度最快的那一个，即便是在64位系统上也是如此

◆ 。较为特殊的两个整数类型usize和isize则主要用作某些集合的索引。

◆ 如果你在编译时使用了带有--release标记的发布（release）模式，那么Rust就不会包含那些可能会触发panic的检查代码。作为替代，Rust会在溢出发生时执行二进制补码环绕。简而言之，任何超出类型最大值的数值都会被“环绕”为类型最小值。以u8为例，256会变为0，257会变为1，以此类推

◆ 假如你确实希望显式地进行环绕行为，那么你可以使用标准库中的类型Wrapping。

◆ 由于在现代CPU中f64与f32的运行效率相差无几，却拥有更高的精度，所以在Rust中，默认会将浮点数字面量的类型推导为f64。

◆ f32和f64类型分别对应着标准中的单精度浮点数和双精度浮点数。

◆ Rust中的char类型占4字节，是一个Unicode标量值，这也意味着它可以表示比ASCII多得多的字符内容。

◆ 复合类型（compound type）可以将多个不同类型的值组合为一个类型。

◆ Rust提供了两种内置的基础复合类型：元组（tuple）和数组（array）。

◆ 元组还拥有一个固定的长度：你无法在声明结束后增加或减少其中的元素数量。

◆ 元组每个位置的值都有一个类型，这些类型不需要是相同的。

◆ 使用模式匹配来解构元组

◆ src/main.rsfn main() {     let tup = (500, 6.4, 1);      let (x, y, z) = tup;      println!("The value of y is: {}", y); } 

◆ 除了解构，我们还可以通过索引并使用点号（.）来访问元组中的值

◆ 这段程序首先创建了一个元组x，随后又通过索引访问元组的各个元素，并将它们的值绑定到新的变量上。和大多数编程语言一样，元组的索引从0开始。

◆ 数组类型

◆ 与元组不同，数组中的每一个元素都必须是相同的类型。Rust中的数组拥有固定的长度，一旦声明就再也不能随意更改大小，这与其他某些语言有所不同。

◆ 通常而言，当你想在栈上而不是堆上为数据分配空间时，或者想要确保总有固定数量的元素时，数组是一个非常有用的工具

◆ Rust标准库也提供了一个更加灵活的动态数组（vector）类型。动态数组是一个类似于数组的集合结构，但它允许用户自由地调整数组长度。

◆ 这样撰写数组类型的方式有些类似于另一种初始化数组的语法，即假如你想要创建一个含有相同元素的数组，那么你可以在方括号中指定元素的值，并接着填入一个分号及数组的长度，如下所示：let a = [3; 5]；以a命名的数组将会拥有5个元素，而这些元素全部拥有相同的初始值3。这一写法等价于let a = [3, 3, 3, 3, 3];，但却更加精简。

◆ 数组由一整块分配在栈上的内存组成


第二十四章 函数

◆ Rust代码使用蛇形命名法（snake case）来作为规范函数和变量名称的风格

◆ 。蛇形命名法只使用小写的字母进行命名，并以下画线分隔单词。

◆ Rust不关心你在何处定义函数，只要这些定义对于使用区域是可见的即可。

◆ 在英语技术文档中，参数变量和传入的具体参数值有自己分别对应的名称parameter和argument，但我们通常会混用两者并将它们统一地称为参数而不加以区别。

◆ 由于Rust是一门基于表达式的语言，所以它将语句（statement）与表达式（expression）区别为两个不同的概念

◆ 语句指那些执行操作但不返回值的指令，而表达式则是指会进行计算并产生一个值作为结果的指令。

◆ 语句let y = 6;中的字面量6就是一个表达式，它返回6作为自己的计算结果。调用函数是表达式，调用宏是表达式，我们用来创建新作用域的花括号（{}）同样也是表达式

◆ fn main() {     let x = 5;   ❶ let y = {❷          let x = 3;      ❸  x + 1     };      println!("The value of y is: {}", y); } 表达式❷是一个代码块。在这个例子中，它会计算出4作为结果。而这个结果会作为let语句❶的一部分被绑定到变量y上。注意结尾处❸的表达式x + 1没有添加分号，这与我们之前见过的大部分代码不同。

◆ 假如我们在表达式的末尾加上了分号，这一段代码就变为了语句而不会返回任何值

◆ st中，函数的返回值等同于函数体最后一个表达式的值。你可以

◆ 你可以使用return关键字并指定一个值来提前从函数中返回，但大多数函数都隐式地返回了最后的表达式

◆ 但由于语句并不会产生值，所以Rust默认返回了一个空元组，也就是上面描述中的()

◆ 。实际的返回值类型与函数定义产生了矛盾，进而触发了编译时错误。


第二十六章 控制流

◆ 由于if是一个表达式，所以我们可以在let语句的右侧使用它来生成一个值

◆ let number = if condition {         5     } else {         6     }; 

◆ Rust提供了3种循环：loop、while和for。

◆ 我们可以将需要返回的值添加到break表达式后面，也就是我们用来终止循环的表达式后面

◆ fn main() {     let mut counter = 0;      let result = loop {         counter += 1;          if counter == 10 {             break counter * 2;         }     };      println!("The result is {}", result); } 

◆ 在循环之后，我们还使用了一个分号来结束当前的语句，这会将循环的返回结果赋值给result。

◆ 使用for循环这种更简明的方法来遍历集合中的每一个元素

◆ for循环的安全性和简捷性使它成为了Rust中最为常用的循环结构


第二十八章 第4章 认识所有权

◆ 第4章认识所有权

◆ 所有权可以说是Rust中最为独特的一个功能了。

◆ 正是所有权概念和相关工具的引入，Rust才能够在没有垃圾回收机制的前提下保障内存安全。

◆ 借用、切片，以及Rust在内存中布局数据的方式


第二十九章 什么是所有权

◆ 一般来讲，所有的程序都需要管理自己在运行时使用的计算机内存空间。某些使用垃圾回收机制的语言会在运行时定期检查并回收那些没有被继续使用的内存；而在另外一些语言中，程序员需要手动地分配和释放内存。

◆ Rust采用了与众不同的第三种方式：它使用包含特定规则的所有权系统来管理内存，这套规则允许编译器在编译过程中执行检查工作，而不会产生任何的运行时开销。

◆ 在许多编程语言中，程序员不需要频繁地考虑栈空间和堆空间的区别。

◆ 但对于Rust这样的系统级编程语言来说，一个值被存储在栈上还是被存储在堆上会极大地影响到语言的行为，进而影响到我们编写代码时的设计抉择。

◆ 所有存储在栈中的数据都必须拥有一个已知且固定的大小。对于那些在编译期无法确定大小的数据，你就只能将它们存储在堆中。

◆ 由于指针的大小是固定的且可以在编译期确定，所以可以将指针存储在栈中。

◆ 向栈上推入数据要比在堆上进行分配更有效率一些，因为操作系统省去了搜索新数据存储位置的工作；这个位置永远处于栈的顶端。

◆ 由于多了指针跳转的环节，所以访问堆上的数据要慢于访问栈上的数据

◆ 处理器在操作排布紧密的数据（比如在栈上）时要比操作排布稀疏的数据（比如在堆上）有效率得多

◆ 许多系统编程语言都需要你记录代码中分配的堆空间，最小化堆上的冗余数据，并及时清理堆上的无用数据以避免耗尽空间

◆ 。而所有权概念则解决了这些问题。一旦你熟练地掌握了所有权及其相关工具，就可以将这些问题交给Rust处理，减轻用于思考栈和堆的心智负担。不过，知晓如何使用和管理堆内存可以帮助我们理解所有权存在的意义及其背后的工作原理。

◆ 所有权规则

◆ • Rust中的每一个值都有一个对应的变量作为它的所有者。• 在同一时间内，值有且仅有一个所有者。• 当所有者离开自己的作用域时，它持有的值就会被释放掉。

◆ 变量作用域
由于我们在第2章完整地编写了一个Rust示例程序，所以接下来的示例代码会略过那些基本的语法，比如fn main() {等语句，你可以手动将下面的示例代码放置在main函数中来完成编译运行任务。这样处理后的示例会更加简单明了，使我们把注意力集中到具体的细节而不是冗余的代码上。
作为所有权的第一个示例，我们先来了解一下变量的作用域。简单来讲，作用域是一个对象在程序中有效的范围。假设有这样一个变量：
let s = "hello";

◆ 之前接触的那些类型会将数据存储在栈上，并在离开自己的作用域时将数据弹出栈空间

◆ Rust提供了第二种字符串类型String。这个类型会在堆上分配到自己需要的存储空间，所以它能够处理在编译时未知大小的文本

◆ 为什么String是可变的，而字符串字面量不是？这是因为它们采用了不同的内存处理方式。

◆ 对于字符串字面量而言，由于我们在编译时就知道其内容，所以这部分硬编码的文本被直接嵌入到了最终的可执行文件中。这就是访问字符串字面量异常高效的原因，而这些性质完全得益于字符串字面量的不可变性

◆ • 我们使用的内存是由操作系统在运行时动态分配出来的。• 当使用完String时，我们需要通过某种方式来将这些内存归还给操作系统。

◆ 在调用String::from时完成，这个函数会请求自己需要的内存空间。

◆ 假如我们忘记释放内存，那么就会造成内存泄漏；假如我们过早地释放内存，那么就会产生一个非法变量；假如我们重复释放同一块内存，那么就会产生无法预知的后果。为了程序的稳定运行，我们必须严格地将分配和释放操作一一对应起来。

◆ Rust提供了另一套解决方案：内存会自动地在拥有它的变量离开作用域后进行释放

◆ Rust在变量离开作用域时，会调用一个叫作drop的特殊函数。

◆ String类型的作者可以在这个函数中编写释放内存的代码。记住，Rust会在作用域结束的地方（即}处）自动调用drop函数。

◆ 在C++中，这种在对象生命周期结束时释放资源的模式有时也被称作资源获取即初始化（Resource Acquisition Is Initialization， RAII）

◆ 变量和数据交互的方式：移动

◆ 一个指向存放字符串内容的指针（ptr）、一个长度（len）及一个容量（capacity），这部分的数据存储在了栈中

◆ 当我们将s1赋值给s2时，便复制了一次String的数据，这意味着我们复制了它存储在栈上的指针、长度及容量字段。但需要注意的是，我们没有复制指针指向的堆数据。

◆ Rust不会在复制值时深度地复制堆上的数据，

◆ 为了确保内存安全，同时也避免复制分配的内存，Rust在这种场景下会简单地将s1废弃，不再视其为一个有效的变量

◆ 。因此，Rust也不需要在s1离开作用域后清理任何东西。

◆ 假如你在其他语言中接触过浅度拷贝（shallow copy）和深度拷贝（deep copy）这两个术语，那么你也许会将这里复制指针、长度及容量字段的行为视作浅度拷贝。但由于Rust同时使第一个变量无效了，所以我们使用了新的术语移动（move）来描述这一行为，而不再使用浅度拷贝。

◆ 既然只有s2有效，那么也就只有它会在离开自己的作用域时释放空间，所以再也没有二次释放的可能性了。

◆ Rust永远不会自动地创建数据的深度拷贝。因此在Rust中，任何自动的赋值操作都可以被视为高效的。

◆ 当你确实需要去深度拷贝String堆上的数据，而不仅仅是栈数据时，就可以使用一个名为clone的方法。

◆ 当你看到某处调用了clone时，你就应该知道某些特定的代码将会被执行，而且这些代码可能会相当消耗资源。

◆ 栈上数据的复制上面的讨论中遗留了一个没有提及的知识点。我们在示例4-2中曾经使用整型编写出了如下所示的合法代码：let x = 5;let y = x;println!("x = {}, y = {}", x, y);这与我们刚刚学到的内容似乎有些矛盾：即便代码没有调用clone，x在被赋值给y后也依然有效，且没有发生移动现象。这是因为类似于整型的类型可以在编译时确定自己的大小，并且能够将自己的数据完整地存储在栈中，对于这些值的复制操作永远都是非常快速的。这也同样意味着，在创建变量y后，我们没有任何理由去阻止变量x继续保持有效。换句话说，对于这些类型而言，深度拷贝与浅度拷贝没有任何区别，调用clone并不会与直接的浅度拷贝有任何行为上的区别。因此，我们完全不需要在类似的场景中考虑上面的问题。

◆ Rust提供了一个名为Copy的trait，它可以用于整数这类完全存储在栈上的数据类型

◆ 一旦某种类型拥有了Copy这种trait，那么它的变量就可以在赋值给其他变量之后保持可用性。如果一种类型本身或这种类型的任意成员实现了Drop这种trait，那么Rust就不允许其实现Copy这种trait。

◆ 尝试给某个需要在离开作用域时执行特殊指令的类型实现Copy这种trait会导致编译时错误。

◆ 任何简单标量的组合类型都可以是Copy的，任何需要分配内存或某种资源的类型都不会是Copy的。

◆ 将变量传递给函数将会触发移动或复制，就像是赋值语句一样

◆ [插图]

◆ 尝试在调用takes_ownership后使用变量s会导致编译时错误。

◆ 变量所有权的转移总是遵循相同的模式：将一个值赋值给另一个变量时就会转移所有权。当一个持有堆数据的变量离开作用域时，它的数据就会被drop清理回收，除非这些数据的所有权移动到了另一个变量上。

◆ 假如你希望在调用函数时保留参数的所有权，那么就不得不将传入的值作为结果返回

◆ 可以利用元组来同时返回多个值

◆ 幸运的是，Rust针对这类场景提供了一个名为引用的功能。


第三十章 引用与借用

◆ 新的函数签名使用了String的引用作为参数而没有直接转移值的所有权

◆ 表的就是引用语义，它们允许你在不获取所有权的前提下使用值。

◆ 与使用&进行引用相反的操作被称为解引用（dereferencing），它使用*作为运算符。

◆ 这里的&s1语法允许我们在不转移所有权的前提下，创建一个指向s1值的引用。由于引用不持有值的所有权，所以当引用离开当前作用域时，它指向的值也不会被丢弃。

◆ 当一个函数使用引用而不是值本身作为参数时，我们便不需要为了归还所有权而特意去返回值，毕竟在这种情况下，我们根本没有取得所有权。

◆ 这种通过引用传递参数给函数的方法也被称为借用（borrowing）

◆ 如果我们尝试着修改借用的值又会发生什么呢？不妨尝试一下示例4-6中的代码。剧透：这段代码无法通过编译！

◆ 与变量类似，引用是默认不可变的，Rust不允许我们去修改引用指向的值。

◆ 我们使用&mut s来给函数传入一个可变引用，并将函数签名修改为some_string: &mut String来使其可以接收一个可变引用作为参数。

◆ 但可变引用在使用上有一个很大的限制：对于特定作用域中的特定数据来说，一次只能声明一个可变引用。

◆ 在Rust中遵循这条限制性规则可以帮助我们在编译时避免数据竞争

◆ 。数据竞争（data race）与竞态条件十分类似，它会在指令满足以下3种情形时发生：• 两个或两个以上的指针同时访问同一空间。• 其中至少有一个指针会向空间中写入数据。• 没有同步数据访问的机制。

◆ 我们不能在拥有不可变引用的同时创建可变引用

◆ Rust编译器可以为我们提早（在编译时而不是运行时）暴露那些潜在的bug，并且明确指出出现问题的地方。你不再需要去追踪调试为何数据会在运行时发生了非预期的变化。

◆ 悬垂引用使用拥有指针概念的语言会非常容易错误地创建出悬垂指针。这类指针指向曾经存在的某处内存地址，但该内存已经被释放掉甚至是被重新分配另作他用了。而在Rust语言中，编译器会确保引用永远不会进入这种悬垂状态。假如我们当前持有某个数据的引用，那么编译器可以保证这个数据不会在引用被销毁前离开自己的作用域。

◆ 让我们试着来创建一个悬垂引用，并看一看Rust是如何在编译期发现这个错误的：
src/main.rs
fn main() { ￼    let reference_to_nothing = dangle(); ￼} ￼ ￼fn dangle() -> &String { ￼    let s = String::from("hello"); ￼ ￼    &s ￼}
出现的错误如下所示：
error[E0106]: missing lifetime specifier￼ --> dangle.rs:5:16￼  |​​5 | fn dangle() -> &String {￼  |                ^ expected lifetime parameter￼  |​​  = help: this function's return type contains a borrowed value, but there is￼  no value for it to be borrowed from￼  = help: consider giving it a 'static lifetime
这段错误提示信息包含了一个我们还没有接触到的新概念：生命周期，我们会在第10章详细地讨论它。不过，即使我们先将生命周期放置不管，这条错误提示信息也准确地指出了代码中的问题：
this function's return type contains a borrowed value, but there is no valuefor it to be borrowed from.[1]
回过头来仔细看一看我们的dangle函数中究竟发生了些什么：
src/main.rs
fn dangle() -> &String {      // dangle会返回一个指向String的引用​​    let s = String::from("hello");  // s被绑定到新的String上 ​​ ￼    &s // 我们将指向s的引用返回给调用者 ​​} // 变量s在这里离开作用域并随之被销毁，它指向的内存自然也不再有效。 ​​  // 危险！
由于变量s创建在函数dangle内，所以它会在dangle执行完毕时随之释放。但是，我们的代码依旧尝试返回一个指向s的引用，这个引用指向的是一个无效的String，这可不对！Rust成功地拦截了我们的危险代码。
解决这个问题的方法也很简单，直接返回String就好：
src/main.rs
fn no_dangle() -> String { ￼    let s = String::from("hello"); ￼ ￼    s ￼}
这种写法没有任何问题，所有权被转移出函数，自然也就不会涉及释放操作了。

◆ • 在任何一段给定的时间里，你要么只能拥有一个可变引用，要么只能拥有任意数量的不可变引用。• 引用总是有效的。


第三十一章 切片

◆ 除了引用，Rust还有另外一种不持有所有权的数据类型：切片（slice）。

◆ as_bytes方法❶将String转换为字节数组

◆ enumerate则将iter的每个输出作为元素逐一封装在对应的元组中返回。元组的第一个元素是索引，第二个元素是指向集合中字节的引用。使用enumerate可以较为方便地获得迭代索引。

◆ 字符串切片是指向String对象中某个连续部分的引用

◆ 字符串切片的边界必须位于有效的UTF-8字符边界内

◆ 字符串切片的类型写作&str

◆ 回忆一下借用规则，当我们拥有了某个变量的不可变引用时，我们就无法同时取得该变量的可变引用。由于clear需要截断当前的String实例，所以调用clear需要传入一个可变引用。

◆ 比较有经验的Rust开发者往往会采用下面的写法，这种改进后的签名使函数可以同时处理String与&str：fn first_word(s: &str) -> &str {

◆ 在定义函数时使用字符串切片来代替字符串引用会使我们的API更加通用，且不会损失任何功能

◆ 这里的切片类型是&[i32]，它在内部存储了一个指向起始元素的引用及长度，这与字符串切片的工作机制完全一样。你将在各


第三十二章 总结

◆ 所有权、借用和切片的概念是Rust可以在编译时保证内存安全的关键所在。

◆ 像其他系统级语言一样，Rust语言给予了程序员完善的内存使用控制能力。


第三十三章 第5章 使用结构体来组织相关联的数据

◆ 第5章使用结构体来组织相关联的数据


第三十四章 定义并实例化结构体

◆ 一旦实例可变，那么实例中的所有字段都将是可变的。Rust不允许我们单独声明某一部分字段的可变性。

◆ 在变量名与字段名相同时使用简化版的字段初始化方法

◆ 参数与结构体字段拥有完全一致的名称，所以我们可以使用名为字段初始化简写（field init shorthand）的语法来重构build_user函数。这种语法不会改变函数的行为，但却能让我们免于在代码中重复书写email和username，

◆ 示例5-5所示。fn build_user(email: String, username: String) -> User {    User {        email,        username,        active: true,        sign_in_count: 1,    }}

◆ 使用结构体更新语法根据其他实例创建新实例

◆ 这里的双点号..表明剩下的那些还未被显式赋值的字段都与给定实例拥有相同的值。

◆ let user2 = User {    email: String::from("another@example.com"),    username: String::from("anotherusername567"),    ..user1};

◆ 元组结构体同样拥有用于表明自身含义的名称，但你无须在声明它时对其字段进行命名，仅保留字段的类型即可

◆ 定义元组结构体时依然使用struct关键字开头，并由结构体名称及元组中的类型定义组成。

◆ 元组结构体实例的行为就像元组一样：你可以通过模式匹配将它们解构为单独的部分，你也可以通过. 及索引来访问特定字段。

◆ 当你想要在某些类型上实现一个trait，却不需要在该类型中存储任何数据时，空结构体就可以发挥相应的作用。

◆ 在结构体中存储指向其他数据的引用，不过这需要用到Rust中独有的生命周期功能

◆ 生命周期保证了结构体实例中引用数据的有效期不短于实例本身。


第三十五章 一个使用结构体的示例程序

◆ 在函数签名和调用过程中使用&进行引用是因为我们希望借用结构体，而不是获取它的所有权，这样main函数就可以保留rect1的所有权并继续使用它。

◆ println! 宏可以执行多种不同的文本格式化命令，而作为默认选项，格式化文本中的花括号会告知println! 使用名为Display的格式化方法：这类输出可以被展示给直接的终端用户。

◆ 宏调用会类似于println!("rect1 is {:?}, rect1);。我们把标识符号:?放入了花括号中，它会告知println! 当前的结构体需要使用名为Debug的格式化输出。Debug是另外一种格式化trait，它可以让我们在调试代码时以一种对开发者友好的形式打印出结构体。

◆ 为了完成该声明，我们在结构体定义前添加了#[derive(Debug)]注解

◆ Rust提供了许多可以通过derive注解来派生的trait，它们可以为自定义的类型增加许多有用的功能。


第三十六章 方法

◆ 方法与函数依然是两个不同的概念，因为方法总是被定义在某个结构体（或者枚举类型、trait对象，我们会在第6章和第17章分别介绍它们）的上下文中，并且它们的第一个参数永远都是self，用于指代调用该方法的结构体实例。

◆ #[derive(Debug)]￼struct Rectangle {￼    width: u32,￼    height: u32,￼}￼￼❶impl Rectangle {￼ ❷ fn area(&self) -> u32 {￼        self.width * self.height￼    }￼}￼￼fn main() {￼    let rect1 = Rectangle { width: 30, height: 50 };￼￼    println!(￼        "The area of the rectangle is {} square pixels.",￼    ❸  rect1.area()￼    );￼}

◆ 虽然Rust没有提供类似的->运算符，但作为替代，我们设计了一种名为自动引用和解引用的功能。方法调用是Rust中少数几个拥有这种行为的地方之一。

◆ 它的工作模式如下：当你使用object.something()调用方法时，Rust会自动为调用者object添加&、&mut或*，以使其能够符合方法的签名。换句话说，下面两种方法调用是等价的：p1.distance(&p2);(&p1).distance(&p2);

◆ 第一种调用看上去要简捷得多。这种自动引用行为之所以能够行得通，是因为方法有一个明确的作用对象：self的类型。在给出调用者和方法名的前提下，Rust可以准确地推导出方法是否是只读的（&self），是否需要修改数据（&mut self），是否会获取数据的所有权（self）。这种针对方法调用者的隐式借用在实践中可以让所有权系统更加友好且易于使用。
带有更多参数的方法

◆ 关联函数
除了方法，impl块还允许我们定义不用接收self作为参数的函数。由于这类函数与结构体相互关联，所以它们也被称为关联函数（associated function）。我们将其命名为函数而不是方法，是因为它们不会作用于某个具体的结构体实例。你曾经接触过的String::from就是关联函数的一种。

◆ 关联函数常常被用作构造器来返回一个结构体的新实例

◆ 我们可以在类型名称后添加::来调用关联函数

◆ 这里的::语法不仅被用于关联函数，还被用于模块创建的命名空间。

◆ 每个结构体可以拥有多个impl块。


第三十七章 总结

◆ 方法可以让我们为结构体实例指定行为，而关联函数则可以将那些不需要实例的特定功能放置到结构体的命名空间中。


第三十八章 第6章 枚举与模式匹配

◆ 第6章枚举与模式匹配

◆ Option，它常常被用来描述某些可能不存在的值

◆ Rust中的枚举更类似于F#、OCaml和Haskell这类函数式编程语言中的代数数据类型（algebraic data type）


第三十九章 定义枚举

◆ 枚举的变体全都位于其标识符的命名空间中，并使用两个冒号来将标识符和变体分隔开来

◆ 枚举允许我们直接将其关联的数据嵌入枚举变体内

◆ 每个变体可以拥有不同类型和数量的关联数据

◆ Rust并没有像许多其他语言一样支持空值。空值（Null）本身是一个值，但它的含义却是没有值。在设计有空值的语言中，一个变量往往处于这两种状态：空值或非空值。

◆ Tony Hoare，空值的发明者，曾经在2009年的一次演讲Null References: The Billion Dollar Mistake中提到：
这是一个价值数十亿美金的错误设计。当时，我正在为一门面向对象语言中的引用设计一套全面的类型系统。我的目标是，通过编译器自动检查来确保所有关于引用的操作都是百分之百安全的。但是我却没有抵挡住引入一个空引用概念的诱惑，仅仅是因为这样会比较容易去实现这套系统。这导致了无数的错误、漏洞和系统崩溃，并在之后的40多年中造成了价值数10亿美金的损失。
空值的问题在于，当你尝试像使用非空值那样使用空值时，就会触发某种程度上的错误。因为空或非空的属性被广泛散布在程序中，所以你很难避免引起类似的问题。
但是不管怎么说，

◆ 空值本身所尝试表达的概念仍然是有意义的：它代表了因为某种原因而变为无效或缺失的值。

◆ Rust中虽然没有空值，但却提供了一个拥有类似概念的枚举，我们可以用它来标识一个值无效或缺失

◆ 。这个枚举就是Option<T>，它在标准库中被定义为如下所示的样子：
enum Option<T> {￼    Some(T),￼    None,￼}


第四十章 控制流运算符match

◆ 匹配必须穷举所有的可能

◆ 这里的_模式可以匹配任何值。通过将它放置于其他分支后，可以使其帮我们匹配所有没有被显式指定出来的可能的情形。与它对应的代码块里只有一个()空元组，所以在_匹配下什么都不会发生


第四十一章 简单控制流if let

◆ 简单控制流if let

◆  some_u8_value = Some(0u8);￼match some_u8_value {￼    Some(3) => println!("three"),￼    _ => (),￼}
示例6-6：这里的match只在值为Some(3)时执行特定的代码


◆ 后额外加上一句_ => ()，这显得十分多余。
不过，我们可以使用if let以一种更加简短的方式实现这段代码。下面的代码与示例6-6中的match拥有完全一致的行为：
if let Some(3) = some_u8_value {￼    println!("three");￼}
这里的if let语法使用一对以=隔开的模式与表达式。它们所起的作用与match中的完全相同，表达式对应match中的输入，而模式则对应第一个分支。

◆ 换句话说，你可以将if let视作match的语法糖。它只在值满足某一特定模式时运行代码，而忽略其他所有的可能性。

◆ 我们还可以在if let中搭配使用else。else所关联的代码块在if let语句中扮演的角色，就如同match中_模式所关联的代码块一样

◆  mut count = 0;￼match coin {￼    Coin::Quarter(state) => println!("State quarter from {:?}!", state),￼    _ => count += 1,￼}
或者我们可以像下面这样使用if let与else表达式：
let mut count = 0;￼if let Coin::Quarter(state) = coin {￼    println!("State quarter from {:?}!", state);￼} else {￼    count += 1;￼}
如果你在编写程序的过程中，觉得在某些情形下使用match会过分烦琐，要记得在Rust工具箱中还有if let的存在。



第四十三章 第7章 使用包、单元包及模块来管理日渐复杂的项目

◆ 第7章使用包、单元包及模块来管理日渐复杂的项目

◆ 一个包（package）可以拥有多个二进制单元包及一个可选的库单元包。

◆ 对于那些特别巨大的、拥有多个相互关联的包的项目，Cargo提供了另外一种解决方案：工作空间（workspace）

◆ 另外一个与组织和封装密切相关的概念被称为作用域（scope）：在编写代码的嵌套上下文中有一系列被定义在“作用域内”的名字。

◆ 模块系统（module system）

◆ ，它们包括：

◆ • 包（package）：一个用于构建、测试并分享单元包的Cargo功能。• 单元包（crate）：一个用于生成库或可执行文件的树形模块结构。• 模块（module）及use关键字：它们被用于控制文件结构、作用域及路径的私有性。• 路径（path）：一种用于命名条目的方法，这些条目包括结构体、函数和模块等。


第四十四章 包与单元包

◆ 单元包可以被用于生成二进制程序或库。

◆ 首先，一个包中只能拥有最多一个库单元包。其次，包可以拥有任意多个二进制单元包。最后，包内必须存在至少一个单元包（库单元包或二进制单元包）。

◆ Cargo会默认将src/main.rs视作一个二进制单元包的根节点而无须指定，这个二进制单元包与包拥有相同的名称。同样地，假设包的目录中包含文件src/lib.rs，Cargo也会自动将其视作与包同名的库单元包的根节点。

◆ 我们可以在路径src/bin下添加源文件来创建出更多的二进制单元包，这个路径下的每个源文件都会被视作单独的二进制单元包。


第四十五章 通过定义模块来控制作用域及私有性

◆ 模块决定了一个条目是否可以被外部代码使用（公共），或者仅仅只是一个内部的实现细节而不对外暴露（私有）

◆ mod front_of_house {￼    mod hosting {￼        fn add_to_waitlist() {}￼￼        fn seat_at_table() {}￼    }￼￼    mod serving {￼        fn take_order() {}￼￼        fn serve_order() {}￼￼        fn take_payment() {}￼    }￼}

◆ src/main.rs与src/lib.rs被称作单元包的根节点，因为这两个文件的内容各自组成了一个名为crate的模块，并位于单元包模块结构的根部。这个模块结构也被称为模块树（module tree）。


◆ crate￼ └── front_of_house￼     ├── hosting￼     │   ├── add_to_waitlist￼     │   └── seat_at_table￼     └── serving￼         ├── take_order￼         ├── serve_order￼         └── take_payment

◆ 当模块A被包含在模块B内时，我们将模块A称作模块B的子节点（child），并将模块B称作模块A的父节点（parent）。

◆ 整个模块树都被放置在一个名为crate的隐式根模块下。

◆ 模块树也许会让你想起文件系统的目录树，实际上这是一个非常恰当的对比！正如文件系统中的目录一样，我们可以使用模块来组织代码；也正如目录中的文件一样，我们也需要对应的方法来定位模块。


第四十六章 用于在模块树中指明条目的路径

◆ 路径有两种形式：
• 使用单元包名或字面量crate从根节点开始的绝对路径。
• 使用self、super或内部标识符从当前模块开始的相对路径。

◆ 大部分的Rust开发者会更倾向于使用绝对路径，因为我们往往会彼此独立地移动代码的定义与调用代码。

◆ 模块不仅仅被用于组织代码，同时还定义了Rust中的私有边界（privacy boundary）：外部代码无法知晓、调用或依赖那些由私有边界封装了的实现细节。因此，当你想要将一个条目（比如函数或结构体）声明为私有时，你可以将它放置到某个模块中。
Rust中的所有条目（函数、方法、结构体、枚举、模块及常量）默认都是私有的。处于父级模块中的条目无法使用子模块中的私有条目，但子模块中的条目可以使用它所有祖先模块中的条目。

◆ Rust之所以选择让模块系统这样运作，是因为我们希望默认隐藏内部的实现细节。这样，你就能够明确地知道修改哪些内部实现不会破坏外部代码。同时，你也可以使用pub关键字来将某些条目标记为公共的，从而使子模块中的这些部分被暴露到祖先模块中。

◆ 将模块变为公开状态并不会影响到它内部条目的状态。模块之前的pub关键字仅仅意味着祖先模块拥有了指向该模块的权限。

◆ 私有性规则不仅作用于模块，也同样作用于结构体、枚举、函数及方法。

◆ mod front_of_house {￼    pub mod hosting {￼        pub fn add_to_waitlist() {}￼    }￼}￼￼pub fn eat_at_restaurant() {￼    // 绝对路径​​    crate::front_of_house::hosting::add_to_waitlist();￼￼    // 相对路径​​    front_of_house::hosting::add_to_waitlist();￼}

◆ 我们同样也可以从父模块开始构造相对路径，这一方式需要在路径起始处使用super关键字。它有些类似于在文件系统中使用..语法开始一段路径。

◆ 当我们在结构体定义前使用pub时，结构体本身就成为了公共结构体，但它的字段依旧保持了私有状态。我们可以逐一决定是否将某个字段公开。

◆ 相对应地，当我们将一个枚举声明为公共的时，它所有的变体都自动变为了公共状态。

◆ 公开一个枚举会同时将它的所有字段公开


第四十七章 用use关键字将路径导入作用域

◆ 基于路径来调用函数的写法看上去会有些重复与冗长。

◆ 幸运的是，有一种方法可以简化该步骤。我们可以借助use关键字来将路径引入作用域，并像使用本地条目一样来调用路径中的条目。

◆ 使用use将模块引入作用域

◆ 使用use来指定相对路径稍有一些不同。我们必须在传递给use的路径的开始处使用关键字self，而不是从当前作用域中可用的名称开始。

◆ Rust开发者们正在尝试去掉self前缀，也许在不久的将来我们能够避免在代码中使用它。

◆ 使用use将函数的父模块引入作用域意味着，我们必须在调用函数时指定这个父模块，从而更清晰地表明当前函数没有被定义在当前作用域中。当然，这一方式同样也尽可能地避免了重复完整路径。

◆ 当使用use将结构体、枚举和其他条目引入作用域时，我们习惯于通过指定完整路径的方式引入

◆ 使用use将同名类型引入作用域时所产生的问题还有另外一种解决办法：我们可以在路径后使用as关键字为类型指定一个新的本地名称，也就是别名

◆ 当我们使用use关键字将名称引入作用域时，这个名称会以私有的方式在新的作用域中生效。为了让外部代码能够访问到这些名称，我们可以通过组合使用pub与use实现。这项技术也被称作重导出（re-exporting），因为我们不仅将条目引入了作用域，而且使该条目可以被外部代码从新的作用域引入自己的作用域。

◆ 当代码的内部结构与外部所期望的访问结构不同时，重导出技术会显得非常有用。例如，在这个餐厅的比喻中，餐厅的员工会以“前厅”和“后厨”来区分工作区域，但访问餐厅的顾客则不会以这样的术语来考虑餐厅的结构。通过使用pub use，我们可以在编写代码时使用一种结构，而在对外部暴露时使用另外一种不同的结构。这一方法可以让我们的代码库对编写者与调用者同时保持良好的组织结构。

◆ Cargo.toml中添加rand作为依赖会指派Cargo从crates.io上下载rand及相关的依赖包，并使rand对当前的项目可用。

◆ 使用嵌套的路径来清理众多use语句

◆ use std::{cmp::Ordering, io};￼// ---略---

◆ 这两条路径拥有共同的std::io前缀，该前缀还是第一条路径本身。为了将这两条路径合并至一行use语句中，我们可以在嵌套路径中使用self

◆ use std::io::{self, Write}

◆ 假如你想要将所有定义在某个路径中的公共条目都导入作用域，那么可以在指定路径时在后面使用*通配符：

◆ use std::collections::*;

◆ 请小心谨慎地使用这一特性！通配符会使你难以确定作用域中存在哪些名称，以及某个名称的具体定义位置

◆ 测试代码常常会使用通配符将所有需要测试的东西引入tests模块


第四十八章 将模块拆分为不同的文件

◆ 将模块拆分为不同的文件

◆ 在mod front_of_house后使用分号而不是代码块会让Rust前往与当前模块同名的文件中加载模块内容。

◆ 我们使用mod关键字声明模块，并指示Rust在同名文件中搜索模块内的代码。


第四十九章 总结

◆ 总结
Rust允许你将包拆分为不同的单元包，并将单元包拆分为不同的模块，从而使你能够在其他模块中引用某个特定模块内定义的条目。为了引用外部条目，你需要指定它们的绝对路径或相对路径。我们可以通过use语句将这些路径引入作用域，接着在该作用域中使用较短的路径来多次使用对应的条目。模块中的代码是默认私有的，但你可以通过添加pub关键字来将定义声明为公共的。


第五十章 第8章 通用集合类型

◆ 第8章通用集合类型

◆ 与内置的数组与元组类型不同，这些集合将自己持有的数据存储在了堆上。


第五十一章 使用动态数组存储多个值

◆ 创建动态数组

◆ let v: Vec<i32> = Vec::new();

◆ let v = vec![1, 2, 3];

◆ let mut v = Vec::new();￼￼v.push(5);￼v.push(6);￼v.push(7);￼v.push(8);

◆ 正如第3章讨论过的，对于任何变量，只要我们想要改变它的值，就必须使用关键字mut来将其声明为可变的。由于Rust可以从数据中推断出我们添加的值都是i32类型的，所以此处同样不需要添加Vec<i32>的类型声明

◆ 两种访问动态数组的方式，它们分别是使用索引和get方法。

◆ 使用&与[]会直接返回元素的引用；而接收索引作为参数的get方法则会返回一个Option<&T>。

◆ []方法会因为索引指向了不存在的元素而导致程序触发panic。假如你希望在尝试越界访问元素时使程序直接崩溃，那么这个方法就再适合不过了。

◆ get方法会在检测到索引越界时简单地返回None，而不是使程序直接崩溃。

◆ 回忆一下所有权规则，我们不能在同一个作用域中同时拥有可变引用与不可变引用。示例8-7便遵循了该规则。在这个例子中，我们持有了一个指向动态数组中首个元素的不可变引用，但却依然尝试向这个动态数组的结尾处添加元素，该尝试是不会成功的。
let mut v = vec![1, 2, 3, 4, 5];￼￼let first = &v[0];￼￼v.push(6);￼println!("The first element is: {}", first);
示例8-7：在存在指向动态数组元素的引用时尝试向动态数组中添加元素

◆ 动态数组中的元素是连续存储的，插入新的元素后也许会没有足够多的空间将所有元素依次相邻地放下，这就需要分配新的内存空间，并将旧的元素移动到新的空间上。

◆ 我们同样也可以遍历可变的动态数组，获得元素的可变引用，并修改其中的值。示例8-9中的for循环会让动态数组中的所有元素的值增加50。
let mut v = vec![100, 32, 57];￼for i in &mut v {￼    *i += 50;￼}

◆ 使用枚举来存储多个类型的值
在本章开始的时候，我们曾经提到过动态数组只能存储相同类型的值。这个限制可能会带来不小的麻烦，实际工作中总是会碰到需要存储一些不同类型值的情况。幸运的是，当我们需要在动态数组中存储不同类型的元素时，可以定义并使用枚举来应对这种情况，因为枚举中的所有变体都被定义为了同一种枚举类型。
假设我们希望读取表格中的单元值，这些单元值可能是整数、浮点数或字符串，那么就可以使用枚举的不同变体来存放不同类型的值。所有的这些枚举变体都会被视作统一的类型：也就是这个枚举类型。接着，我们便可以创建一个持有该枚举类型的动态数组来存放不同类型的值，如示例8-10所示。
enum SpreadsheetCell {￼    Int(i32),￼    Float(f64),￼    Text(String),￼}￼￼let row = vec![￼    SpreadsheetCell::Int(3),￼    SpreadsheetCell::Text(String::from("blue")),￼    SpreadsheetCell::Float(10.12),￼];
示例8-10：在动态数组中使用定义的枚举来存储不同类型的值


◆ 假如Rust允许动态数组存储任意类型，那么在对动态数组中的元素进行操作时，就有可能会因为一个或多个不当的类型处理而导致错误。将枚举和match表达式搭配使用意味着，Rust可以在编译时确保所有可能的情形都得到妥当的处理

◆ 假如你没有办法在编写程序时穷尽所有可能出现在动态数组中的值类型，那么就无法使用枚举。为了解决这一问题，我们需要用到在第17章会介绍的动态trait。


第五十二章 使用字符串存储UTF-8编码的文本

◆ Rust在语言核心部分只有一种字符串类型，那就是字符串切片str，它通常以借用的形式（&str）出现。正如在第4章讨论的那样，字符串切片是一些指向存储在别处的UTF-8编码字符串的引用。例如，字符串字面量的数据被存储在程序的二进制文件中，而它们本身也是字符串切片的一种。


◆ 我们可以对那些实现了Display trait的类型调用to_string方法，如同字符串字面量一样。

◆  data = "initial contents";￼￼let s = data.to_string();￼￼// 这个方法同样也可以直接作用于字面量：￼let s = "initial contents".to_string();
示例8-12：使用to_string方法基于字符串字面量创建String

◆ String::from和to_string实际上完成了相同的工作，你可以根据自己的喜好来选择使用哪种方法。

◆ String的大小可以增减，其中的内容也可以修改，正如我们将数据推入其中时Vec<T>内部数据所发生的变化一样。此外，我们还可以方便地使用+运算符或format! 宏来拼接String。
使用push_str或push向字符串中添加内容

◆  s1 = String::from("Hello, ");￼let s2 = String::from("world!");￼let s3 = s1 + &s2; // 注意这里的s1已经被移动且再也不能被使用了
示例8-18：使用+运算符将两个String合并到一个新的String中

◆ 首先，代码中的s2使用了&符号，这意味着我们实际上是将第二个字符串的引用与第一个字符串相加了，正如add函数中的s参数所指明的那样：我们只能将&str与String相加，而不能将两个String相加。但是等等，&s2的类型是&String，而add函数中的第二个参数的类型则是&str。为什么示例8-18依然能够通过编译呢？
我们能够使用&s2来调用add函数的原因在于：编译器可以自动将&String类型的参数强制转换为&str类型。当我们调用add函数时，Rust使用了一种被称作解引用强制转换的技术，将&s2转换为了&s2[..]。我们将在第15章更加深入地讨论解引用强制转换这一概念。由于add并不会取得函数签名中参数s的所有权，因此变量s2将在执行这一操作后依旧保留一个有效的String值。
其次，我们可以看到add函数签名中的self并没有&标记，所以add函数会取得self的所有权。这也意味着示例8-18中的s1将会被移动至add函数调用中，并在调用后失效。所以，即便let s3 = s1 + &s2;看起来像是复制两个字符串并创建一个新的字符串，但实际上这条语句会取得s1的所有权，再将s2中的内容复制到其中，最后再将s1的所有权作为结果返回。换句话说，它看起来好像进行了很多复制，但实际上并没有，这种实现要比单纯的复制更加高效。

◆ 有这么多+及"字符的情况下，你很难去分析其中的具体实现。对于这种复杂一些的字符串合并，我们可以使用format! 宏

◆ format! 宏与println! 宏的工作原理完全相同，不过不同于println! 将结果打印至屏幕，format! 会将结果包含在一个String中返回。这段使用format! 的代码要更加易读，并且不会夺取任何参数的所有权。

◆ Rust中的字符串并不支持索引。

◆ String实际上是一个基于Vec<u8>的封装类型。

◆ let len = String::from("Hola").len();
在这行代码中，len方法将会返回4，这意味着动态数组所存储的字符串Hola占用了4字节。在编码为UTF-8时，每个字符都分别占用1字节。那么，下面这个例子是否也符合这样的规律呢？（注意，这个字符串中的首字母是西里尔字母中的Ze，而不是阿拉伯数字3。）
let len = String::from("Здравствуйте").len();
首先来猜一下这个字符串的长度，你给出的答案也许是12。但实际上，Rust返回的结果是24：这就是使用UTF-8编码来存储"Здравствуйте"所需要的字节数，因为这个字符串中的每个Unicode标量值都需要占据2字节。发现了吧，对字符串中字节的索引并不总是能对应到一个有效的Unicode标量值。为了演示这一行为，让我们来看一看下面这段非法的Rust代码：
let hello = "Здравствуйте";￼let answer = &hello[0];
这段代码中的answer值会是多少呢？它应该是首字母З吗？当使用UTF-8编码时，З依次使用了208、151两字节空间，所以这里的answer应该是208吧，但208本身却又不是一个合法的字符。请求字符串中首字母的用户可不会希望获得一个208的返回值，可这又偏偏是Rust在索引0处取到的唯一字节数据。用户想要的结果通常不会是一个字节值，即便这个字符串只由拉丁字母组成：如果我们将&"hello"[0]视作合法的代码，那么它会返回一个字节值104，而不是h。为了避免返回意想不到的值，以及出现在运行时才会暴露的错误，Rust会直接拒绝编译这段代码，在开发阶段提前杜绝可能的误解。


◆ 使用UTF-8编码还会引发另外一个问题。在Rust中，我们实际上可以通过3种不同的方式来看待字符串中的数据：字节、标量值和字形簇（最接近人们眼中字母的概念）。

◆ 假如我们尝试存入一个使用梵文书写的印度语单词“￼”，那么该单词在动态数组中存储的u8值看起来会像下面一样：
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,224, 165, 135]
这里有18字节，也是计算机最终存储数据的样子。假如我们将它们视作Unicode标量值，也就是Rust中的char类型，那么这些字节看起来会像是：
￼
这里有6个char值，但实际上第四个与第六个并不能算作字母：它们本身没有任何意义，只是作为音标存在。最后，假如我们将它们视作字形簇，就会得到通常意义上的印度语字符：
￼
Rust中提供了不同的方式来解析存储在计算机中的字符串数据，以便于程序员们自行选择所需的解释方式，而不用关心具体的语言类型。
Rust不允许我们通过索引来获得String中的字符还有最后一个原因，那就是索引操作的复杂度往往会被预期为常数时间（O(1)）。但在String中，我们无法保障这种做法的性能，因为Rust必须要遍历从头至索引位置的整个内容来确定究竟有多少合法的字符存在。


◆ 尝试通过索引引用字符串通常是一个坏主意，因为字符串索引操作应当返回的类型是不明确的：究竟应该是字节，还是字符，或是字形簇，甚至是字符串切片呢？因此，如果真的想要使用索引来创建字符串切片，Rust会要求你做出更加明确的标记。为了明确表明需要一个字符串切片，你需要在索引的[]中填写范围来指定所需的字节内容，而不是在[]中使用单个数字进行索引：
let hello = "Здравствуйте";￼￼let s = &hello[0..4];

◆ 在这段代码中，s将会是一个包含了字符串前4字节的&str。前面曾提到过，这里的每个字符都会占据2字节，这也意味着s中的内容将是Зд。
假如我们在这里尝试使用&hello[0..1]会发生什么呢？答案是，Rust会如同我们在动态数组中使用非法索引时一样，在运行时发生panic。
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`',￼src/libcore/str/mod.rs:2188:4
切记要小心谨慎地使用范围语法创建字符串切片，因为错误的指令会导致程序崩溃。

◆ 幸运的是，还有其他访问字符串中元素的方法。
假如你想要对每一个Unicode标量值都进行处理，那么最好的办法就是使用chars方法。针对字符串“￼”调用chars会分别返回6个类型为char的值，接着就可以遍历这个结果来访问每个元素了：
for c in "".chars() {￼    println!("{}", c);￼}

◆ 而bytes方法则会依次返回每个原始字节，这在某些场景下可能会有用：
for b in "".bytes() {￼    println!("{}", b);￼}
这段代码会打印出组成这个String的18个字节值：
224￼164￼// --略--￼165￼135
但是请记住，合法的Unicode标量值可能会需要占用1字节以上的空间。


◆ 从字符串中获取字形簇相对复杂一些，所以标准库中也没有提供这个功能。如果你有这方面的需求，那么可以在crates.io上获取相关的开源库


第五十三章 在哈希映射中存储键值对

◆ use std::collections::HashMap;￼￼let mut scores = HashMap::new();￼￼scores.insert(String::from("Blue"), 10);￼scores.insert(String::from("Yellow"), 50);

◆ 另外一个构建哈希映射的方法是，在一个由键值对组成的元组动态数组上使用collect方法。

◆ use std::collections::HashMap;￼￼let teams  = vec![String::from("Blue"), String::from("Yellow")];￼let initial_scores = vec![10, 50];￼￼let scores: HashMap<_, _> =￼teams.iter().zip(initial_scores.iter()).collect();

◆ 这里的类型标记HashMap<_, _>不能被省略，因为collect可以作用于许多不同的数据结构，如果不指明类型的话，Rust就无法知道我们具体想要的类型。但是对于键值的类型参数，我们则使用了下画线占位，因为Rust能够根据动态数组中的数据类型来推导出哈希映射所包含的类型。

◆ 哈希映射与所有权
对于那些实现了Copy trait的类型，例如i32，它们的值会被简单地复制到哈希映射中。而对于String这种持有所有权的值，其值将会转移且所有权会转移给哈希映射，如示例8-22所示。
use std::collections::HashMap;￼￼let field_name = String::from("Favorite color");￼let field_value = String::from("Blue");￼￼let mut map = HashMap::new();￼map.insert(field_name, field_value);￼// filed_name和field_value从这一刻开始失效，若尝试使用它们则会导致编译错误！

◆ 一旦键值对被插入，其所有权就会转移给哈希映射

◆ 假如我们只是将值的引用插入哈希映射，那么这些值是不会被移动到哈希映射中的。这些引用所指向的值必须要保证，在哈希映射有效时自己也是有效的。

◆ 我们会在第10章的“使用生命周期保证引用的有效性”一节中详细地讨论这个问题。

◆ 类似于动态数组，我们同样可以使用一个for循环来遍历哈希映射中所有的键值对：
use std::collections::HashMap;￼￼let mut scores = HashMap::new();￼￼scores.insert(String::from("Blue"), 10);￼scores.insert(String::from("Yellow"), 50);￼￼for (key, value) in &scores {￼    println!("{}: {}", key, value);￼}
这段代码会将

◆ use std::collections::HashMap;￼￼let mut scores = HashMap::new();￼scores.insert(String::from("Blue"), 10);￼￼scores.entry(String::from("Yellow")).or_insert(50);￼scores.entry(String::from("Blue")).or_insert(50);￼￼println!("{:?}", scores);
示例8-25：通过使用entry方法在键不存在对应值时插入数据


◆ 基于旧值来更新值
哈希映射的另外一个常见用法是查找某个键所对应的值，并基于这个值来进行更新。比如，示例8-26中的代码用于计算一段文本中每个单词所出现的次数。我们使用了一个以单词作为键的哈希映射来记录它们所出现的次数。在遍历的过程中，假如出现了一个新的单词，我们就先将值0插入哈希映射中。
use std::collections::HashMap;￼￼let text = "hello world wonderful world";￼￼let mut map = HashMap::new();￼￼for word in text.split_whitespace() {￼    let count = map.entry(word).or_insert(0);￼    *count += 1;￼}￼￼println!("{:?}", map);

◆ 使用哈希映射来存储并计算单词出现的次数

◆ 运行这段代码会输出{"world": 2, "hello": 1, "wonderful": 1}。代码中的方法or_insert实际上为我们传入的键返回了一个指向关联值的可变引用（&mut V）。这个可变引用进而被存储到变量count上，为了对这个值进行赋值操作，我们必须首先使用星号（*）来对count进行解引用。由于这个可变引用会在for循环的结尾处离开作用域，所以我们在代码中的所有修改都是安全且满足借用规则的。

◆ 哈希函数
为了提供抵御拒绝服务攻击（DoS，Denial of Service）的能力，HashMap默认使用了一个在密码学上安全的哈希函数。这确实不是最快的哈希算法，不过为了更高的安全性付出一些性能代价通常是值得的。假如你在对代码进行性能分析的过程中，发现默认哈希函数成为了你的性能热点并导致性能受损，你也可以通过指定不同的哈希计算工具来使用其他函数。这里的哈希计算工具特指实现了BuildHasher trait的类型。我们会在第10章讨论trait，以及如何实现它们。你并不一定非要从头实现自己的哈希工具，Rust开发者们已经在crates.io上分享了许多基于不同哈希算法的开源项目。


第五十五章 第9章 错误处理

◆ 第9章错误处理


◆ 在Rust中，我们将错误分为两大类：可恢复错误与不可恢复错误。

◆ 其他大部分的编程语言都没有刻意地区分这两种错误，而是通过异常之类的机制来统一处理它们。虽然Rust没有类似的异常机制，但它提供了用于可恢复错误的类型Result<T, E>，以及在程序出现不可恢复错误时中止运行的panic! 宏


第五十六章 不可恢复错误与panic!

◆ panic中的栈展开与终止
当panic发生时，程序会默认开始栈展开。这意味着Rust会沿着调用栈的反向顺序遍历所有调用函数，并依次清理这些函数中的数据。但是为了支持这种遍历和清理操作，我们需要在二进制中存储许多额外信息。除了展开，我们还可以选择立即终止程序，它会直接结束程序且不进行任何清理工作，程序所使用过的内存只能由操作系统来进行回收。假如项目需要使最终二进制包尽可能小，那么你可以通过在Cargo.toml文件中的[profile]区域添加panic = 'abort'来将panic的默认行为从展开切换为终止。例如，如果你想要在发布模式中使用终止模式，那么可以在配置文件中加入：
[profile.release]￼panic = 'abort'

◆ C这样的语言中，程序在这种情况下依然会尝试返回你所请求的值，即便这可能会与你所期望的并不相符：你会得到动态数组中对应这个索引位置的内存，而这个内存可能存储了其他数据，甚至都不属于动态数组本身。这种情形也被称为缓冲区溢出（buffer overread），并可能导致严重的安全性问题。攻击者可以通过操纵索引来访问存储在数组后面的、那些不被允许读取的数据。

◆ 为了保护我们的程序，避免出现类似的漏洞，当你尝试读取一个非法索引指向的元素时，Rust会拒绝继续执行代码，并终止程序。

◆ 通过设置环境变量RUST_BACKTRACE来得到回溯信息，进而确定触发错误的原因。回溯中包含了到达错误点的所有调用函数列表。在Rust中使用回溯的方式与在其他语言中的使用方式类似：从头开始查看回溯列表，直至定位到自己所编写代码的文件，而这也正是产生问题的地方。从定位到文件的那一行往上是我们代码所调用的代码，往下则是调用了我们代码的代码。这些调用中可能会包含Rust核心库、标准库，以及你所使用的第三方库。

◆ 为了获取这些带有调试信息的回溯，你必须启用调试符号（debug symbol）

◆ 。在运行cargo build或cargo run命令时，如果没有附带--release标志，那么调试符号就是默认开启的


第五十七章 可恢复错误与Result

◆ 可恢复错误与Result

◆ Result枚举定义了两个变体—Ok和Err，如下所示：
enum Result<T, E> {￼    Ok(T),￼    Err(E),￼}

◆ use std::fs::File;￼￼fn main() {￼    let f = File::open("hello.txt");￼￼    let f = match f {￼        Ok(file) => file,￼        Err(error) => {￼            panic!("There was a problem opening the file: {:?}", error)￼        },￼    };￼}

◆ 使用match表达式来处理所有可能的Result变体


◆ 与Option枚举一样，Result枚举及其变体已经通过预导入模块被自动地引入当前作用域中，所以我们不需要在使用Ok变体与Err变体之前在match分支中显式地声明Result::。

◆ 匹配不同的错误

◆ use std::fs::File;￼use std::io::ErrorKind;￼￼fn main() {￼    let f = File::open("hello.txt");￼￼    let f = match f {￼        Ok(file) => file,￼        Err(error) => match error.kind() {￼            ErrorKind::NotFound => match File::create("hello.txt") {￼                Ok(fc) => fc,￼                Err(e) => panic!("Tried to create file but there was a problem: {:?}", e),￼            },￼            other_error => panic!("There was a problem opening the file: {:?}", other_error),￼        },￼    };￼}
示例9-5：用不同的方式处理不同的错误类型

◆ Result<T,E>通过使用match表达式实现了许多接收闭包的方法；我们会在第13章开始学习闭包。一个更有经验的Rust开发者可能会像下面这样实现示例9-5中的代码：
src/main.rs
use std::fs::File;￼use std::io::ErrorKind;￼￼fn main() {￼    let f = File::open("hello.txt").map_err(|error| {￼        if error.kind() == ErrorKind::NotFound {￼            File::create("hello.txt").unwrap_or_else(|error| {￼                panic!("Tried to create file but there was a problem: {:?}", error);￼            })￼        } else {￼            panic!("There was a problem opening the file: {:?}", error);￼        }￼    });￼}

◆ 在处理错误时，有许多类似的方法可以简化嵌套的match表达式。

◆ 失败时触发panic的快捷方式：unwrap和expect

◆ 当Result的返回值是Ok变体时，unwrap就会返回Ok内部的值。而当Result的返回值是Err变体时，unwrap则会替我们调用panic! 宏。

◆ 还有另外一个被称作expect的方法，它允许我们在unwrap的基础上指定panic! 所附带的错误提示信息。

◆ 传播错误的模式在Rust编程中非常常见，所以Rust专门提供了一个问号运算符（?）来简化它的语法。


◆ 传播错误的快捷方式：?运算符

◆ 假如这个Result的值是Ok，那么包含在Ok中的值就会作为这个表达式的结果返回并继续执行程序。假如值是Err，那么这个值就会作为整个程序的结果返回，如同使用了return一样将错误传播给调用者。

◆ ?运算符帮助我们消除了大量模板代码，使函数实现更为简单。我们甚至还可以通过链式方法调用来进一步简化这些代码

◆ use std::io;￼use std::io::Read;￼use std::fs::File;￼￼fn read_username_from_file() -> Result<String, io::Error> {￼    let mut s = String::new();￼￼    File::open("hello.txt")?.read_to_string(&mut s)?;￼￼    Ok(s)￼}
示例9-8：?运算符后面的链式方法调用


◆ ?运算符只能被用于返回Result的函数

◆ 使用了？运算符的函数必须返回Result、Option或任何实现了std::ops::Try的类型。在那些没有返回上述类型的函数里，一旦调用的其他函数返回了Result<T, E>，就需要使用match或Result<T, E>自身的方法来对Result<T, E>进行恰当的处理。当然，你也可以选择在合适的条件下将函数的返回类型修改为Result<T, E>。

◆ 对于特殊的main函数而言，可用的返回类型除了()，还有更加方便的Result<T, E>，如下所示：
use std::error::Error;￼use std::fs::File;￼￼fn main() -> Result<(), Box<dyn Error>> {￼    let f = File::open("hello.txt")?;￼￼    Ok(())￼}
这里的Box<dyn Error>被称作trait对象，我们将在第17章讨论它。现在，你可以简单地将Box<dyn Error>理解为“任何可能的错误类型”。在拥有这种返回类型的main函数中使用？运算符是合法的。


第五十八章 要不要使用panic!

◆ 我们会在定义一个可能失败的函数时优先考虑使用Result方案。

◆ 当你编写示例用于演示某些概念时，为了增强健壮性而添加的错误处理代码往往会减弱示例的可读性

◆ 假如错误是可预期的，那么就应该返回一个Result而不是调用panic!。

◆ 尝试访问不属于当前数据结构的内存是一个普遍的安全性问题。函数通常都有某种约定：它们只在输入数据满足某些特定条件时才能正常运行。在约定被违反时触发panic是合理的，因为破坏约定往往预示着调用产生了bug，而这不是我们希望用户显式去处理的错误类型。

◆ 相比于到处重复验证代码，我们可以创建一个新的类型，并在创建的类型实例的函数中对值进行有效性检查。这样就可以在函数签名中安全地使用新类型，而无须担心我们所接收的值的有效性了。示例9-10展示了定义Guess类型的一种方法，它只有在new函数接收到一个1～100之间的数字时才会创建Guess实例。
❶pub struct Guess {￼    value: i32,￼}￼￼impl Guess {￼ ❷ pub fn new(value: i32) -> Guess {￼     ❸ if value < 1 || value > 100 {￼         ❹ panic!("Guess value must be between 1 and 100, got {}.", value);￼        }￼￼     ❺ Guess {￼            value￼        }￼    }￼

◆ ￼ ❻ pub fn value(&self) -> i32 {￼        self.value￼    }￼}


第六十章 第10章 泛型、trait与生命周期

◆ 第10章泛型、trait与生命周期

◆ 在定义泛型时，使用trait可以将其限制为拥有某些特定行为的类型，而不是任意类型。


第六十二章 泛型数据类型

◆  largest<T>(list: &[T]) -> T {￼    let mut largest = list[0];￼￼    for &item in list.iter() {￼        if item > largest {￼            largest = item;￼        }￼    }￼￼    largest￼}￼￼fn main() {￼    let number_list = vec![34, 50, 25, 100, 65];￼￼    let result = largest(&number_list);￼    println!("The largest number is {}", result);￼￼    let char_list = vec!['y', 'm', 'a', 'q'];￼￼    let result = largest(&char_list);￼    println!("The largest char is {}", result);￼}
示例10-5：使用泛型参数定义的largest函数，目前还无法通过编译
假如我们立即尝试编译这段代码，就会出现如下错误提示信息：
error[E0369]: binary operation `>` cannot be applied to type `T`￼ --> src/main.rs:5:12￼  |￼5 |         if item > largest {￼  |            ^^^^^^^^^^^^^^￼  |￼  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
这段错误提示信息中提到的std::cmp::PartialOrd是一个trait，我们将在下一节来讨论它。简单来讲，这个错误表明largest函数中的代码不能适用于T所有可能的类型。因为函数体中的相关语句需要比较类型T的值，这个操作只能被用于可排序的值类型。我们可以通过实现标准库中的std::cmp::PartialOrd trait来为类型实现比较功能。

◆ 你可以在定义中使用任意多个泛型参数，但要注意，过多的泛型会使代码难以阅读。通常来讲，当你需要在代码中使用很多泛型时，可能就意味着你的代码需要重构为更小的片段。


◆ 类似于结构体，枚举定义也可以在它们的变体中存放泛型数据

◆ enum Option<T> {￼    Some(T),￼    None,￼}
你现在应该能够理解这个定义了。正如你所见，Option<T>是一个拥有泛型T的枚举。它拥有两个变体：持有T类型值的Some变体，以及一个不持有任何值的None变体。Option<T>被我们用来表示一个值可能存在的抽象概念

◆ 枚举同样也可以使用多个泛型参数

◆ enum Result<T, E> {￼    Ok(T),￼    Err(E),￼}
Result枚举拥有两个泛型：T和E。它也同样拥有两个变体：持有T类型值的Ok，以及一个持有E类型值的Err。

◆ 这个定义使得Result枚举可以很方便地被用在操作可能成功（返回某个T类型的值），也可能失败（返回某个E类型的错误）的场景。

◆ 泛型代码的性能问题

◆ Rust实现泛型的方式决定了使用泛型的代码与使用具体类型的代码相比不会有任何速度上的差异。
为了实现这一点，Rust会在编译时执行泛型代码的单态化（monomorphization）。单态化是一个在编译期将泛型代码转换为特定代码的过程，它会将所有使用过的具体类型填入泛型参数从而得到有具体类型的代码。

◆ 在这个过程中，编译器所做的工作与我们在示例10-5中创建泛型函数时相反：它会寻找所有泛型代码被调用过的地方，并基于该泛型代码所使用的具体类型生成代码。
让我们看一看这套机制是怎么在标准库的Option<T>枚举上生效的：
let integer = Some(5);￼let float = Some(5.0);
当Rust编译这段代码时，就会开始执行单态化。编译器会首先读取在Option<T>实例中被使用过的值，进而确定存在两种Option<T>：一种是i32，另一种是f32。因此，它会将Option<T>的泛型定义展开为Option_i32与Option_f64，接着再将泛型定义替换为这两个具体类型定义。
单态化后的代码如下所示。Option<T>被替换为了编译器所生成的特定定义：
src/main.rs
enum Option_i32 {￼￼    Some(i32),￼    None,￼}￼￼enum Option_f64 {￼    Some(f64),￼    None,￼}￼￼fn main() {￼    let integer = Option_i32::Some(5);￼    let float = Option_f64::Some(5.0);￼}
正是由于Rust会将每一个实例中的泛型代码编译为特定类型的代码，所以我们无须为泛型的使用付出任何运行时的代价。当运行泛型代码时，其运行效果和我们手动重复每个定义的运行效果一样。单态化使Rust的泛型代码在运行时极其高效。


第六十三章 trait：定义共享行为

◆ trait（特征）被用来向Rust编译器描述某些特定类型拥有的且能够被其他类型共享的功能，它使我们可以以一种抽象的方式来定义共享行为。我们还可以使用trait约束来将泛型参数指定为实现了某些特定行为的类型。


◆ trait与其他语言中常被称为接口（interface）的功能类似，但也不尽相同。

◆ pub trait Summary {￼    fn summarize(&self) -> String;￼}

◆ 一个trait可以包含多个方法：每个方法签名占据单独一行并以分号结尾。

◆ pub struct NewsArticle {￼    pub headline: String,￼    pub location: String,￼    pub author: String,￼    pub content: String,￼}￼￼impl Summary for NewsArticle {￼    fn summarize(&self) -> String {￼        format!("{}, by {} ({})", self.headline, self.author, self.location)￼    }￼}￼￼pub struct Tweet {￼    pub username: String,￼    pub content: String,￼    pub reply: bool,￼    pub retweet: bool,￼}￼￼impl Summary for Tweet {￼    fn summarize(&self) -> String {￼        format!("{}: {}", self.username, self.content)￼    }￼}

◆ 实现trait有一个限制：只有当trait或类型定义于我们的库中时，我们才能为该类型实现对应的trait。

◆ 这一规则也是程序一致性（coherence）的组成部分，它确保了其他人所编写的内容不会破坏到你的代码，反之亦然。如果没有这条规则，那么两个库可以分别对相同的类型实现相同的trait，Rust将无法确定应该使用哪一个版本

◆ 有些时候，为trait中的某些或所有方法都提供默认行为非常有用，它使我们无须为每一个类型的实现都提供自定义行为。当我们在为某个特定类型实现trait时，可以选择保留或重载每个方法的默认行为。

◆ fn summarize(&self) -> String {￼        String::from("(Read more...)")￼    }￼}
示例10-14：拥有默认summarize方法实现的Summary trait定义


◆ 我们还可以在默认实现中调用相同trait中的其他方法，哪怕这些方法没有默认实现。

◆ pub trait Summary {￼    fn summarize_author(&self) -> String;￼￼    fn summarize(&self) -> String {￼        format!("(Read more from {}...)", self.summarize_author())￼    }￼}

◆ 注意，我们是无法在重载方法实现的过程中调用该方法的默认实现的

◆ 使用trait作为参数


◆ pub fn notify(item: impl Summary) {￼    println!("Breaking news! {}", item.summarize());￼}

◆ trait约束
这里的impl Trait常被用在一些较短的示例中，但它其实只是trait约束（trait bound）的一种语法糖。它的完整形式如下所示：
pub fn notify<T: Summary>(item: T) {￼    println!("Breaking news! {}", item.summarize());￼}
这种较长的形式完全等价于之前的示例，只是后面的写法会稍显臃肿一些

◆ 什么时候才应该使用完整形式而不是impl Trait呢？简单来说，impl Trait更适用于短小的示例，而trait约束则更适用于复杂情形。例如，假设我们需要接收两个都实现了Summary的参数，那么使用impl Trait的写法如下所示：
pub fn notify(item1: impl Summary, item2: impl Summary) {
只要item1和item2可以使用不同的类型（同时都实现了Summary），这段代码就没有任何问题。但是，如果你想强迫两个参数使用同样的类型，又应当怎么处理呢？此时你就只能使用trait约束了：
pub fn notify<T: Summary>(item1: T, item2: T) {
泛型T指定了参数item1与item2的类型，它同时也决定了函数为item1与item2接收的参数值必须拥有相同的类型。

◆ 通过+语法来指定多个trait约束
假如notify函数需要在调用summarize方法的同时显示格式化后的item，那么item就必须实现两个不同的trait：Summary和Display。我们可以使用+语法做到这一点：
pub fn notify(item: impl Summary + Display) {
这一语法在泛型的trait约束中同样有效：
pub fn notify<T: Summary + Display>(item: T) {
通过指定的两个trait约束，可以在notify函数体中调用summarize，并使用{}来格式化item。

◆ 使用where从句来简化trait约束
使用过多的trait约束也有一些缺点。因为每个泛型都拥有自己的trait约束，定义有多个泛型参数的函数可能会有大量的trait约束信息需要被填写在函数名与参数列表之间。这往往会使函数签名变得难以理解。为了解决这一问题，Rust提供了一个替代语法，使我们可以在函数签名之后使用where从句来指定trait约束。所以，相比于下面的代码：
fn some_function<T: Display + Clone, U: Clone + Debug>(t: T, u: U) -> i32 {
我们可以使用where从句改写为：
fn some_function<T, U>(t: T, u: U) -> i32￼    where T: Display + Clone,￼          U: Clone + Debug￼{
这时的函数签名就没有那么杂乱了。函数名、参数列表及返回类型的排布要紧密得多，与没有trait约束的函数相差无几。

◆ 返回实现了trait的类型


◆ fn returns_summarizable() -> impl Summary {￼    Tweet {￼        username: String::from("horse_ebooks"),￼        content: String::from("of course, as you probably already know, people"),￼        reply: false,￼        retweet: false,￼    }￼}

◆ 第13章中，我们将会学习两个重度依赖于trait的功能：闭包（closure）与迭代器（iterator）。这些功能会创建出只有编译器才知道的或签名长到难以想象的类型。impl Trait使你可以精练地声明函数会返回实现了Iterator trait的类型，而不需要写出具体的类型。
但是，你只能在返回一个类型时使用impl Trait。例如，下面这段代码中返回的NewsArticle和Tweet都实现了impl Summary，却依然无法通过编译：
fn returns_summarizable(switch: bool) -> impl Summary {￼    if switch {￼        NewsArticle {￼            headline: String::from("Penguins win the Stanley Cup Championship!"),￼            location: String::from("Pittsburgh, PA, USA"),￼            author: String::from("Iceburgh"),￼            content: String::from("The Pittsburgh Penguins once again are the best￼            hockey team in the NHL."),￼        }￼    } else {￼        Tweet {￼            username: String::from("horse_ebooks"),￼            content: String::from("of course, as you probably already know, people"),￼            reply: false,￼            retweet: false,￼        }￼    }￼}

◆ 在第17章的“使用trait对象来存储不同类型的值”一节中，我们会讲到如何编写类似功能的函数。


◆ 使用trait约束来修复largest函数

◆ 在largest的函数体中，我们想要使用大于（>）运算符来比较两个T类型的值。由于这一运算符被定义为标准库trait std::cmp::PartialOrd的一个默认方法，所以我们需要在T的trait约束中指定PartialOrd，才能够使largest函数用于任何可比较类型的切片上。由于PartialOrd位于预导入模块内，所以我们不需要手动将其引入作用域。

◆ 当我们编写largest函数的非泛型版本时，我们只尝试过搜索i32和char类型的最大值。正如在第4章讨论过的那样，i32或char这样拥有确定大小并被存储在栈上的类型，已经实现了Copy trait。但是当我们尝试将largest函数泛型化时，list参数中的类型有可能是没有实现Copy trait的。这也就意味着，我们无法将list[0]中的值移出并绑定到largest变量上，进而会导致上面的错误。
为了确保这个函数只会被那些实现了Copy trait的类型所调用，我们可以把Copy加入T的trait约束中！示例10-15展示了largest函数泛型版本的完整代码，只要我们传入函数的切片值类型实现了PartialOrd和Copy这两个trait，该示例中的代码就能正常通过编译。
src/main.rs
fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {￼    let mut largest = list[0];￼￼    for &item in list.iter() {￼        if item > largest {￼            largest = item;￼        }￼    }￼￼    largest￼}￼￼fn main() {￼    let number_list = vec![34, 50, 25, 100, 65];￼￼    let result = largest(&number_list);￼    println!("The largest number is {}", result);￼￼    let char_list = vec!['y', 'm', 'a', 'q'];￼￼    let result = largest(&char_list);￼    println!("The largest char is {}", result);￼}
示例10-1

◆ ：largest函数可以被用于任何实现了PartialOrd与Copy这两个trait的泛型

◆ 假如我们不希望使largest函数只能使用那些实现了Copy trait的类型，那么可以用Clone来替换T trait约束中的Copy。接着，当需要在largest函数中取得切片中某个值的所有权时，我们就可以使用克隆方法。当然，一旦搜索对象是类似于String之类的存储在堆上的类型时，使用clone函数就意味着我们会执行更多堆分配操作，而当需要处理大量数据时，执行堆分配可能会相当缓慢。
另一种可能的largest实现方式是返回切片中T值的引用。假如将返回类型从T修改为&T，并修改函数体使其返回一个引用，那么我们就不再需要Clone或Copy来进行trait约束了，同时可以避免执行堆分配操作。不妨自己尝试着实现一下这种方案吧！

◆ 使用trait约束来有条件地实现方法
通过在带有泛型参数的impl代码块中使用trait约束，我们可以单独为实现了指定trait的类型编写方法。例如，示例10-16中的类型Pair<T>都会实现new函数，但只有在内部类型T实现了PartialOrd（用于比较）与Display（用于打印）这两个trait的前提下，才会实现cmd_display方法。
use std::fmt::Display;￼￼struct Pair<T> {￼    x: T,￼    y: T,￼}￼￼impl<T> Pair<T> {￼    fn new(x: T, y: T) -> Self {￼        Self {￼            x,￼            y,￼        }￼    }￼}￼￼impl<T: Display + PartialOrd> Pair<T> {￼    fn cmp_display(&self) {￼        if self.x >= self.y {￼            println!("The largest member is x = {}", self.x);￼        } else {￼            println!("The largest member is y = {}", self.y);￼        }￼    }￼}
示例10-16：根据泛型的trait约束来有条件地实现方法

◆ 我们同样可以为实现了某个trait的类型有条件地实现另一个trait。对满足trait约束的所有类型实现trait也被称作覆盖实现（blanket implementation），这一机制被广泛地应用于Rust标准库中。例如，标准库对所有满足Display trait约束的类型实现了ToString trait。标准库中的impl代码块如下所示：
impl<T: Display> ToString for T {￼    // --略--￼}

◆ 由于标准库提供了上面的覆盖实现，所以我们可以为任何实现了Display trait的类型调用ToString trait中的to_string方法。例如，我们可以像下面一样将整数转换为对应的String值，因为整数实现了Display：
let s = 3.to_string();
有关覆盖实现的描述信息在对应trait文档中的“implementors”部分可以找到。
借助于trait和trait约束，我们可以在使用泛型参数来消除重复代码的同时，向编译器指明自己希望泛型拥有的功能。而编译器则可以利用这些trait约束信息来确保代码中使用的具体类型提供了正确的行为。

◆ 在动态语言中，尝试调用一个类型没有实现的方法会导致在运行时出现错误。但是，Rust将这些错误出现的时期转移到了编译期，并迫使我们在运行代码之前修复问题。我们无须编写那些用于在运行时检查行为的代码，因为这些工作已经在编译期完成了。这一机制在保留泛型灵活性的同时提升了代码的性能。

◆ 生命周期是另外一种你已经接触过的泛型。普通泛型可以确保类型拥有期望的行为，与之不同的是，生命周期能够确保引用在我们的使用过程中一直有效


第六十四章 使用生命周期保证引用的有效性

◆ 使用生命周期保证引用的有效性
我们在第4章的“引用与借用”一节中有意地跳过了一些细节：Rust的每个引用都有自己的生命周期（lifetime），它对应着引用保持有效性的作用域。在大多数时候，生命周期都是隐式且可以被推导出来的，就如同大部分时候类型也是可以被推导的一样。当出现了多个可能的类型时，我们就必须手动声明类型。类似地，当引用的生命周期可能以不同的方式相互关联时，我们就必须手动标注生命周期。Rust需要我们注明泛型生命周期参数之间的关系，来确保运行时实际使用的引用一定是有效的。
生命周期的概念不同于其他编程语言中的工具，从某种意义上说，它也是Rust最与众不同的特性。

◆ 生命周期最主要的目标在于避免悬垂引用

◆ 示例10-17中的程序，它包含了一个外部作用域及一个内部作用域。
{￼ ❶ let r;￼￼    {￼     ❷ let x = 5;￼     ❸ r = &x;￼ ❹ }￼￼ ❺ println!("r: {}", r);￼}
示例10-17：尝试在值离开作用域时使用指向它的引用
注意
示例10-17、10-18及10-24中的代码声明了一些未被初始化的变量，以便这些变量名可以存在于外部作用域中。初看起来，这好像与Rust中不存在空值的设计相矛盾。但实际上，只要我们尝试在赋值前使用这些变量就会触发编译时错误。Rust中确实不允许空值存在！
上面的代码在外部作用域中声明了一个名为r的未初始化变量❶，而内部作用域则声明了一个初始值为5的变量x❷。在内部作用域中，我们尝试将r的值设置为指向x的引用❸。接着，当内部作用域结束时❹，尝试去打印出r所指向的值❺。这段代码将无法通过编译，因为在我们使用r时，它所指向的值已经离开了作用域。下面是相关的错误提示信息：
error[E0597]: `x` does not live long enough￼  --> src/main.rs:7:5￼   |￼6  |         r = &x;￼   |              - borrow occurs here￼7  |     }￼   |     ^ `x` dropped here while still borrowed￼...￼10 | }￼   | - borrowed value needs to live until here
上面的错误提示信息指出，变量x的存活周期不够长。这是因为x在到达第7行，也就是内部作用域结束时离开了自己的作用域。而r对于整个外部作用域始终是有效的，它的作用域要更大一些，也就是我们所说的“存活得更久一些”。假如Rust允许这段代码运行，r就会引用到在x离开作用域时已经释放的内存，这时任何基于r所进行的操作都无法正确地进行。那么，Rust是如何确定这段代码并不合法的呢？它使用了一个叫作借用检查器的工具。
借用检查器
Rust编译器拥有一个借用检查器（borrow checker），它被用于比较不同的作用域并确定所有借用的合法性

◆ 函数中的泛型生命周期
让我们来编写一个函数，用于返回两个字符串切片中较长的一个。这个函数会接收两个字符串切片作为参数，并返回一个字符串切片作为结果。当我们实现了longest函数之后，示例10-20中的代码应该会打印出The longest string is abcd。
src/main.rs
fn main() {￼    let string1 = String::from("abcd");￼    let string2 = "xyz";￼￼    let result = longest(string1.as_str(), string2);￼    println!("The longest string is {}", result);￼}
示例10-20：main函数会调用longest函数来找到两个字符串切片中较长的一个
需要注意的是，因为我们并不希望longest取得参数的所有权，所以它应该可以接收字符串切片（也就是引用）作为参数。同时，我们还希望这个函数既能处理String切片（也就是变量string1的类型），又能处理字符串字面量（也就是变量string2所存储的）。
如果你还不太清楚我们为什么对使用的参数有如上要求，那么你可以参考第4章的“将字符串切片作为参数”一节。
不过，假如试着像示例10-21一样实现longest函数，那么它将无法通过编译。
src/main.rs
fn longest(x: &str, y: &str) -> &str {￼    if x.len() > y.len() {￼        x￼    } else {￼        y￼    }￼}
示例10-21：用于返回两个字符串切片中较长的那一个的longest函数，但目前还无法通过编译
在编译过程中会触发涉及生命周期的错误：
error[E0106]: missing lifetime specifier￼ --> src/main.rs:1:33￼  |￼1 | fn longest(x: &str, y: &str) -> &str {￼  |                                 ^ expected lifetime parameter￼  |￼  = help: this function's return type contains a borrowed value, but the￼signature does not say whether it is borrowed from `x` or `y`
帮助文本解释了具体的错误原因：我们需要给返回类型标注一个泛型生命周期参数，因为Rust并不能确定返回的引用会指向x还是指向y。实际上，即便是编写代码的我们也无法做出这个判断。因为函数体中的if代码块返回了x的引用，而else代码块则返回了y的引用。
在我们定义这个函数的时候，我们并不知道会被传入函数的具体值，所以也不能确定到底是if分支还是else分支会得到执行。我们同样也无法知晓传入的引用的具体生命周期，所以就无法像示例10-18和10-19那样通过分析作用域来确定返回的引用是否有效。借用检查器自然也无法确定这一点，因为它不知道x与y的生命周期是如何与返回值的生命周期相关联的。为了解决这个问题，我们会添加一个泛型生命周期参数，并用它来定义引用之间的关系，进而使借用检查器可以正常地进行分析。


◆ 生命周期的标注并不会改变任何引用的生命周期长度。如同使用了泛型参数的函数可以接收任何类型一样，使用了泛型生命周期的函数也可以接收带有任何生命周期的引用。在不影响生命周期的前提下，标注本身会被用于描述多个引用生命周期之间的关系。


◆ 生命周期的标注使用了一种明显不同的语法：它们的参数名称必须以撇号（'）开头，且通常使用全小写字符。与泛型一样，它们的名称通常也会非常简短。'a被大部分开发者选择作为默认使用的名称。我们会将生命周期参数的标注填写在&引用运算符之后，并通过一个空格符来将标注与引用类型区分开来。

◆ 单个生命周期的标注本身并没有太多意义，标注之所以存在是为了向Rust描述多个泛型生命周期参数之间的关系

◆ 函数签名中的生命周期标注

◆ 在这个签名中我们所表达的意思是：参数与返回值中的所有引用都必须拥有相同的生命周期。

◆ fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {￼    if x.len() > y.len() {￼        x￼    } else {￼        y￼    }￼}

◆ 当我们在函数签名中指定生命周期参数时，我们并没有改变任何传入值或返回值的生命周期。我们只是向借用检查器指出了一些可以用于检查非法调用的约束。

◆ 当我们在函数中标注生命周期时，这些标注会出现在函数签名而不是函数体中。Rust可以独立地完成对函数内代码的分析。但是，当函数开始引用或被函数外部的代码所引用时，想要单靠Rust自身来确定参数或返回值的生命周期，就几乎是不可能的了。函数所使用的生命周期可能在每次调用中都会发生变化。这也正是我们需要手动对生命周期进行标注的原因。

◆ 当我们将具体的引用传入longest时，被用于替代'a的具体生命周期就是作用域x与作用域y重叠的那一部分。换句话说，泛型生命周期'a会被具体化为x与y两者中生命周期较短的那一个

◆ 。因为我们将返回的引用也标记为了生命周期参数'a，所以返回的引用在具化后的生命周期范围内都是有效的。


◆ fn main() {￼    let string1 = String::from("long string is long");￼    let result;￼    {￼        let string2 = String::from("xyz");￼        result = longest(string1.as_str(), string2.as_str());￼    }￼    println!("The longest string is {}", result);￼}
示例10-24：尝试在string2离开作用域后使用result
当我们尝试编译这段代码时，就会出现如下所示的错误：
error[E0597]: `string2` does not live long enough￼  --> src/main.rs:15:5￼   |￼14 |         result = longest(string1.as_str(), string2.as_str());￼   |                                            ------- borrow occurs here￼15 |     }￼   |     ^ `string2` dropped here while still borrowed￼16 |     println!("The longest string is {}", result);￼17 | } ￼   | - borrowed value needs to live until here
这里错误提示信息的意思是，为了使println! 语句中的result是有效的，string2需要一直保持有效，直到外部作用域结束的地方。因为我们在函数参数与返回值中使用了同样的生命周期参数'a，所以Rust才会指出这些问题。
对人类而言，我们可以确定string1中的字符要长于string2，进而确定result中将会持有指向string1的引用。由于string1在我们使用println! 语句时还没有离开自己的作用域，所以这个指向string1的引用应该是完全合法的才对。但是，编译器无法在这种情形下得出引用一定有效的结论。不过，我们曾经告诉过Rust，longest函数返回的引用的生命周期与传入的引用的生命周期中较短的那一个相同。仅在这一约束下，还是有可能出现非法引用的，因此借用检查器拒绝编译示例10-12中的代码。

◆ 当函数返回一个引用时，返回类型的生命周期参数必须要与其中一个参数的生命周期参数相匹配。当返回的引用没有指向任何参数时，那么它只可能是指向了一个创建于函数内部的值，由于这个值会因为函数的结束而离开作用域，所以返回的内容也就变成了悬垂引用。

◆ 无论我们怎么改变生命周期参数，都无法阻止悬垂引用的产生，而Rust并不允许创建悬垂引用。在本例中，最好的解决办法就是返回一个持有自身所有权的数据类型而不是引用，这样就可以将清理值的责任转移给函数调用者了。

◆ 从根本上说，生命周期语法就是用来关联一个函数中不同参数及返回值的生命周期的。一旦它们形成了某种联系，Rust就获得了足够的信息来支持保障内存安全的操作，并阻止那些可能会导致悬垂指针或其他违反内存安全的行为。

◆ 结构体定义中的生命周期标注

◆ struct ImportantExcerpt<'a> {￼ ❷ part: &'a str,￼}￼￼fn main() {￼ ❸ let novel = String::from("Call me Ishmael. Some years ago...");￼ ❹ let first_sentence = novel.split('.')￼        .next()￼        .expect("Could not find a '.'");￼ ❺ let i = ImportantExcerpt { part: first_sentence };￼}

◆ 这个标注意味着ImportantExcerpt实例的存活时间不能超过存储在part字段中的引用的存活时间。

◆ 生命周期省略

◆ 任何引用都有一个生命周期，并且需要为使用引用的函数或结构体指定生命周期参数

◆ 然而，在第4章的示例4-9中我们曾经编写过一个函数，它在没有任何生命周期标注的情况下正常地通过了编译，示例10-26展示了该函数的详细版本。
src/lib.rs
fn first_word(s: &str) -> &str {￼    let bytes = s.as_bytes();￼￼    for (i, &item) in bytes.iter().enumerate() {￼        if item == b' ' {￼            return &s[0..i];￼        }￼    }￼￼    &s[..]￼}
示例10-26：即便参数和返回类型都是引用，示例4-9中定义的这个函数依然没有使用生命周期标注
这个函数之所以能够在没有生命周期标注的情况下通过编译是出于一些历史原因：在Rust的早期版本（pre-1.0）中，这样的代码确实无法通过编译，因为每个引用都必须有一个显式的生命周期。当时的函数签名会被写为：
fn first_word<'a>(s: &'a str) -> &'a str {
在编写了相当多的Rust代码后，Rust团队发现，在某些特定情况下Rust程序员总是在一遍又一遍地编写同样的生命周期标注。这样的场景是可预测的，而且有一些明确的模式。于是，Rust团队决定将这些模式直接写入编译器代码中，使借用检查器在这些情况下可以自动对生命周期进行推导而无须显式标注。
了解这段Rust历史是有必要的，因为随着Rust自身的开发，可能会有更多确定性的模式被添加到编译器中。在未来，需要手动标注的生命周期也许会越来越少。

◆ 这些被写入Rust引用分析部分的模式也就是所谓的生命周期省略规则。这些规则并不需要程序员去遵守；它们只是指明了编译器会考虑的某些场景，当你的代码符合这些场景时，就无须再显式地为代码注明相关生命周期了。
省略规则并不能提供完整的推断。假如Rust在确定性地应用了规则后仍然对引用的生命周期存在歧义的话，那么编译器不会去猜测剩余引用所拥有的生命周期是怎样的。在这种情况下，编译器会直接抛出错误而不是进行随意猜测。你可以通过添加生命周期标注，显式地注明引用之间的关系，来解决这些错误。

◆ 函数参数或方法参数中的生命周期被称为输入生命周期（input lifetime），而返回值的生命周期则被称为输出生命周期（output lifetime）。


◆ 在没有显式标注的情况下，编译器目前使用了3种规则来计算引用的生命周期。第一条规则作用于输入生命周期，第二条和第三条规则作用于输出生命周期。当编译器检查完这3条规则后仍有无法计算出生命周期的引用时，编译器就会停止运行并抛出错误。这些规则不但对fn定义生效，也对impl代码块生效。
第一条规则是，每一个引用参数都会拥有自己的生命周期参数。换句话说，单参数函数拥有一个生命周期参数：fn foo<'a>(x: &'a i32)；双参数函数拥有两个不同的生命周期参数：fn foo<'a, 'b>(x: &'a i32, y: &'b i32)；以此类推。
第二条规则是，当只存在一个输入生命周期参数时，这个生命周期会被赋予给所有输出生命周期参数，例如fn foo<'a>(x: &'a i32) -> &'a i32。
第三条规则是，当拥有多个输入生命周期参数，而其中一个是&self或&mut self时，self的生命周期会被赋予给所有的输出生命周期参数。这条规则使方法更加易于阅读和编写，因为它省略了一些不必要的符号。

◆ 现在，让我们假设自己就是编译器。我们会尝试应用这些规则来计算出示例10-26中的first_word函数签名中引用的生命周期。这段签名中的引用刚开始时还没有关联任何生命周期：
fn first_word(s: &str) -> &str {
接着，编译器开始应用第一条规则，为每个参数指定生命周期。我们按照惯例使用'a，所以签名如下所示：
fn first_word<'a>(s: &'a str) -> &str {
因为这里只有一个输入生命周期，所以第二条规则也是适用的。根据第二条规则，输入参数的生命周期将被赋予给输出生命周期参数，也就是：
fn first_word<'a>(s: &'a str) -> &'a str {
现在，函数签名中所有的引用都已经有了生命周期，因此编译器可以继续分析代码，而无须程序员标注这个函数签名中的生命周期。

◆ 让我们再看一个例子。这次，我们用示例10-21中没有生命周期参数的longest函数来分析：
fn longest(x: &str, y: &str) -> &str {
依然使用第一条规则，即每一个参数都有自己的生命周期。因为这次我们有两个参数，所以产生了两个生命周期：
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
这时你会发现，由于函数中的输入生命周期个数超过一个，所以第二条规则不再适用。此外，由于longest是一个函数而不是方法，其中并没有self参数，所以第三条规则也不再适用。在遍历完所有的3条规则后，我们依然无法计算出返回类型的生命周期。这也是当我们尝试去编译示例10-21中的代码时会出现错误的原因：编译器已经使用了全部生命周期省略规则，却依然无法计算出签名中所有引用的生命周期。
因为第三条规则实际上只适用于方法签名，所以我们会接着来学习这一上下文环境中的生命周期，并看一看为什么第三条规则可以让我们在大部分的方法签名中省略生命周期标注。


◆ 方法定义中的生命周期标注

◆ 生命周期省略规则在大部分情况下都可以帮我们免去方法签名中的生命周期标注。

◆ impl<'a> ImportantExcerpt<'a> {￼    fn level(&self) -> i32 {￼        3￼    }￼}
声明在impl及类型名称之后的生命周期是不能省略的，但根据第一条省略规则，我们可以不用为方法中的self引用标注生命周期。

◆ 下面是一个应用了第三条生命周期省略规则的例子：
impl<'a> ImportantExcerpt<'a> {￼    fn announce_and_return_part(&self, announcement: &str) -> &str {￼        println!("Attention please: {}", announcement);￼        self.part￼    }￼}
这里有两个输入生命周期，所以Rust通过应用第一条生命周期省略规则给了&self和announcement各自的生命周期。接着，由于其中一个参数是&self，返回类型被赋予了&self的生命周期，因此所有的生命周期就都被计算出来了。

◆ 静态生命周期

◆ Rust中还存在一种特殊的生命周期'static，它表示整个程序的执行期。所有的字符串字面量都拥有'static生命周期，我们可以像下面一样显式地把它们标注出来：
let s: &'static str = "I have a static lifetime.";
字符串的文本被直接存储在二进制程序中，并总是可用的。因此，所有字符串字面量的生命周期都是'static。
你可能会在错误提示信息中看到过关于使用'static生命周期的建议。不过，在将引用的生命周期指定为'static之前，记得要思考一下你所持有的引用是否真的可以在整个程序的生命周期内都有效。即便它可以，你也需要考虑一下它是否真的需要存活那么长时间。大部分情况下，错误的原因都在于尝试创建一个悬垂引用或可用生命周期不匹配。这时，应该去解决这些问题，而不是指定'static生命周期


第六十五章 同时使用泛型参数、trait约束与生命周期

◆ 同时使用泛型参数、trait约束与生命周期
让我们来简单地看一下在单个函数中同时指定泛型参数、trait约束及生命周期的语法：
use std::fmt::Display;￼￼fn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str￼    where T: Display￼{￼    println!("Announcement! {}", ann);￼    if x.len() > y.len() {￼        x￼    } else {￼        y￼    }￼}
这是示例10-22中用于返回两个字符串切片中较长者的longest函数。但是现在，它多了一个额外的ann参数，这个参数的类型为泛型T。根据where从句中的约束，该参数的类型可以被替换为任何实现了Display trait的类型。这个额外的参数会在函数比较字符串切片长度之前被打印出来，所以我们需要Display来作为trait约束。因为生命周期也是泛型的一种，所以生命周期参数'a和泛型参数T都被放置到了函数名后的尖括号列表中


第六十七章 第11章 编写自动化测试

◆ 第11章编写自动化测试

◆ Edsger W. Dijkstra[1]在1972年发表的文章《谦逊的程序员》（The Humble Programmer）中指出：“虽然测试可以高效地暴露程序中的bug，但在证明bug不存在方面却无能为力。”

◆ 尽管测试有着这样的局限，但是我们作为开发者，仍然应该竭尽全力地去进行测试！


第六十八章 如何编写测试

◆ 只需要将#[test]添加到关键字fn的上一行便可以将函数转变为测试函数

◆ 使用cargo test命令来运行测试

◆ cargo new adder --lib​​     Created library `adder` project￼$ cd adder
这个adder库会自动生成一个src/lib.rs文件

◆ src/lib.rs
#[cfg(test)]￼mod tests {￼ ❶ #[test]￼    fn it_works() {￼     ❷ assert_eq!(2 + 2, 4);￼    }￼}

◆ 即便是在tests模块中也可能会存在普通的非测试函数，它们通常被用来执行初始化操作或一些常用指令，所以我们必须要将测试函数标记为#[test]。

◆ 函数体中使用了assert_eq! 宏❷断言

◆ 性能测试（benchmark test）还只能用于Rust的nightly版本，请参阅Rust官方文档来了解更多关于性能测试的信息。

◆ 接下来以Doc-tests adder❹开头的部分是文档测试（documentation test）的结果。虽然我们还未编写过这种测试，但是要知道Rust能够编译在API文档中出现的任何代码示例。这一特性可以帮助我们保证文档总会和实际代码同步

◆ 在Rust中，一旦测试函数触发panic，该测试就被视作执行失败。每个测试在运行时都处于独立的线程中，主线程在监视测试线程时，一旦发现测试线程意外终止，就会将对应的测试标记为失败。

◆ use super::*;❶。tests模块与其他模块没有任何区别

◆ 从本质上来看，assert_eq! 和assert_ne! 宏分别使用了==和!=运算符来进行判断，并在断言失败时使用调试输出格式（{:?}）将参数值打印出来

◆ 。这意味着它们的参数必须同时实现PartialEq和Debug这两个trait。

◆ 所有的基本类型和绝大多数标准库定义的类型都是符合这一要求的。而对于自定义的结构体和枚举来说，你需要自行实现PartialEq来判断两个值是否相等，并实现Debug来保证值可以在断言失败时被打印出来

◆ 由于这两个trait都是可派生trait，所以它们一般可以通过在自定义的结构体或枚举的定义的上方添加#[derive(PartialEq, Debug)]标注来自动实现这两个trait。你可以参阅附录C来了解有关自动实现trait的更多细节。


◆ 你也可以添加自定义的错误提示信息，将其作为可选的参数传入assert!、assert_eq! 或assert_ne! 宏。实际上，任何在assert!、assert_eq! 或assert_ne! 的必要参数之后出现的参数都会一起被传递给format! 宏

◆ 可以将一个包含{}占位符的格式化字符串及相对应的填充值作为参数一起传递给这些宏

◆ pub fn greeting(name: &str) -> String {￼    format!("Hello {}!", name)￼}￼￼#[cfg(test)]￼mod tests {￼    use super::*;￼￼    #[test]￼    fn greeting_contains_name() {￼        let result = greeting("Carol");￼        assert!(result.contains("Carol"));￼    }￼}

◆ 为测试函数添加一个额外的新属性：should_panic。标记了这个属性的测试函数会在代码发生panic时顺利通过，而在代码不发生panic时执行失败。

◆ 使用Result<T, E>编写测试


◆ #[cfg(test)]￼mod tests {￼    #[test]￼    fn it_works() -> Result<(), String> {￼        if 2 + 2 == 4 {￼            Ok(())￼        } else {￼            Err(String::from("two plus two does not equal four"))￼        }￼    }￼}

◆ it_works函数现在会返回一个Result<(), String>类型的值。在函数体中，我们不再调用assert_eq! 宏，而是在测试通过时返回Ok(())，在失败时返回一个带有String的Err值。

◆ 像这样编写返回Result<T, E>的测试，就可以在测试函数体中使用问号运算符了。这样可以方便地编写一个测试，该测试在任意一个步骤返回Err值时都会执行失败。


第六十九章 控制测试的运行方式

◆ cargo test同样会在测试模式下编译代码，并运行生成的测试二进制文件

◆ 当你尝试运行多个测试时，Rust会默认使用多线程来并行执行它们。

◆ 开发者必须保证测试之间不会互相依赖，或者依赖到同一个共享的状态或环境上，例如当前工作目录、环境变量等

◆ cargo test -- --test-threads=1
在上面的命令中，我们将线程数量限制为1，这也就意味着程序不会使用任何并行操作。

◆ 假如你希望在测试通过时也将值打印出来，那么可以传入--nocapture标记来禁用输出截获功能：
$ cargo test -- --nocapture

◆ 值得注意的是，测试的输出和测试结果相互交叉在了一起；这是因为测试是并行运行的。你可以自行尝试使用--test-threads=1选项和--nocapture标记来运行测试，并观察输出的结果。


◆ 通过向cargo test中传递测试名称来指定需要运行的测试

◆ 我们可以指定测试名称的一部分来作为参数，任何匹配这一名称的测试都会得到执行。

◆ 使用ignore属性来标记这些耗时的测试，将这些测试排除在正常的测试运行之外


第七十章 测试的组织结构

◆ Rust社区主要从以下两个分类来讨论测试：单元测试（unit test）和集成测试（integration test）。单元测试小而专注，每次只单独测试一个模块或私有接口。而集成测试完全位于代码库之外，和正常从外部调用代码库一样使用外部代码，只能访问公共接口，并且在一次测试中可能会联用多个模块。

◆ 为了确保代码库无论是独立的还是作为一个整体都能如期运行，编写单元测试和集成测试是非常重要的工作。


◆ 我们一般将单元测试与需要测试的代码存放在src目录下的同一文件中。同时也约定俗成地在每个源代码文件中都新建一个tests模块来存放测试函数，并使用cfg(test)对该模块进行标注。
测试模块和#[cfg(test)]
在tests模块上标注#[cfg(test)]可以让Rust只在执行cargo test命令时编译和运行该部分测试代码，而在执行cargo build时剔除它们。

◆ 我们不需要对集成测试标注#[cfg(test)]，因为集成测试本身就放置在独立的目录中

◆ 但是，由于单元测试是和业务代码并列放置在同一文件中的，所以我们必须使用#[cfg(test)]进行标注才能将单元测试的代码排除在编译产出物之外。


◆ 通过使用cfg属性，Cargo只在运行cargo test时才会将测试代码纳入编译范围。这一约定不止针对那些标注了#[test]属性的测试函数，还针对该模块内的其余辅助函数。

◆ 软件测试社区对于是否应当直接测试私有函数一直存在争议。在某些语言中，测试私有函数往往是困难的，甚至是不可能的。不过无论你在软件测试上持有何种观点，Rust都通过私有性规则的设计，允许测试私有函数。

◆ pub fn add_two(a: i32) -> i32 {￼    internal_adder(a, 2)￼}￼￼fn internal_adder(a: i32, b: i32) -> i32 {￼    a + b￼}￼￼#[cfg(test)]￼mod tests {￼    use super::*;￼￼    #[test]￼    fn internal() {￼        assert_eq!(4, internal_adder(2, 2));￼    }￼}

◆ 集成测试
在Rust中，集成测试是完全位于代码库之外的。集成测试调用库的方式和其他的代码调用方式没有任何不同，这也意味着你只能调用对外公开提供的那部分接口。集成测试的目的在于验证库的不同部分能否协同起来正常工作。能够独立正常工作的单元代码在集成运行时也会发生各种问题，所以集成测试的覆盖率同样是非常重要的。为了创建集成测试，你首先需要建立一个tests目录。

◆ 我们需要在项目根目录下创建tests文件夹，它和src文件夹并列。Cargo会自动在这个目录下寻找集成测试文件

◆ 我们不需要为tests/integration_test.rs中的任何代码标注#[cfg(test)]。Cargo对tests目录进行了特殊处理，它只会在执行cargo test命令时编译这个目录下的文件。

◆ 在集成测试中使用子模块

◆ 为了避免common出现在测试结果中，我们可以创建tests/common/ mod.rs，而不再创建tests/common.rs。这是另一种可以被Rust理解的命名规范。通过采用这种文件命名方式，Rust就不会再将common模块视作一个集成测试文件了。

◆ tests/integration_test.rs
use adder;￼￼mod common;￼￼#[test]￼fn it_adds_two() {￼common::setup();￼assert_eq!(4, adder::add_two(2));￼}

◆ mod common;语句声明了需要引用的模块。接着，我们就可以在测试函数中正常调用common::setup()函数了。


◆ 二进制包的集成测试

◆ 如果我们的项目是一个只有src/main.rs文件而没有src/lib.rs文件的二进制包，那么我们就无法在tests目录中创建集成测试，也无法使用use语句将src/main.rs中定义的函数导入作用域。只有代码包（library crate）才可以将函数暴露给其他包来调用，而二进制包只被用于独立执行。

◆ 这就是Rust的二进制项目经常会把逻辑编写在src/lib.rs文件中，而只在src/main.rs文件中进行简单调用的原因。这种组织结构使得集成测试可以将我们的项目视作一个代码包，并能够使用use访问包中的核心功能。只要我们能够保证核心功能一切正常，src/main.rs中的少量胶水代码就能够工作，无须进行测试。


第七十二章 第12章 I/O项目：编写一个命令行程序

◆ 第12章I/O项目：编写一个命令行程序


第七十三章 接收命令行参数

◆ args函数与非法的Unicode字符
注意，std::env::args函数会因为命令行参数中包含了非法的Unicode字符而发生panic。如果你确实需要在程序中接收包含非法Unicode字符的参数，那么请使用std::env::args_os函数。这个函数会返回一个产出OsString值（而不是String值）的迭代器。我们在本章选择使用std::env::args是为了简单起见，因为OsString值会因平台而异，处理起来也会比String值更加复杂。



第七十四章 读取文件

◆ poem.txt
I'm nobody! Who are you?￼Are you nobody, too?￼Then there's a pair of us - don't tell!￼They'd banish us, you know.￼￼How dreary to be somebody!￼How public, like a frog￼To tell your name the livelong day￼To an admiring bog!


第七十五章 重构代码以增强模块化程度和错误处理能力

◆ 二进制项目的关注点分离

◆ Rust社区开发了一套为将会逐渐臃肿的二进制程序进行关注点分离的指导性原则：
• 将程序拆分为main.rs和lib.rs，并将实际的业务逻辑放入lib.rs。
• 当命令行解析逻辑相对简单时，将它留在main.rs中也无妨。
• 当命令行解析逻辑开始变得复杂时，同样需要将它从main.rs提取至lib.rs中。
经过这样的拆分之后，保留在main函数中的功能应当只有：
• 调用命令行解析的代码处理参数值。
• 准备所有其他的配置。
• 调用lib.rs中的run函数。
• 处理run函数可能出现的错误。
这种模式正是关注点分离思想的体现：main.rs负责运行程序，而lib.rs则负责处理所有真正的业务逻辑。虽然你无法直接测试main函数，但因为我们将大部分代码都移动到了lib.rs中，所以我们依然可以测试几乎所有的程序逻辑。依然保留在main.rs中的代码量应该小到可以直接通过阅读来进行正确性检查。下面让我们按照以上原则来重构程序。


◆ 注意
在使用复杂类型更合适时偏偏坚持使用基本类型，是一种叫作基本类型偏执（primitive obsession）的反模式（anti-pattern）。

◆ 有许多不同的方法可以用来处理String类型的输入值，但其中最简单的莫过于调用clone方法进行复制，尽管它可能会有些低效❼❽。这个方法会将输入值完整复制一份，从而方便Config实例取得新值的所有权。这样做确实比存储字符串的引用消耗了更多的时间和内存，但同时也省去了管理引用的生命周期的麻烦，从而让代码更加简单直接。在这个场景中，用少许的性能交换更多的简捷性是非常值得的取舍。


◆ 使用clone的取舍
许多Rust爱好者由于担心增加运行时代价，从而会避免使用clone来解决所有权问题。我们确实会在第13章学习如何更有效率地处理这种情形。但是对于本例来说，用复制字符串的方式来改进程序是没有任何问题的，因为我们只会执行一次相关的复制操作，并且文件名和搜索字符串都只会占用相当小的空间。在首次编写程序时，先完成一个运行正常但效率有待改进的程序比尝试过度优化代码更好一些。另外，随着你越来越熟悉Rust，你也会越来越容易地一次性写出高效率的代码，但是，目前使用clone是完全可以接受的。


◆ 调用process::exit函数会立刻中止程序运行，并将我们指定的错误码返回给调用者。


第八十章 第13章 函数式语言特性：迭代器与闭包

◆ 第13章函数式语言特性：迭代器与闭包

◆ 常见的函数式风格编程通常包括将函数当作参数、将函数作为其他函数的返回值或将函数赋给变量以备之后执行等。

◆ • 闭包（closure），一个类似于函数且可以存储在变量中的结构。
• 迭代器（iterator），一种处理一系列元素的方法。
• 使用闭包和迭代器来改善第12章中的I/O项目。
• 讨论闭包和迭代器的运行时性能。（悄悄透露一下：它们比你想象的还要快！）



第八十一章 闭包：能够捕获环境的匿名函数

◆ Rust中的闭包是一种可以存入变量或作为参数传递给其他函数的匿名函数。

◆ let expensive_closure = |num| {￼    println!("calculating slowly...");￼    thread::sleep(Duration::from_secs(2));￼    num￼};
示例13-5：定义一个闭包并将它存入expensive_closure变量中
闭包的定义放置在=之后，它会被赋值给语句左侧的expensive_closure变量。为了定义闭包，我们需要以一对竖线（|）开始，并在竖线之间填写闭包的参数；之所以选择这样的写法是因为它与Smalltalk及Ruby中的闭包定义类似。这个闭包仅有一个名为num的参数，而当闭包需要多个参数时，我们需要使用逗号来分隔它们，例如|param1, param2|。
在参数后面，我们使用了一对花括号来包裹闭包的函数体。如果这个闭包只是单行表达式，你也可以选择省略花括号。在闭包结束后，也就是右花括号的后边，我们需要用一个分号来结束当前的let语句。因为闭包代码中的最后一行（num）没有以分号结尾，所以该行产生的值会被当作闭包的结果返回给调用者，其行为与普通函数的完全一致。


◆ fn generate_workout(intensity: u32, random_number: u32) {￼    let expensive_closure = |num| {￼        println!("calculating slowly...");￼        thread::sleep(Duration::from_secs(2));￼        num￼    };￼￼    if intensity < 25 {￼        println!(￼            "Today, do {} pushups!",￼            expensive_closure(intensity)￼        );￼        println!(￼            "Next, do {} situps!",￼            expensive_closure(intensity)￼        );￼    } else {￼        if random_number == 3 {￼            println!("Take a break today! Remember to stay hydrated!");￼        } else {￼            println!(￼                "Today, run for {} minutes!",￼                expensive_closure(intensity)￼            );￼        }￼    }￼}

◆ 这样的改动让示例13-3中的老问题重新出现了：我们依然在第一个if块中调用了两次闭包，也就是执行了两次耗时的计算操作，进而导致用户的等待时间不合理地被延长了两倍。当然，在if块中定义一个局部变量来存储闭包结果可以解决这个问题，但你也可以利用闭包的特性提供另一种解决方案。我们稍后再来讨论它。现在，先来看一看为什么闭包定义及其相关trait中都没有出现任何的类型标注。

◆ 和fn定义的函数不同，闭包并不强制要求你标注参数和返回值的类型。Rust之所以要求我们在函数定义中进行类型标注，是因为类型信息是暴露给用户的显式接口的一部分。严格定义接口有助于所有人对参数和返回值的类型取得明确共识。但是，闭包并不会被用于这样的暴露接口：它们被存储在变量中，在使用时既不需要命名，也不会被暴露给代码库的用户。
闭包通常都相当短小，且只在狭窄的代码上下文中使用，而不会被应用在广泛的场景下。在这种限定环境下，编译器能够可靠地推断出闭包参数的类型及返回值的类型，就像是编译器能够推断出大多数变量的类型一样。


◆ 标准库中提供了一系列Fn trait，而所有的闭包都至少实现了Fn、FnMut及FnOnce中的一个trait。

◆ struct Cacher<T>￼    where T: Fn(u32) -> u32￼{￼    calculation: T,￼    value: Option<u32>,￼}
示例13-9：存储了一个闭包calculation和一个可选结果值value的结构体Cacher

◆ Cacher结构体拥有一个泛型T的calculation字段，而trait约束规定的这个T代表一个使用Fn trait的闭包。另外，我们存储在calculation中的闭包必须有一个u32参数（在Fn后面的括号中指定），同时必须返回一个u32值（在->后面指定）。
注意
函数同样也可以实现这3个Fn trait。假如代码不需要从环境中捕获任何值，那么我们也可以使用实现了Fn trait的函数而不是闭包。
另外一个字段value的类型是Option<u32>。在运行闭包之前，value会被初始化为None。而当使用Cacher的代码请求闭包的执行结果时，Cacher会运行闭包并将结果存储在value的Some变体中。之后，如果代码重复请求闭包的结果，Cacher就可以避免再次运行闭包，而将缓存在Some变体中的结果返回给调用者。

◆ src/main.rs
impl<T> Cacher<T>￼ ❶ where T: Fn(u32) -> u32￼{￼ ❷ fn new(calculation: T) -> Cacher<T> {￼     ❸ Cacher {￼            calculation,￼            value: None,￼        }￼    }￼￼ ❹ fn value(&mut self, arg: u32) -> u32 {￼        match self.value {￼         ❺ Some(v) => v,￼         ❻ None => {￼                let v = (self.calculation)(arg);￼                self.value = Some(v);￼                v￼            },￼        }￼    }￼}

◆  generate_workout(intensity: u32, random_number: u32) {￼ ❶ let mut expensive_result = Cacher::new(|num| {￼        println!("calculating slowly...");￼        thread::sleep(Duration::from_secs(2));￼        num￼    });￼￼    if intensity < 25 {￼        println!(￼            "Today, do {} pushups!",￼         ❷ expensive_result.value(intensity)￼        );￼        println!(￼            "Next, do {} situps!",￼         ❸ expensive_result.value(intensity)￼        );￼    } else {￼        if random_number == 3 {￼            println!("Take a break today! Remember to stay hydrated!");￼        } else {￼            println!(￼                "Today, run for {} minutes!",￼             ❹ expensive_result.value(intensity)￼            );￼        }￼    }￼}

◆ 当前的Cacher实现存在两个问题，导致我们很难在不同的上下文环境中复用它。
第一个问题是，Cacher实例假设value方法会为不同的arg参数返回相同的值。

◆ 解决这个问题的方法是让Cacher存储一个哈希表而不是单一的值。这个哈希表使用传入的arg值作为关键字，并将关键字调用闭包后的结果作为对应的值。相应地，value方法不再简单地判断self.value的值是Some还是None，而是会检查哈希映射里是否存在arg这个关键字。如果存在的话，Cacher就直接返回对应的值；如果不存在的话，则调用闭包，使用arg关键字将结果存入哈希表之后再返回。

◆ 这个Cacher实现的第二个问题是它只能接收一个获取u32类型参数并返回u32类型的值的闭包。但我们可能想要缓存的是一个获取字符串切片参数并返回usize值的闭包。为了修复这一问题，你可以自行尝试引入更多的泛型参数来提升Cacher功能的灵活性。


◆ 使用闭包捕获上下文环境

◆ 闭包还有一项函数所不具备的功能：它们可以捕获自己所在的环境并访问自己被定义时的作用域中的变量

◆ fn main() {￼    let x = 4;￼￼    let equal_to_x = |z| z == x;￼￼    let y = 4;￼￼    assert!(equal_to_x(y));￼}

◆ 闭包可以通过3种方式从它们的环境中捕获值，这和函数接收参数的3种方式是完全一致的：获取所有权、可变借用及不可变借用。

◆ 这3种方式被分别编码在如下所示的3种Fn系列的 trait中：
• FnOnce意味着闭包可以从它的封闭作用域中，也就是闭包所处的环境中，消耗捕获的变量。为了实现这一功能，闭包必须在定义时取得这些变量的所有权并将它们移动至闭包中。这也是名称FnOnce中Once一词的含义：因为闭包不能多次获取并消耗掉同一变量的所有权，所以它只能被调用一次。
• FnMut可以从环境中可变地借用值并对它们进行修改。
• Fn可以从环境中不可变地借用值。
当你创建闭包时，Rust会基于闭包从环境中使用值的方式来自动推导出它需要使用的trait。所有闭包都自动实现了FnOnce，因为它们至少都可以被调用一次。那些不需要移动被捕获变量的闭包还会实现FnMut，而那些不需要对被捕获变量进行可变访问的闭包则同时实现了Fn。在示例13-12中，因为equal_to_x闭包只需要读取x中的值，所以它仅仅不可变地借用了x并实现了Fn trait。
假如你希望强制闭包获取环境中值的所有权，那么你可以在参数列表前添加move关键字。这个特性在把闭包传入新线程时相当有用，它可以将捕获的变量一并移动到新线程中去。


◆ 在大部分情形下，当你需要指定某一个Fn系列的 trait时，可以先尝试使用Fn trait，编译器会根据闭包体中的具体情况来告诉你是否需要FnMut或FnOnce。


第八十二章 使用迭代器处理元素序列

◆ Iterator trait和next方法
所有的迭代器都实现了定义于标准库中的Iterator trait。该trait的定义类似于下面这样：
pub trait Iterator {￼    type Item;￼￼    fn next(&mut self) -> Option<Self::Item>;￼￼    // 这里省略了由Rust给出的默认实现方法​​}


◆ 注意，这个定义使用了两种新语法：type Item和Self::Item，它们定义了trait的关联类型（associated type）。我们会在第19章深入讨论关联类型

◆ Iterator trait只要求实现者手动定义一个方法：next方法，它会在每次被调用时返回一个包裹在Some中的迭代器元素，并在迭代结束时返回None。

◆ iter方法生成的是一个不可变引用的迭代器，我们通过next取得的值实际上是指向动态数组中各个元素的不可变引用。如果你需要创建一个取得v1所有权并返回元素本身的迭代器，那么你可以使用into_iter方法。类似地，如果你需要可变引用的迭代器，那么你可以使用iter_mut方法。

◆ 这些调用next的方法也被称为消耗适配器（consuming adaptor），因为它们同样消耗了迭代器本身。以sum方法为例，这个方法会获取迭代器的所有权并反复调用next来遍历元素，进而导致迭代器被消耗。在迭代过程中，它会对所有元素进行求和并在迭代结束后将总和作为结果返回。示例13-16中的测试展示了sum方法的使用场景。
src/lib.rs
#[test]￼fn iterator_sum() {￼    let v1 = vec![1, 2, 3];￼￼    let v1_iter = v1.iter();￼￼    let total: i32 = v1_iter.sum();￼￼    assert_eq!(total, 6);￼}
示例13-16：调用sum方法来得到迭代器中所有元素的总和
由于我们在调用sum的过程中获取了迭代器v1_iter的所有权，所以该迭代器无法继续被随后的代码使用。


◆ Iterator trait还定义了另外一些被称为迭代器适配器（iterator adaptor）的方法，这些方法可以使你将已有的迭代器转换成其他不同类型的迭代器。你可以链式地调用多个迭代器适配器完成一些复杂的操作，同时保持代码易于阅读。但因为所有的迭代器都是惰性的，所以你必须调用一个消耗适配器的方法才能从迭代器适配器中获得结果。


◆ let v1: Vec<i32> = vec![1, 2, 3];￼￼let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();￼￼assert_eq!(v2, vec![2, 3, 4]);
示例13-18：调用map方法创建新迭代器，接着再调用collect方法将其消耗掉并得到一个动态数组

◆ 迭代器的filter方法会接收一个闭包作为参数，这个闭包会在遍历迭代器中的元素时返回一个布尔值，而每次遍历的元素只有在闭包返回true时才会被包含在filter生成的新迭代器中。

◆ fn shoes_in_my_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {￼ ❷ shoes.into_iter()￼     ❸ .filter(|s| s.size == shoe_size)￼     ❹ .collect()￼}￼

◆ 可以通过实现Iterator trait来创建拥有自定义行为的迭代器。正如之前所提到的，你只需要提供一个next方法的定义即可实现Iterator trait。一旦完成该方法定义，你就可以使用其他一切拥有默认实现的Iterator trait提供的方法。


◆ src/lib.rs
#[test]￼fn calling_next_directly() {￼    let mut counter = Counter::new();￼￼    assert_eq!(counter.next(), Some(1));￼    assert_eq!(counter.next(), Some(2));￼    assert_eq!(counter.next(), Some(3));￼    assert_eq!(counter.next(), Some(4));￼    assert_eq!(counter.next(), Some(5));￼    assert_eq!(counter.next(), None);￼}
示例13-22：测试next方法实现的功能
这个测试首先在counter变量中创建了一个新的Counter实例，接着反复调用next来验证实现的迭代器行为是否符合我们的期望，也就是返回从1到5的值。
使用其他的Iterator trait方法
我们只需要提供next方法的定义便可以使用标准库中那些拥有默认实现的Iterator trait方法，因为这些方法都依赖于next方法的功能。
例如，假设我们希望将一个Counter实例产生的值与另一个Counter实例跳过首元素后的值一一配对，接着将配对的两个值相乘，最后再对乘积中能被3整除的那些数字求和。示例13-23中的测试演示了这一过程。
src/lib.rs
#[test]￼fn using_other_iterator_trait_methods() {￼    let sum: u32 = Counter::new().zip(Counter::new().skip(1))￼                                 .map(|(a, b)| a * b)￼                                 .filter(|x| x % 3 == 0)￼                                 .sum();￼    assert_eq!(18, sum);￼}
示例13-23：在Counter迭代器上使用不同的Iterator trait方法
注意，zip方法只会产生4对值，它在两个迭代器中的任意一个返回None时结束迭代，所以理论上的第五对值(5, None)永远不会被生成出来。
因为我们指定了next方法的具体行为，而标准库又对其他调用next的方法提供了默认实现，所以我们能够合法地使用所有这些方法。


第八十三章 改进I/O项目

◆ impl Config {￼    pub fn new(mut args: std::env::Args) -> Result<Config, &'static str> {￼        args.next();￼￼        let query = match args.next() {￼            Some(arg) => arg,￼            None => return Err("Didn't get a query string"),￼        };￼￼        let filename = match args.next() {￼            Some(arg) => arg,￼            None => return Err("Didn't get a file name"),￼        };￼￼        let case_sensitive = env::var("CASE_INSENSITIVE").is_err();￼￼        Ok(Config { query, filename, case_sensitive })￼    }￼}

◆ pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {￼    contents.lines()￼        .filter(|line| line.contains(query))￼        .collect()￼}

◆ 迭代器可以让开发者专注于高层的业务逻辑，而不必陷入编写循环、维护中间变量这些具体的细节中。通过高层抽象去消除一些惯例化的模板代码，也可以让代码的重点逻辑（例如filter方法的过滤条件）更加突出。


第八十四章 比较循环和迭代器的性能

◆ 迭代器是Rust语言中的一种零开销抽象（zero-cost abstraction），这个词意味着我们在使用这些抽象时不会引入额外的运行时开销。

◆ 它已经能够被编译成与手写汇编几乎一样的产出物。遍历coefficients根本不会用到循环：因为Rust知道这里会迭代12次，所以它直接“展开”（unroll）了循环。展开是一种优化策略，它通过将循环代码展开成若干份重复的代码来消除循环控制语句带来的性能开销。
这样能让所有coefficients中的值都存储在寄存器中，进而使得对它们的访问变得异常快速。同时，我们也就无须在运行时浪费时间对数组访问进行边界检查了。Rust引入的所有这些优化使最终产出的代码极为高效。现在你知道了，我们完全可以无所畏惧地使用迭代器和闭包！它们既能够让代码在观感上保持高层次的抽象，又不会因此带来任何运行时性能损失。


第八十六章 第14章 进一步认识Cargo及crates.io

◆ 第14章进一步认识Cargo及crates.io


第八十七章 使用发布配置来定制构建

◆ 当项目的Cargo.toml文件中没有任何[profile.*]区域时，Cargo针对每个配置都会有一套可以应用的默认选项。通过为任意的配置添加[profile.*]区域，我们可以覆盖默认设置的任意子集。例如，下面是opt-level选项分别在dev与release配置中的默认值：
Cargo.toml
[profile.dev]￼opt-level = 0￼￼[profile.release]￼opt-level = 3

◆ 选项opt-level决定了Rust在编译时会对代码执行何种程度的优化，从0到3都是合法的配置值。越高级的优化需要消耗越多的编译时间

◆ dev配置下的默认opt-level值为0

◆ release配置下的默认opt-level值为3


第八十八章 将包发布到crates.io上

◆ 由于crates.io的包注册表会以源代码的形式来分发你的包，所以由它托管的包大部分都是开源的

◆ 我们可以使用三斜线（///）而不是双斜线来编写文档注释，并且可以在文档注释中使用Markdown语法来格式化内容。文档注释被放置在它所说明的条目之前。

◆ 通过运行cargo doc命令来基于这段文档注释生成HTML文档。这条命令会调用Rust内置的rustdoc工具在target/doc路径下生成HTML文档

◆ 可以调用cargo doc --open来生成并自动在浏览器中打开当前的包的文档（以及所有依赖包的文档）。

◆ Examples在HTML文档中创建了标题为“Examples”的区域。除此之外，包的作者还经常会在文档中使用下面一些区域：
• Panics，指出函数可能引发panic的场景。不想触发panic的调用者应当确保自己的代码不会在这些场景下调用该函数。
• Errors，当函数返回Result作为结果时，这个区域会指出可能出现的错误，以及造成这些错误的具体原因，它可以帮助调用者在编写代码时为不同的错误采取不同的措施。
• Safety，当函数使用了unsafe关键字（在第19章讨论）时，这个区域会指出当前函数不安全的原因，以及调用者应当确保的使用前提。
大部分的文档注释都不需要拥有全部这些区域，但你可以将它作为一个检查列表来提醒自己需要在文档中编写哪几部分。

◆ 在文档注释中增加示例可以帮助用户理解代码库的使用方式。除此之外，cargo test会在执行时将文档注释中的代码示例作为测试去运行。

◆ 还有一种文档注释形式 ：//!，它可以为包裹当前注释的外层条目（而不是紧随注释之后的条目）添加文档。这种文档注释通常被用在包的根文件（也就是惯例上的 src/libs.rs）或模块的根文件上，分别为整个包或整个模块提供文档。

◆ 使用pub use来重新导出部分条目

◆ ，从而建立一套和你的内部结构不同的对外结构。

◆ 为了从公共API中移除内部结构，我们可以修改示例14-3中的art包代码，使用pub use语句将需要公开的条目重新导出到顶层结构中，如示例14-5所示。
src/lib.rs
//! # Art￼//!￼//! A library for modeling artistic concepts.￼￼pub use self::kinds::PrimaryColor;￼pub use self::kinds::SecondaryColor;￼pub use self::utils::mix;￼￼pub mod kinds {￼    // --略--￼}￼￼pub mod utils {￼    // --略--￼}
示例14-5：使用pub use语句重新导出一些条目

◆ 再次使用cargo doc为art包生成API文档，新的文档首页会列出重新导出的条目及指向它们的链接，如图14-4所示。这就使得PrimaryColor类型、SecondaryColor类型及mix函数更加易于查找了。

◆ src/main.rs
use art::PrimaryColor;￼use art::mix;￼￼fn main() {￼    // --略--￼}
示例14-6：这段程序使用了art包中重新导出的条目

◆ 当存在较多嵌套模块时，使用pub use将类型重新导出到顶层模块可以显著地改善用户体验。

◆ 在发布包之前，我们需要在crates.io上注册一个账户并获取一个API令牌（API token）。你可以访问crates.io主页并使用GitHub账户登录来完成注册

◆ 使用API令牌执行cargo login命令：
$ cargo login abcdefghijklmnopqrstuvwxyz012345
这个命令会让Cargo将你的API令牌存入～/.cargo/credentials文件中

◆ 首先，包需要有一个独一无二的名称。当在本地对包进行开发时，你可以使用任何你喜欢的名称。但是，托管到crates.io平台上的包就必须按照先来先得的规则取名了。一旦某个包的名称被占用，其他包就不能再使用这个名称了

◆ 许多Rust社区中的开发者会选择在他们的项目中使用与Rust完全一致的许可协议，也就是双许可的MIT OR Apache-2.0。

◆ 尽管你不能移除某一个老版本的包，但我们仍然可以阻止未来的新项目将它们引用为依赖。这在包的版本因为异常问题而损坏时十分有用。对于此类场景，Cargo支持撤回（yank）某个特定版本。

◆ 所有已经产生Cargo.lock的项目将不会受到撤回操作的影响，而未来所有产生的新Cargo.lock文件将不会再使用已经撤回的版本

◆ 通过在命令中添加--undo参数，你也可以取消撤回操作，从而允许项目再次开始依赖这个版本：
$ cargo yank --vers 1.0.1 --undo


第八十九章 Cargo工作空间

◆ Cargo提供了一个叫作工作空间（workspace）的功能，它可以帮助开发者管理多个相互关联且需要协同开发的包。

◆ 工作空间是由共用同一个Cargo.lock和输出目录的一系列包所组成的

◆ 我们已经可以使用cargo build来构建整个工作空间了。此时，add目录下的文件应该有如下所示的文件结构：
├── Cargo.lock￼├── Cargo.toml￼├── adder￼│   ├── Cargo.toml￼│   └── src￼│       └── main.rs￼└── target
工作空间在根目录下有一个target目录用来存放所有成员的编译产出物，相对应地，adder包也就没有了自己独立的target目录。即使我们进入adder目录中运行cargo build，编译产出物依然会输出到add/target而不是add/adder/target中。Cargo之所以会将不同的target目录集中到一处是因为工作空间中的包往往是互相依赖的。如果每个包都有自己的target目录，那么它们就不得不在执行各自的构建过程中反复编译工作空间下的其余包。而通过共享一个target目录，不同的包就可以避免这些不必要的重复编译过程。


◆ add目录下应该有如下所示的目录和文件：
├── Cargo.lock￼├── Cargo.toml￼├── add-one￼│   ├── Cargo.toml￼│   └── src￼│       └── lib.rs￼├── adder￼│   ├── Cargo.toml￼│   └── src￼│       └── main.rs￼└── target

◆ 创建好新的代码包后，我们可以让二进制包adder依赖于代码包add-one。首先，我们需要在adder/Cargo.toml中添加add-one的路径作为依赖：
adder/Cargo.toml
[dependencies]￼￼add-one = { path = "../add-one" }
由于Cargo不会主动去假设工作空间中的包会彼此依赖，所以我们必须要显式地指明包与包之间的依赖关系。


◆ 为了在add根目录下运行二进制包，我们需要在调用cargo run时通过-p参数来指定需要运行的包名：
$ cargo run -p adder​​    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs￼     Running `target/debug/adder`￼Hello, world! 10 plus one is 11!

◆ 需要注意的是，整个工作空间只在根目录下有一个Cargo.lock文件，而不是在每个包的目录下都有一个Cargo.lock文件。这一规则确保了所有的内部包都会使用完全相同的依赖版本

◆ 我们同样可以在工作空间根目录下，使用参数-p及指定的包名称来运行某一个特定包的测试：
$ cargo test -p add-one​​

◆ 当你想要将工作空间中的各个包发布到crates.io上时，你必须要将它们分别发布。cargo publish命令并没有提供类似于--all或-p之类的标记，你必须手动切换到每个包的目录，并对每个包分别执行cargo publish来完成发布任务。


◆ 你可以在项目规模逐渐增长时考虑使用工作空间：独立短小的组件要比繁复冗长的代码更容易理解一些。另外，当多个包经常需要同时修改时，将它们放于同一工作空间下也有助于协调同步。


第九十章 使用cargo install从crates.io上安装可执行程序

◆ 使用cargo install从crates.io上安装可执行程序

◆ 所有通过cargo install命令安装的二进制文件都会被存储在Rust安装根目录下的bin文件夹中


第九十一章 使用自定义命令扩展Cargo的功能

◆ 使用自定义命令扩展Cargo的功能
Cargo允许我们添加子命令来扩展它的功能而无须修改Cargo本身。只要你的$PATH路径中存在二进制文件cargo-something，就可以通过运行cargo something来运行该二进制文件，就好像它是Cargo的子命令一样。运行cargo --list可以列出所有与此类似的自定义命令。借助于这一设计，我们可以使用cargo install来安装扩展，并把这些扩展视作内建的Cargo命令来运行


第九十三章 第15章 智能指针

◆ 第15章智能指针


◆ Rust中最常用的指针就是你在第4章学习过的引用。引用是用&符号表示的，会借用它所指向的值

◆ 而智能指针（smart pointer）则是一些数据结构，它们的行为类似于指针但拥有额外的元数据和附加功能

◆ 引用计数（reference counting）智能指针类型。这种指针会通过记录所有者的数量来使一份数据被多个所有者同时持有，并在没有任何所有者时自动清理数据。

◆ 实际上，我们已经在本书中接触过好几种不同的智能指针了，例如第8章中的String与Vec<T>。尽管我们没有刻意地提及智能指针这个称呼，但这两种类型都可以被算作智能指针，因为它们都拥有一片内存区域并允许用户对其进行操作。它们还拥有元数据（例如容量等），并提供额外的功能或保障（例如String会保障其中的数据必定是合法的UTF-8编码）。
我们通常会使用结构体来实现智能指针，但区别于一般结构体的地方在于它们会实现Deref与Drop这两个trait。Deref trait使得智能指针结构体的实例拥有与引用一致的行为，它使你可以编写出能够同时用于引用和智能指针的代码。Drop trait则使你可以自定义智能指针离开作用域时运行的代码。在本章中，我们会依次讨论这两个trait，并通过演示来说明它们对于智能指针的重要性。
由于智能指针作为一种设计模式被相当频繁地应用到了Rust中，所以我们无法在本书中涉及所有现存的智能指针类型。事实上，许多代码库都会提供它们自己的智能指针，你也可以选择自己编写满足特定用途的智能指针类型。接下来，我们会将讨论的重点集中到标准库中最为常见的那些智能指针上：
• Box<T>，可用于在堆上分配值。
• Rc<T>，允许多重所有权的引用计数类型。
• Ref<T>和RefMut<T>，可以通过RefCell<T>访问，是一种可以在运行时而不是编译时执行借用规则的类型。
另外，我们会在本章介绍内部可变性（interior mutability）模式，使用了这一模式的不可变类型会暴露出能够改变自己内部值的API。我们还会讨论循环引用导致内存泄漏的原因，并研究如何来规避类似的问题。


第九十四章 使用Box<T>在堆上分配数据

◆ 装箱（box）是最为简单直接的一种智能指针，它的类型被写作Box<T>。装箱使我们可以将数据存储在堆上，并在栈中保留一个指向堆数据的指针

◆ 装箱常常被用于下面的场景中：
• 当你拥有一个无法在编译时确定大小的类型，但又想要在一个要求固定尺寸的上下文环境中使用这个类型的值时。
• 当你需要传递大量数据的所有权，但又不希望产生大量数据的复制行为时。
• 当你希望拥有一个实现了指定trait的类型值，但又不关心具体的类型时。


◆ 我们会在“使用装箱定义递归类型”一节中演示第一种场景的应用示例。在第二种场景中，转移大量数据的所有权可能会花费较多的时间，因为这些数据需要在栈上进行逐一复制。为了提高性能，你可以借助装箱将这些数据存储到堆上。通过这种方式，我们只需要在转移所有权时复制指针本身即可，而不必复制它指向的全部堆数据。第三种场景也被称作trait对象（trait object），我们会在第17章的“使用trait对象来存储不同类型的值”一节来详细讨论它。

◆ fn main() {￼    let b = Box::new(5);￼    println!("b = {}", b);￼}

◆ 代码中用来访问装箱数据的语法与访问栈数据的语法非常类似。另外，和其他任何拥有所有权的值一样，装箱会在离开自己的作用域时（也就是b到达main函数的结尾时）被释放。装箱被释放的东西除了有存储在栈上的指针，还有它指向的那些堆数据。

◆ 我们再来看一下另一个案例，在该场景下我们只有使用装箱才能定义出期望的类型。

◆ 使用装箱定义递归类型
Rust必须在编译时知道每一种类型占据的空间大小，但有一种被称作递归（recursive）的类型却无法在编译时被确定具体大小。递归类型的值可以在自身中存储另一个相同类型的值，因为这种嵌套在理论上可以无穷无尽地进行下去，所以Rust根本无法计算出一个递归类型需要的具体空间大小。但是，装箱有一个固定的大小，我们只需要在递归类型的定义中使用装箱便可以创建递归类型了。

◆ use crate::List::{Cons, Nil};￼￼fn main() {￼    let list = Cons(1, Cons(2, Cons(3, Nil)));￼}

◆ 上面的错误提示信息指出这个类型“拥有无限大小”，这是因为我们在定义List时引入了一个递归的变体，它直接持有了另一个相同类型的值。这意味着Rust无法计算出存储一个List值需要消耗多大的空间。

◆ 建议中的indirection（间接）意味着，我们应该改变数据结构来存储指向这个值的指针，而不是直接地存储这个值。
因为Box<T>是一个指针，所以Rust总是可以确定一个Box<T>的具体大小。指针的大小总是恒定的，它不会因为指向数据的大小而产生变化。这也意味着我们可以在Cons变体中存放一个Box<T>而不是直接存放另外一个List值。而Box<T>则会指向下一个List并存储在堆上，而不是直接存放在Cons变体中。理论上讲，我们仍然拥有一个“持有”其他列表的列表，但现在的实现更像是一项挨着一项，而不是一项包含另一项。

◆ enum List {￼    Cons(i32, Box<List>),￼    Nil,￼}￼￼use crate::List::{Cons, Nil};￼￼fn main() {￼    let list = Cons(1,￼        Box::new(Cons(2,￼            Box::new(Cons(3,￼                Box::new(Nil))))));￼}

◆ 新的Cons变体需要一部分存储i32的空间和一部分存储装箱指针数据的空间。

◆ 装箱正好能够被用在类似于链接列表这类仅仅需要间接访问的场景中

◆ Box<T>属于智能指针的一种，因为它实现了Deref trait，并允许我们将Box<T>的值当作引用来对待。当一个Box<T>值离开作用域时，因为它实现了Drop trait，所以Box<T>指向的堆数据会自动地被清理释放掉


第九十五章 通过Deref trait将智能指针视作常规引用

◆ 实现Deref trait使我们可以自定义解引用运算符（dereference operator）*的行为（这一符号也同时被用作乘法运算符和通配符）。通过实现Deref，我们可以将智能指针视作常规引用来进行处理。这也就意味着，原本用于处理引用的代码可以不加修改地用于处理智能指针。


◆ 把Box<T>当成引用来操作
我们可以使用Box<T>来代替示例15-6中的引用，此时的解引用运算符能够正常工作，如示例15-7所示。
src/main.rs
fn main() {￼    let x = 5;￼ ❶ let y = Box::new(x);￼￼    assert_eq!(5, x);￼ ❷ assert_eq!(5, *y);￼}

◆ *y会被Rust隐式地展开为：
*(y.deref())

◆ Rust使用*运算符来替代deref方法和另外一个朴素的解引用操作

◆ 所有权系统决定了deref方法需要返回一个引用，而*(y.deref())的最外层依然需要一个朴素的解引用操作。假设deref方法直接返回了值而不是指向值的引用，那么这个值就会被移出self。在大多数使用解引用运算符的场景下，我们并不希望获得MyBox<T>内部值的所有权。

◆ 解引用转换（deref coercion）是Rust为函数和方法的参数提供的一种便捷特性。当某个类型T实现了Deref trait时，它能够将T的引用转换为T经过Deref操作后生成的引用。当我们将某个特定类型的值引用作为参数传递给函数或方法，但传入的类型与参数类型不一致时，解引用转换就会自动发生。编译器会插入一系列的deref方法调用来将我们提供的类型转换为参数所需的类型。

◆ Rust通过实现解引用转换功能，使程序员在调用函数或方法时无须多次显式地使用&和*运算符来进行引用和解引用操作。

◆ 标准库为String提供的Deref实现会返回字符串切片（你可以在Deref的API文档中看到这一信息），所以Rust可以继续调用deref来将&String转换为&str

◆ fn main() {￼    let m = MyBox::new(String::from("Rust"));￼    hello(&(*m)[..]);￼}
示例15-13：如果Rust没有解引用转换功能，就必须编写这样的代码
代码中的(*m)首先将MyBox<String>进行解引用得到String，然后，通过&和[..]来获取包含整个String的字符串切片以便匹配hello函数的签名

◆ 只要代码涉及的类型实现了Deref trait，Rust就会自动分析类型并不断尝试插入Deref::deref来获得与参数类型匹配的引用。因为这一分析过程会在编译时完成，所以解引用转换不会在运行时产生任何额外的性能开销！

◆ 解引用转换与可变性
使用Deref trait能够重载不可变引用的*运算符。与之类似，使用DerefMut trait能够重载可变引用的*运算符。
Rust会在类型与trait满足下面3种情形时执行解引用转换：
• 当T: Deref<Target=U>时，允许&T转换为&U。
• 当T: DerefMut<Target=U>时，允许&mut T转换为&mut U。
• 当T: Deref<Target=U>时，允许&mut T转换为&U。
前两种情形除可变性之外是完全相同的。其中，情形一意味着，如果T实现了类型U的Deref trait，那么&T就可以被直接转换为&U。情形二意味着，同样的解引用转换过程会作用于可变引用。
情形三则有些微妙：Rust会将一个可变引用自动地转换为一个不可变引用。但这个过程绝对不会逆转，也就是说不可变引用永远不可能转换为可变引用。因为按照借用规则，如果存在一个可变引用，那么它就必须是唯一的引用（否则程序将无法通过编译）。将一个可变引用转换为不可变引用肯定不会破坏借用规则，但将一个不可变引用转换为可变引用则要求这个引用必须是唯一的，而借用规则无法保证这一点。因此，Rust无法将不可变引用转换为可变引用视作一个合理的操作。


第九十六章 借助Drop trait在清理时运行代码

◆ 使用std::mem::drop提前丢弃值
遗憾的是，我们无法直接禁用自动drop功能。当然，禁用drop通常也没有任何必要，因为Drop trait存在的意义就是为了完成自动释放的逻辑。不过，我们倒是常常会碰到需要提前清理一个值的情形。其中一个例子就是使用智能指针来管理锁时：你也许会希望强制运行drop方法来提前释放锁，从而允许同一作用域内的其他代码来获取它。Rust并不允许我们手动调用Drop trait的drop方法；但是，你可以调用标准库中的std::mem::drop函数来提前清理某个值。

◆ std::mem::drop函数不同于Drop trait中的drop方法。我们需要手动调用这个函数，并将需要提前丢弃的值作为参数传入。因为该函数被放置在了预导入模块中

◆ fn main() {￼    let c = CustomSmartPointer { data: String::from("some data") };￼    println!("CustomSmartPointer created.");￼    drop(c);￼    println!("CustomSmartPointer dropped before the end of main.");￼}

◆ 借助Drop trait和Rust的所有权系统，开发者可以将清理现场的工作完全交由Rust执行，它会自动处理好这类琐碎的任务。

◆ 我们也无须担心正在使用的值会被意外地清理掉：所有权系统会保证所有的引用有效，而drop只会在确定不再使用这个值时被调用一次。



第九十七章 基于引用计数的智能指针Rc<T>

◆ Rust提供了一个名为Rc<T>的类型来支持多重所有权，它名称中的Rc是Reference counting（引用计数）的缩写。Rc<T>类型的实例会在内部维护一个用于记录值引用次数的计数器，从而确认这个值是否仍在使用。如果对一个值的引用次数为零，那么就意味着这个值可以被安全地清理掉，而不会触发引用失效的问题。

◆ 当你希望将堆上的一些数据分享给程序的多个部分同时使用，而又无法在编译期确定哪个部分会最后释放这些数据时，我们就可以使用Rc<T>类型。

◆ 需要注意的是，Rc<T>只能被用于单线程场景中。

◆ 使用Rc<T>共享数据
我们曾经在示例15-5的链接列表程序中使用了Box<T>。这一次我们会创建出两个列表，并让它们同时持有第三个列表的所有权，结构如图15-3所示。
￼
图15-3　b和c两个列表同时持有第三个列表a的所有权
我们会首先创建一个包含5和10的列表a，并接着创建另外两个列表：以3开始的b和以4开始的c。b和c两个列表会连接至包含了5和10的列表a。换句话说，这两个列表将会共享第一个列表中的5和10。
基于Box<T>实现的List无法实现这样的场景，示例15-17中的代码无法正常运行。
src/main.rs
enum List {￼    Cons(i32, Box<List>),￼    Nil,￼}￼￼use crate::List::{Cons, Nil};￼￼fn main() {￼    let a = Cons(5,￼        Box::new(Cons(10,￼            Box::new(Nil))));￼ ❶ let b = Cons(3, Box::new(a));￼ ❷ let c = Cons(4, Box::new(a));￼}
示例15-17：Box<T>无法让两个列表同时持有另一列表的所有权
尝试编译这段代码会出现如下所示的错误：
error[E0382]: use of moved value: `a`￼  --> src/main.rs:13:30￼   |￼12 |     let b = Cons(3, Box::new(a));￼   |                              - value moved here￼13 |     let c = Cons(4, Box::new(a));￼   |                              ^ value used here after move￼   |￼   = note: move occurs because `a` has type `List`, which does not implement￼   the `Copy` trait
Cons变体持有它存储的数据。因此，整个a列表会在我们创建b列表时❶被移动至b中。换句话说，b列表持有了a列表的所有权。当我们随后再次尝试使用a来创建c列表时❷就会出现编译错误，因为a已经被移走了。
我们当然可以改变Cons的定义来让它持有一个引用而不是所有权，并为其指定对应的生命周期参数。但这个生命周期参数会要求列表中所有元素的存活时间都至少要和列表本身一样长。换句话说，借用检查器最终会阻止我们编译类似于let a = Cons(10, &Nil);这样的代码，因为此处临时创建的Nil变体值会在a取得其引用前被丢弃。
另外一种解决方案是，我们可以将List中的Box<T>修改为Rc<T>，如示例15-18所示。在这段新的代码中，每个Cons变体都会持有一个值及一个指向List的Rc<T>。我们只需要在创建b的过程中克隆a的Rc<List>智能指针即可，而不再需要获取a的所有权。这会使a和b可以共享Rc<List>数据的所有权，并使智能指针中的引用计数从1增加到2。随后，我们在创建c时也会同样克隆a并将引用计数从2增加到3。每次调用Rc::clone都会使引用计数增加，而Rc<List>智能指针中的数据只有在引用计数器减少到0时才会被真正清理掉。
src/main.rs
enum List {￼    Cons(i32, Rc<List>),￼    Nil,￼}￼￼use crate::List::{Cons, Nil};￼❶use std::rc::Rc;￼￼fn main() {￼ ❷ let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));￼ ❸ let b = Cons(3, Rc::clone(&a));￼ ❹ let c = Cons(4, Rc::clone(&a));￼}
示例15-18：使用Rc<T>定义List


◆ 由于Rc<T>没有被包含在预导入模块中，所以我们必须使用use语句来将它引入作用域❶。我们在main函数中首先创建了一个包含5和10的列表，并将这个新建的Rc<List>存入了a❷。随后，我们在创建b❸和c❹时调用的Rc::clone函数会接收a中Rc<List>的引用作为参数。
你可以在这里调用a.clone()而不是Rc::clone(&a)来实现同样的效果，但Rust的惯例是在此场景下使用Rc::clone，因为Rc::clone不会执行数据的深度拷贝操作，这与绝大多数类型实现的clone方法明显不同。调用Rc::clone只会增加引用计数，而这不会花费太多时间。但与此相对的是，深度拷贝则常常需要花费大量时间来搬运数据。因此，在引用计数上调用Rc::clone可以让开发者一眼就区分开“深度拷贝”与“增加引用计数”这两种完全不同的克隆行为。当你需要定位存在性能问题的代码时，就可以忽略Rc::clone而只需要审查剩余的深度拷贝克隆行为即可。

◆ 克隆Rc<T>会增加引用计数
接下来，让我们继续修改示例15-18中的代码来观察Rc<List>在创建和丢弃引用时的计数变化情形。
示例15-19在main函数中创建了一个被包裹在内部作用域中的c，让我们来看一看c离开作用域时引用计数会产生怎样的变化。
src/main.rs
fn main() {￼    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));￼    println!("count after creating a = {}", Rc::strong_count(&a));￼    let b = Cons(3, Rc::clone(&a));￼    println!("count after creating b = {}", Rc::strong_count(&a));￼    {￼        let c = Cons(4, Rc::clone(&a));￼        println!("count after creating c = {}", Rc::strong_count(&a));￼    }￼    println!("count after c goes out of scope = {}", Rc::strong_count(&a));￼}

◆ count after creating a = 1￼count after creating b = 2￼count after creating c = 3￼count after c goes out of scope = 2

◆ 我们能够看到a存储的Rc<List>拥有初始引用计数1，并在随后每次调用clone时增加1。而当c离开作用域被丢弃时，引用计数减少1。

◆ Rc<T>的Drop实现会在Rc<T>离开作用域时自动将引用计数减1。


◆ Rc<T>通过不可变引用使你可以在程序的不同部分之间共享只读数据。如果Rc<T>也允许你持有多个可变引用的话，那么它就会违反在第4章讨论过的其中一个借用规则：多个指向同一区域的可变借用会导致数据竞争及数据不一致。但在实际开发中，允许数据可变无疑是非常有用的！因此，我们接下来将要讨论内部可变性模式及RefCell<T>类型，该类型可以与Rc<T>联合使用来绕开不可变的限制。


第九十八章 RefCell<T>和内部可变性模式

◆ 内部可变性（interior mutability）是Rust的设计模式之一，它允许你在只持有不可变引用的前提下对数据进行修改；

◆ 通常而言，类似的行为会被借用规则所禁止。为了能够改变数据，内部可变性模式在它的数据结构中使用了unsafe（不安全）代码来绕过Rust正常的可变性和借用规则

◆ 假如我们能够保证自己的代码在运行时符合借用规则，那么就可以在即使编译器无法在编译阶段保证符合借用规则的前提下，也能使用那些采取了内部可变性模式的类型。实现过程中涉及的那些不安全代码会被妥善地封装在安全的API内，而类型本身从外部看来依然是不可变的。

◆ 使用RefCell<T>在运行时检查借用规则

◆ 与Rc<T>不同，RefCell<T>类型代表了其持有数据的唯一所有权。那么，RefCell<T>和Box<T>的区别究竟在哪里呢？让我们回忆一下在第4章学习的借用规则：
• 在任何给定的时间里，你要么只能拥有一个可变引用，要么只能拥有任意数量的不可变引用。
• 引用总是有效的。
对于使用一般引用和Box<T>的代码，Rust会在编译阶段强制代码遵守这些借用规则。而对于使用RefCell<T>的代码，Rust则只会在运行时检查这些规则，并在出现违反借用规则的情况下触发panic来提前中止程序。


◆ 将借用规则的检查放在编译阶段有许多优势：它不仅会帮助我们在开发阶段尽早地暴露问题，而且不会带来任何运行时的开销，因为所有检查都已经提前执行完毕。因此，在编译期检查借用规则对于大多数场景而言都是最佳的选择，这也正是Rust将编译期检查作为默认行为的原因。
在运行时检查借用规则则可以使我们实现某些特定的内存安全场景，即便这些场景无法通过编译时检查。静态分析（static analysis），正如Rust编译器一样，从本质上来讲是保守的。并不是程序中所有的属性都能够通过分析代码来得出：其中最为经典的例子莫过于停机问题（Halting Problem）。

◆ 因为某些分析是根本无法完成的，所以Rust编译器会简单地拒绝掉所有不符合所有权规则的代码，哪怕这些代码根本没有任何问题。Rust编译器的保守正是体现于此。一旦Rust放行了某个有问题的程序，那么Rust对安全性的保证就将直接破产，进而失去用户的信任！虽然拒绝掉某些正确的程序会对开发者造成不便，但至少这样不会产生什么灾难性的后果。在这类编译器无法理解代码，但开发者可以保证借用规则能够满足的情况下，RefCell<T>便有了它的用武之地。

◆ 与Rc<T>相似，RefCell<T>只能被用于单线程场景中。强行将它用于多线程环境中会产生编译时错误。

◆ 下面是选择使用Box<T>、Rc<T>还是RefCell<T>的依据：
• Rc<T>允许一份数据有多个所有者，而Box<T>和RefCell<T>都只有一个所有者。
• Box<T>允许在编译时检查的可变或不可变借用，Rc<T>仅允许编译时检查的不可变借用，RefCell<T>允许运行时检查的可变或不可变借用。
• 由于RefCell<T>允许我们在运行时检查可变借用，所以即便RefCell<T>本身是不可变的，我们仍然能够更改其中存储的值。
内部可变性模式允许用户更改一个不可变值的内部数据。

◆ 内部可变性：可变地借用一个不可变的值
借用规则的一个推论是，你无法可变地借用一个不可变的值。例如，下面这段代码就无法通过编译：
fn main() {￼    let x = 5;￼    let y = &mut x;￼}
尝试编译这段代码会产生如下所示的错误：
error[E0596]: cannot borrow immutable local variable `x` as mutable￼ --> src/main.rs:3:18￼  |￼2 |     let x = 5;￼  |         - consider changing this to `mut x`￼3 |     let y = &mut x;￼  |                  ^ cannot borrow mutably
然而，在某些特定情况下，我们也会需要一个值在对外保持不可变性的同时能够在方法内部修改自身。除了这个值本身的方法，其余的代码则依然不能修改这个值。使用RefCell<T>就是获得这种内部可变性的一种方法。不过，RefCell<T>并没有完全绕开借用规则：我们虽然使用内部可变性通过了编译阶段的借用检查，但借用检查的工作仅仅是被延后到了运行阶段。如果你违反了借用规则，那么就会得到一个panic! 而不再只是编译时的错误。


◆ 内部可变性的应用场景：模拟对象
测试替代（test double）是一个通用的编程概念，它代表了那些在测试工作中被用作其他类型替代品的类型。而模拟对象（mock object）则指代了测试替代中某些特定的类型，它们会承担起记录测试过程的工作。我们可以利用这些记录来断言测试工作的运行是否正确。
Rust没有和其他语言中类似的对象概念，也同样没有在标准库中提供模拟对象的测试功能。但是，我们可以自行定义一个结构体来实现与模拟对象相同的功能。
设计的测试场景如下：我们希望开发一个记录并对比当前值与最大值的库，它会基于当前值与最大值之间的接近程度向外传递信息。例如，这个库可以记录用户调用不同API的次数，并将它们与设置的调用限额进行比较。
我们只会在这个库中记录当前值与最大值的接近程度，以及决定何时显示何种信息。使用库的应用程序需要自行实现发送消息的功能，例如在应用程序中打印信息、发送电子邮件、发送文字短信等。我们会提供一个Messenger trait供外部代码来实现这些功能，而使库本身不需要关心这些细节。这个库的源代码如示例15-20所示。
src/lib.rs
pub trait Messenger {￼ ❶ fn send(&self, msg: &str);￼}￼￼pub struct LimitTracker<'a, T: 'a + Messenger> {￼    messenger: &'a T,￼    value: usize,￼    max: usize,￼}￼￼impl<'a, T> LimitTracker<'a, T>￼    where T: Messenger {￼    pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {￼        LimitTracker {￼            messenger,￼            value: 0,￼            max,￼        }￼    }￼￼ ❷ pub fn set_value(&mut self, value: usize) {￼        self.value = value;￼￼        let percentage_of_max = self.value as f64 / self.max as f64;￼￼        if percentage_of_max >= 1.0 {￼            self.messenger.send("Error: You are over your quota!");￼        } else if percentage_of_max >= 0.9 {￼             self.messenger.send("Urgent warning: You've used up over 90% of your quota!");￼        } else if percentage_of_max >= 0.75 {￼            self.messenger.send("Warning: You've used up over 75% of your quota!");￼        }￼    }￼}
示例15-20：我们的库会记录当前值与最大值的接近程度并根据不同的程度输出警告信息

◆ 这段代码的一个重点是Messenger trait，它唯一的方法send可以接收self的不可变引用及一条文本消息作为参数❶。我们创建的模拟对象就需要拥有这样的接口。另外一个重点则是LimitTracker的set_value方法，我们需要对这个方法的行为进行测试❷。你也许会尝试着改变value参数的值来进行测试，但set_value并不会返回任何可供断言的结果。实际上，我们需要在测试中确定的是，当某段程序使用一个实现了Messenger trait的值与一个max值来创建LimitTracker实例时，传入的不同value值能够触发messenger发送不同的信息。
我们的模拟对象在调用send时只需要将收到的信息存档记录即可，而不需要真的去发送邮件或短信。使用模拟对象来创建LimitTracker实例后，我们便可以通过调用set_value方法检查模拟对象中是否存储了我们希望见到的消息。按照这一思路实现的模拟对象如示例15-21所示，注意，这段代码还无法通过借用检查。
src/lib.rs
#[cfg(test)]￼mod tests {￼    use super::*;￼￼ ❶ struct MockMessenger {￼     ❷ sent_messages: Vec<String>,￼    }￼￼    impl MockMessenger {￼     ❸ fn new() -> MockMessenger {￼            MockMessenger { sent_messages: vec![] }￼        }￼    }￼￼ ❹ impl Messenger for MockMessenger {￼        fn send(&self, message: &str) {￼         ❺ self.sent_messages.push(String::from(message));￼        }￼    }￼￼    #[test]￼ ❻ fn it_sends_an_over_75_percent_warning_message() {￼        let mock_messenger = MockMessenger::new();￼        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);￼￼        limit_tracker.set_value(80);￼￼        assert_eq!(mock_messenger.sent_messages.len(), 1);￼    }￼}
示例15-21：尝试实现的MockMessenger在编译时无法通过借用检查
这段测试代码定义的MockMessenger结构体❶拥有一个sent_messages字段，它用携带String值的动态数组❷来记录所有接收到的信息。我们还定义了关联函数new❸来方便地创建一个不包含任何消息的新MockMessenger实例。接着，我们为MockMessenger实现了Messenger trait❹，从而使它可以被用于创建LimitTracker。在send方法的定义中❺，参数中的消息文本会被存入sent_messages的MockMessenger列表。
在测试函数中，我们希望检查LimitTracker在当前值value超过最大值max的75%时的行为❻。函数体中的代码首先创建了一个信息列表为空的MockMessenger实例，并使用它的引用及最大值100作为参数来创建LimitTracker。随后，我们调用了LimitTracker的set_value方法，并将值80传入该方法，这个值超过了最大值100的75%。最后，我们断言MockMessenger的信息列表中存在一条被记录下来的信息。


◆ 尝试编译这段测试代码会出现如下所示的错误：
error[E0596]: cannot borrow immutable field `self.sent_messages` as mutable￼  --> src/lib.rs:52:13￼   |￼51 |         fn send(&self, message: &str) {￼   |                 ----- use `&mut self` here to make mutable￼52 |             self.sent_messages.push(String::from(message));￼   |             ^^^^^^^^^^^^^^^^^^ cannot mutably borrow immutable fie
由于send方法接收了self的不可变引用，所以我们无法修改MockMessenger的内容来记录消息。我们也无法按照编译器在错误提示信息中给出的建议来将函数签名修改为&mut self，因为修改后的签名与Messenger trait定义的send的签名不符（你可以自行尝试进行这样的修改并观察出现的错误）。
这就是一个内部可变性能够大显身手的场景！只要在RefCell<T>中存入sent_messages，send方法就可以修改sent_messages来存储我们看到的信息了！修改后的代码如示例15-22所示。
src/lib.rs
#[cfg(test)]￼mod tests {￼    use super::*;￼    use std::cell::RefCell;￼￼    struct MockMessenger {￼     ❶ sent_messages: RefCell<Vec<String>>,￼    }￼￼    impl MockMessenger {￼        fn new() -> MockMessenger {￼         ❷ MockMessenger { sent_messages: RefCell::new(vec![]) }￼        }￼    }￼￼    impl Messenger for MockMessenger {￼        fn send(&self, message: &str) {￼         ❸ self.sent_messages.borrow_mut().push(String::from(message));￼        }￼    }￼￼    #[test]￼    fn it_sends_an_over_75_percent_warning_message() {￼        // --略--￼￼     ❹ assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);￼    }￼}
示例15-22：在保持外部值不可变的前提下，使用RefCell<T>来修改内部存储的值
sent_messages字段的类型变为了RefCell<Vec<String>>❶，而不再是Vec<String>。在new函数中，我们使用了一个空的动态数组来创建新的RefCell<Vec<String>>实例❷。
对于send方法的实现，其第一个参数依然是self的不可变借用，以便与trait的定义维持一致。随后的代码调用了RefCell<Vec<String>>类型的self.sent_messages的borrow_mut方法❸，来获取RefCell<Vec<String>>内部值（也就是动态数组）的可变引用。接着，我们便可以在动态数组的可变引用上调用push方法来存入数据，从而将已发送消息记录在案。
最后，我们还需要稍微修改一下断言语句。为了查看内部动态数组的长度，我们需要先调用RefCell<Vec<String>>的borrow方法来取得动态数组的不可变引用❹。

◆ 在了解了如何使用RefCell<T>后，让我们来接着研究一下它是如何工作的吧！
使用RefCell<T>在运行时记录借用信息
我们会在创建不可变和可变引用时分别使用语法&与&mut。对于RefCell<T>而言，我们需要使用borrow与borrow_mut方法来实现类似的功能，这两者都被作为RefCell<T>的安全接口来提供给用户。borrow方法和borrow_mut方法会分别返回Ref<T>与RefMut<T>这两种智能指针。由于这两种智能指针都实现了Deref，所以我们可以把它们当作一般的引用来对待。
RefCell<T>会记录当前存在多少个活跃的Ref<T>和RefMut<T>智能指针。每次调用borrow方法时，RefCell<T>会将活跃的不可变借用计数加1，并且在任何一个Ref<T>的值离开作用域被释放时，不可变借用计数将减1。RefCell<T>会基于这一技术来维护和编译器同样的借用检查规则：在任何一个给定的时间里，它只允许你拥有多个不可变借用或一个可变借用。
当我们违背借用规则时，相比于一般引用导致的编译时错误，RefCell<T>的实现会在运行时触发panic。示例15-23稍微修改了一下示例15-22中的send函数。这段新的代码故意在同一个作用域中创建两个同时有效的可变借用，以便演示RefCell<T>在运行时会如何阻止这一行为。
src/lib.rs
impl Messenger for MockMessenger {￼    fn send(&self, message: &str) {￼        let mut one_borrow = self.sent_messages.borrow_mut();￼        let mut two_borrow = self.sent_messages.borrow_mut();￼￼        one_borrow.push(String::from(message));￼        two_borrow.push(String::from(message));￼    }￼}
示例15-23：在同一个作用域中创建两个可变引用，这会使RefCell<T>引发panic

◆ 我们首先创建了一个RefMut<T>类型的one_borrow变量来存储从borrow_mut返回的结果，并在随后用同样的方法在two_borrow变量中创建另外一个可变借用。这段代码实现了一个不被允许的情形：同一个作用域中出现了两个可变引用。示例15-23中的测试代码可以顺利地通过编译，但却会在测试运行时运行失败：
---- tests::it_sends_an_over_75_percent_warning_message stdout ----￼        thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at￼'already borrowed: BorrowMutError', src/libcore/result.rs:906:4￼note: Run with `RUST_BACKTRACE=1` for a backtrace.
注意，这段代码触发了panic并输出信息already borrowed: BorrowMutError，这是RefCell<T>在运行时处理违反借用规则代码的方法。
在运行时而不是编译时捕获借用错误意味着，开发者很有可能到研发后期才得以发现问题，甚至是将问题暴露到生产环境中。另外，代码也会因为运行时记录借用的数量而产生些许性能损失。但不管怎么样，使用RefCell<T>都能够使我们在不可变的环境中修改自身数据，从而成功地编写出能够记录消息的不可变模拟对象。只要能够做出正确的取舍，你就可以借助RefCell<T>来完成某些常规引用无法完成的功能。


◆ 2024/06/12发表想法

花了几天时间一口气看到这里了，前面的东西也陆续忘了，开始模模糊糊的感觉了

原文：将Rc<T>和RefCell<T>结合使用来实现一个拥有多重所有权的可变数据
将RefCell<T>和Rc<T>结合使用是一种很常见的用法。Rc<T>允许多个所有者持有同一数据，但只能提供针对数据的不可变访问。如果我们在Rc<T>内存储了RefCell<T>，那么就可以定义出拥有多个所有者且能够进行修改的值了。

◆ 将Rc<T>和RefCell<T>结合使用来实现一个拥有多重所有权的可变数据
将RefCell<T>和Rc<T>结合使用是一种很常见的用法。Rc<T>允许多个所有者持有同一数据，但只能提供针对数据的不可变访问。如果我们在Rc<T>内存储了RefCell<T>，那么就可以定义出拥有多个所有者且能够进行修改的值了。


◆ 让我们以示例15-18中定义的链接列表为例，它使用Rc<T>来让多个列表共享同一个列表的所有权。由于Rc<T>只能存储不可变值，所以列表一经创建，其中的值就无法被再次修改了。现在，让我们在Cons定义中使用RefCell<T>来实现修改现有列表内数值的功能，如示例15-24所示。
src/main.rs
#[derive(Debug)]￼enum List {￼    Cons(Rc<RefCell<i32>>, Rc<List>),￼    Nil,￼}￼￼use crate::List::{Cons, Nil};￼use std::rc::Rc;￼use std::cell::RefCell;￼￼fn main() {￼ ❶ let value = Rc::new(RefCell::new(5));￼￼ ❷ let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));￼￼    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&a));￼    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&a));￼￼ ❸ *value.borrow_mut() += 10;￼￼    println!("a after = {:?}", a);￼    println!("b after = {:?}", b);￼    println!("c after = {:?}", c);￼}
示例15-24：使用Rc<RefCell<i32>>创建一个可变的List
main函数中的代码首先创建了一个Rc<RefCell<i32>>实例，并将它暂时存入了value变量中❶以便之后可以直接访问。接着，我们使用含有value的Cons变体创建一个List类型的a变量❷。为了确保a和value同时持有内部值5的所有权，这里的代码还克隆了value，而不仅仅只是将value的所有权传递给a，或者让a借用value。
与示例15-18类似，为了让随后创建的b和c能够同时指向a，我们将a封装到了Rc<T>中。
创建完a、b、c这3个列表后，我们通过调用borrow_mut来将value指向的值增加10❸。注意，这里使用了自动解引用功能（在第5章讨论过）来将Rc<T>解引用为RefCell<T>。borrow_mut方法会返回一个RefMut<T>智能指针，我们可以使用解引用运算符来修改其内部值。
打印a、b、c这3个列表可以看到它们存储的值都从5变为了15：
a after = Cons(RefCell { value: 15 }, Nil)￼b after = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))￼c after = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))
这种实现方法非常简单明了！通过使用RefCell<T>，我们拥有的List保持了表面上的不可变状态，并能够在必要时借由RefCell<T>提供的方法来修改其内部存储的数据。运行时的借用规则检查同样能够帮助我们避免数据竞争，在某些场景下为了必要的灵活性而牺牲一些运行时性能也是值得的。
标准库还提供了其他一些类型来实现内部可变性，例如与RefCell<T>十分类似的Cell<T>，但相比于前者通过借用来实现内部数据的读写，Cell<T>选择了通过复制来访问数据。另外还有在第16章会讨论到的Mutex<T>，它被用于实现跨线程情形下的内部可变性模式。请参考标准库文档来了解有关这些类型有哪些区别的更多信息。



第九十九章 循环引用会造成内存泄漏

◆ 循环引用会造成内存泄漏
Rust提供的内存安全保障使我们很难在程序中意外地制造出永远不会得到释放的内存空间（也就是所谓的内存泄漏），但这也并非是不可能的。与数据竞争不同，在编译期彻底防止内存泄漏并不是Rust作出的保证之一，这也意味着内存泄漏在Rust中是一种内存安全行为。你可以通过使用Rc<T>和RefCell<T>看到Rust是允许内存泄漏的：我们能够创建出互相引用成环状的实例。由于环中每一个指针的引用计数都不可能减少到0，所以对应的值也不会被释放丢弃，这就造成了内存泄漏。

◆ # fn main() {}￼use std::rc::Rc;￼use std::cell::RefCell;￼use crate::List::{Cons, Nil};￼￼#[derive(Debug)]￼enum List {￼ ❶ Cons(i32, RefCell<Rc<List>>),￼    Nil,￼}￼￼impl List {￼ ❷ fn tail(&self) -> Option<&RefCell<Rc<List>>> {￼        match self {￼            Cons(_, item) => Some(item),￼            Nil => None,￼        }￼    }￼}

◆ fn main() {￼ ❶ let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));￼￼    println!("a initial rc count = {}", Rc::strong_count(&a));￼    println!("a next item = {:?}", a.tail());￼￼ ❷ let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));￼￼    println!("a rc count after b creation = {}", Rc::strong_count(&a));￼    println!("b initial rc count = {}", Rc::strong_count(&b));￼    println!("b next item = {:?}", b.tail());￼￼ ❸ if let Some(link) = a.tail() {￼     ❹ *link.borrow_mut() = Rc::clone(&b);￼    } ￼￼    println!("b rc count after changing a = {}", Rc::strong_count(&b));￼    println!("a rc count after changing a = {}", Rc::strong_count(&a));￼￼    // 取消下面的注释行便可以观察到循环引用；它会造成栈的溢出。​​    // println!("a next item = {:?}", a.tail());￼}


◆ 假如去除最后一行println! 的注释并再次运行程序，那么Rust会在尝试将这个循环引用打印出来的过程中反复地从a跳转至b，再从b跳转至a；整个程序会一直处于这样的循环中直到发生栈溢出为止。

◆ 对于一个逻辑更复杂的程序而言，在循环引用中分配并长时间持有大量内存会让程序不断消耗掉超过业务所需的内存，这样的漏洞可能会导致内存逐步消耗殆尽并最终拖垮整个系统。

◆ 在Rust中创建出循环引用并不是特别容易，但也绝非不可能。如果你的程序中存在RefCell<T>包含Rc<T>或其他联用了内部可变性与引用计数指针的情形，那么你就需要自行确保不会在代码中创建出循环引用；Rust的特性对这样的场景无能为力。创建出循环引用意味着你的代码逻辑出现了bug，而这些bug可以通过自动化测试、代码评审及其他的软件开发手段来尽可能地避免。
另外一种用于解决循环引用的方案需要重新组织数据结构，它会将引用拆分为持有所有权和不持有所有权两种情形。因此，你可以在形成的环状实例中让某些指向关系持有所有权，并让另外某些指向关系不持有所有权。只有持有所有权的指向关系才会影响到某个值是否能够被释放。接下来，让我们来观察一个由父子节点组成的图状数据结构，并思考非所有权关系是如何帮助我们避免循环引用的。

◆ 使用Weak<T>代替Rc<T>来避免循环引用
目前，我们已经演示了如何通过调用Rc::clone来增加Rc<T>实例的strong_count引用计数，并指出Rc<T>实例只有在strong_count为0时才会被清理。不过除此之外，我们还可以通过调用Rc::downgrade函数来创建出Rc<T>实例中值的弱引用。使用Rc<T>的引用来调用Rc::downgrade函数会返回一个类型为Weak<T>的智能指针，这一操作会让Rc<T>中weak_count的计数增加1，而不会改变strong_count的状态。Rc<T>类型使用weak_count来记录当前存在多少个Weak<T>引用，这与strong_count有些类似。它们之间的差别在于，Rc<T>并不会在执行清理操作前要求weak_count必须减为0。
强引用可以被我们用来共享一个Rc<T>实例的所有权，而弱引用则不会表达所有权关系。一旦强引用计数减为0，任何由弱引用组成的循环就会被打破。因此，弱引用不会造成循环引用。
由于我们无法确定Weak<T>引用的值是否已经被释放了，所以我们需要在使用Weak<T>指向的值之前确保它依然存在。你可以调用Weak<T>实例的upgrade方法来完成这一验证。此函数返回的Option<Rc<T>>会在Rc<T>值依然存在时表达为Some，而在Rc<T>值被释放时表达为None。由于upgrade返回的是Option<T>类型，所以Rust能够保证Some和None两个分支都得到妥善的处理，而不会产生无效指针之类的问题。

◆ 现在换一种思路来考虑此处的父子节点关系：父节点自然应该拥有子节点的所有权，因为当父节点被丢弃时，子节点也应当随之被丢弃。但子节点却不应该拥有父节点，父节点的存在性不会因为丢弃子节点而受到影响。这正是应当使用弱引用的场景！

◆ use std::rc::{Rc, Weak};￼use std::cell::RefCell;￼￼#[derive(Debug)]￼struct Node {￼    value: i32,￼    parent: RefCell<Weak<Node>>,￼    children: RefCell<Vec<Rc<Node>>>,￼}

◆ fn main() {￼    let leaf = Rc::new(Node {￼        value: 3,￼     ❶ parent: RefCell::new(Weak::new()),￼        children: RefCell::new(vec![]),￼    });￼￼ ❷ println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());￼￼    let branch = Rc::new(Node {￼        value: 5,￼     ❸ parent: RefCell::new(Weak::new()),￼        children: RefCell::new(vec![Rc::clone(&leaf)]),￼    });￼￼ ❹ *leaf.parent.borrow_mut() = Rc::downgrade(&branch);￼￼ ❺ println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());￼}

◆ 示例15-28：leaf节点持有一个指向父节点branch的弱引用

◆ 现在打印leaf还可以避免示例15-26中因循环引用而导致的栈溢出故障，因为Weak<Node>引用会被直接打印为(Weak)。

◆ leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },￼children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },￼children: RefCell { value: [] } }] } })
有限的输出意味着代码中没有产生循环引用。这一结论同样可以通过观察Rc::strong_count和Rc::weak_count的计数值来得出。

◆ 所有这些用于管理引用计数及值释放的逻辑都被封装到了Rc<T>与Weak<T>类型，以及它们对Drop trait的具体实现中。通过在Node定义中将子节点指向父节点的关系定义为一个Weak<T>引用，可以使父子节点在指向彼此的同时避免产生循环引用或内存泄漏。



第一百零章 总结

◆ 本章涉及了如何使用智能指针来实现不同于Rust常规引用的功能保障与取舍。Box<T>类型拥有固定的大小并指向一段分配于堆上的数据。Rc<T>类型通过记录堆上数据的引用次数使该数据可以拥有多个所有者。RefCell<T>类型则通过其内部可变性模式使我们可以修改一个不可变类型的内部值；它会在运行时而不是编译时承担起维护借用规则的责任。
我们还讨论了实现智能指针功能不可或缺的Deref和Drop这两个trait。最后，我们研究了会触发内存泄漏的循环引用问题，以及如何使用Weak<T>来避免它们。

◆ 如果本章的内容引起了你的兴趣并希望立即开始实现智能指针的话，那么你可以参考Rust官方网站上的The Rustonomicon来获得更多有用的信息。


第一百一章 第16章 无畏并发

◆ 第16章无畏并发


◆ Rust团队曾经认为保证内存安全和防止并发问题是两个截然不同的挑战，我们需要使用不同的方法来解决它们。但是随着时间的推移，开发团队发现所有权和类型系统这套强有力的工具集能够同时帮助我们管理内存安全及并发问题！借助所有权和类型检查，许多并发问题可以在Rust中暴露为编译时错误而不是运行时错误。因此，相比于在运行时遭遇并发缺陷后花费大量时间来重现特定的问题场景，Rust编译器会直接拒绝不正确的代码并给出解释问题的错误提示信息。这使得代码中的并发缺陷可以在开发过程中被及时修复，而不必等到它们被发布至生产环境后暴露出来。

◆ 我们会在本章讨论以下话题：
• 如何创建线程来同时运行多段代码。
• 使用通道在线程间发送消息的消息传递式并发。
• 允许多个线程访问同一片数据的共享状态式并发。
• Sync trait与Send trait，能够将Rust的并发保证从标准库中提供的类型扩展至用户自定义类型。


第一百二章 使用线程同时运行代码

◆ 现有的编程语言采用了不同的方式来实现线程。许多操作系统都提供了用于创建新线程的API。这种直接利用操作系统API来创建线程的模型常常被称作1:1模型，它意味着一个操作系统线程对应一个语言线程。
也有许多编程语言提供了它们自身特有的线程实现，这种由程序语言提供的线程常常被称为绿色线程（green thread），使用绿色线程的语言会在拥有不同数量系统线程的环境下运行它们。为此，绿色线程也被称为M:N模型，它表示M个绿色线程对应着N个系统线程，这里的M与N不必相等。
每一种模型都有其自身的优势和取舍。对于Rust而言，设计过程中最重要的权衡因素在于是否需要提供运行时支持。运行时（runtime）是一个容易令人迷惑的术语，它在不同的上下文中拥有不同的含义。
在当前语境下，运行时指语言中那些被包含在每一个可执行文件中的代码。不同的语言拥有不同大小的运行时代码。除汇编语言之外，编程语言总是会包含一定数量的运行时代码。因此，当人们提到某种语言“没有运行时”的时候，他们想要表达的其实是该语言的“运行时非常小”。较小的运行时拥有较少的功能，但却可以生成较小的二进制文件，并可以使该语言能够方便地在众多场景下与其他语言组合使用。尽管许多语言选择了增加运行时来提供更多的功能，但Rust会尽可能地保持几乎没有运行时的状态，这使我们可以方便地与C语言进行交互并获得较高的性能。
由于绿色线程的M:N模型需要一个较大的运行时来管理线程，所以Rust标准库只提供了1:1线程模型的实现。但得益于Rust良好的底层抽象能力，Rust社区中涌现出了许多支持M:N线程模型的第三方包。你可以选择付出一定开销来获得期望的特性，诸如更强的线程控制能力、更低的线程上下文切换开销等。

◆ 使用spawn创建新线程

◆ use std::thread;￼￼use std::time::Duration;￼￼fn main() {￼    thread::spawn(|| {￼        for i in 1..10 {￼            println!("hi number {} from the spawned thread!", i);￼            thread::sleep(Duration::from_millis(1));￼        }￼    });￼￼    for i in 1..5 {￼        println!("hi number {} from the main thread!", i);￼        thread::sleep(Duration::from_millis(1));￼    }￼}

◆ 需要注意的是，只要这段程序中的主线程运行结束，创建出的新线程就会相应停止，而不管它的打印任务是否完成。

◆ 使用join句柄等待所有线程结束

◆ thread::spawn的返回值类型是一个自持有所有权的JoinHandle，调用它的join方法可以阻塞当前线程直到对应的新线程运行结束

◆ move闭包常常被用来与thread::spawn函数配合使用，它允许你在某个线程中使用来自另一个线程的数据。

◆ 我们在第13章曾经提到过，你可以在闭包的参数列表前使用move关键字来强制闭包从外部环境中捕获值的所有权。这一技术在我们创建新线程时尤其有用，它可以跨线程地传递某些值的所有权。

◆ 通过在闭包前添加move关键字，我们会强制闭包获得它所需值的所有权，而不仅仅是基于Rust的推导来获得值的借用。

◆ use std::thread;￼￼fn main() {￼    let v = vec![1, 2, 3];￼￼    let handle = thread::spawn(move || {￼        println!("Here's a vector: {:?}", v);￼    });￼￼    handle.join().unwrap();￼}

◆ 使用move关键字来强制闭包获得它所需值的所有权


第一百三章 使用消息传递在线程间转移数据

◆ 使用消息传递在线程间转移数据
使用消息传递（message passing）机制来保证并发安全正在变得越来越流行。在这种机制中，线程或actor之间通过给彼此发送包含数据的消息来进行通信。Go编程语言文档中的口号正体现了这样的思路：不要通过共享内存来通信，而是通过通信来共享内存。

◆ 编程中的通道由发送者（transmitter）和接收者（receiver）两个部分组成。发送者位于通道的上游，也就是你放置橡皮鸭的地方；而接收者则位于通道的下游，也就是橡皮鸭到达的地方。某一处代码可以通过调用发送者的方法来传送数据，而另一处代码则可以通过检查接收者来获取数据。当你丢弃了发送者或接收者的任何一端时，我们就称相应的通道被关闭（closed）了。


◆ 路径中的mpsc是英文“multiple producer, single consumer”（多个生产者，单个消费者）的缩写。

◆ 函数mpsc::channel会返回一个含有发送端与接收端的元组。代码中用来绑定它们的变量名称为tx和rx，这也是在许多场景下发送者与接收者的惯用简写

◆  std::thread;￼use std::sync::mpsc;￼￼fn main() {￼    let (tx, rx) = mpsc::channel();￼￼    thread::spawn(move || {￼        let val = String::from("hi");￼        tx.send(val).unwrap();￼    });￼￼    let received = rx.recv().unwrap();￼    println!("Got: {}", received);￼}

◆ 通道的接收端有两个可用于获取消息的方法：recv和try_recv。我们使用的recv（也就是receive的缩写）会阻塞主线程的执行直到有值被传入通道。一旦有值被传入通道，recv就会将它包裹在Result<T, E>中返回。而如果通道的发送端全部关闭了，recv则会返回一个错误来表明当前通道再也没有可接收的值。
try_recv方法不会阻塞线程，它会立即返回Result<T, E>：当通道中存在消息时，返回包含该消息的Ok变体；否则便返回Err变体。当某个线程需要一边等待消息一边完成其他工作时，try_recv方法会非常有用。我们可以编写出一个不断调用try_recv方法的循环，并在有消息到来时对其进行处理，而在没有消息时执行其他指令。


◆ 为了简单起见，我们在本例中使用了recv；由于示例中的主线程除等待消息之外没有其他任何工作可做，所以阻塞主线程是合适的。

◆ send函数会获取参数的所有权，并在参数传递时将所有权转移给接收者

◆  std::thread;￼use std::sync::mpsc; ￼use std::time::Duration;￼￼fn main() {￼    let (tx, rx) = mpsc::channel();￼￼    thread::spawn(move || {￼        let vals = vec![￼            String::from("hi"),￼            String::from("from"),￼            String::from("the"),￼            String::from("thread"),￼        ];￼￼        for val in vals {￼            tx.send(val).unwrap();￼            thread::sleep(Duration::from_secs(1));￼        }￼    });￼￼    for received in rx {￼        println!("Got: {}", received);￼    }￼}
示例16-10：发送多条消息并在每次发送后暂停1秒钟
这段代码在新线程中创建了一个用于存储字符串的动态数组。我们会迭代动态数组来逐个发送其中的字符串，并在每次发送后调用Duration值为1秒的thread::sleep函数来稍作暂停。
在主线程中，我们会将rx视作迭代器，而不再显式地调用recv函数。迭代中的代码会打印出每个接收到的值，并在通道关闭时退出循环。

◆ 通过克隆发送者创建多个生产者

◆ let (tx, rx) = mpsc::channel();￼￼let tx1 = mpsc::Sender::clone(&tx);￼thread::spawn(move || {￼    let vals = vec![￼        String::from("hi"),￼        String::from("from"),￼        String::from("the"),￼        String::from("thread"),￼    ];￼￼    for val in vals {￼        tx1.send(val).unwrap();￼        thread::sleep(Duration::from_secs(1));￼    }￼});￼￼thread::spawn(move || {￼    let vals = vec![￼        String::from("more"),￼        String::from("messages"),￼        String::from("for"),￼        String::from("you"),￼    ];￼￼    for val in vals {￼        tx.send(val).unwrap();￼        thread::sleep(Duration::from_secs(1));￼    }￼});￼￼for received in rx {￼    println!("Got: {}", received);￼}￼￼// --略--￼}
示例16-11：用多个生产者发送多条消息


第一百四章 共享状态的并发

◆ 共享状态的并发

◆ 互斥体（mutex）是英文mutual exclusion的缩写。也就是说，一个互斥体在任意时刻只允许一个线程访问数据。为了访问互斥体中的数据，线程必须首先发出信号来获取互斥体的锁（lock）。

◆ 在Rust中，由于类型系统和所有权规则的帮助，我们可以保证自己不会在加锁和解锁这两个步骤中出现错误。

◆ Mutex<T>是一种智能指针。更准确地说，对lock的调用会返回一个名为MutexGuard的智能指针。这个智能指针通过实现Deref来指向存储在内部的数据，它还会通过实现Drop来完成自己离开作用域时的自动解锁操作。

◆ 多线程与多重所有权
在第15章中，我们借助于智能指针Rc<T>提供的引用计数为单个值赋予了多个所有者。接下来，我们会尝试用相同的方法来解决当前的问题。示例16-14中的代码使用Rc<T>来包裹Mutex<T>，并在每次需要移动所有权至线程时克隆Rc<T>。另外，鉴于我们已经发现了错误的原因，所以下面的代码重新使用了for循环，并且依然为闭包使用了move关键字。


◆ 不幸的是，Rc<T>在跨线程使用时并不安全。当Rc<T>管理引用计数时，它会在每次调用clone的过程中增加引用计数，并在克隆出的实例被丢弃时减少引用计数，但它并没有使用任何并发原语来保证修改计数的过程不会被另一个线程所打断。这极有可能导致计数错误并产生诡异的bug，比如内存泄漏或值在使用时被莫名其妙地提前释放。我们需要的是一个行为与Rc<T>一致，且能够保证线程安全的引用计数类型。


◆ 原子引用计数Arc<T>
幸运的是，我们拥有一种被称为Arc<T>的类型，它既拥有类似于Rc<T>的行为，又保证了自己可以被安全地用于并发场景。它名称中的A代表着原子（atomic），表明自己是一个原子引用计数（atomically reference counted）类型。原子是一种新的并发原语，我们可以参考标准库文档中的std::sync::atomic部分来获得更多相关信息。你现在只需要知道：原子和原生类型的用法十分相似，并且可以安全地在多个线程间共享。
你也许会疑惑的是：为什么不将所有的原生类型实现为原子？标准库中的类型为什么不默认使用Arc<T>来实现呢？这是因为我们需要付出一定的性能开销才能够实现线程安全，而我们只应该在必要时为这种开销买单。如果你只是在单线程中对值进行操作，那么我们的代码可以因为无须原子的安全保障而运行得更快。

◆ use std::sync::{Mutex, Arc};￼use std::thread;￼￼fn main() {￼    let counter = Arc::new(Mutex::new(0));￼    let mut handles = vec![];￼￼    for _ in 0..10 {￼        let counter = Arc::clone(&counter);￼        let handle = thread::spawn(move || {￼            let mut num = counter.lock().unwrap();￼￼            *num += 1;￼        });￼        handles.push(handle);￼    }￼￼    for handle in handles {￼        handle.join().unwrap();￼    }￼￼    println!("Result: {}", *counter.lock().unwrap());￼}
示例16-15：使用Arc<T>包裹Mutex<T>来实现多线程共享所有权
这段代码将会打印出下面的结果：
Result: 10
终于成功了！我们的计数器从0变为了10。虽然这个例子看上去非常平凡，但我们确实在这个过程中掌握了许多有关Mutex<T>与线程安全的知识。你可以使用本节中的程序结构去完成比计数更为复杂的工作。基于这个策略，你可以将计算分割为多个独立的部分，并将它们分配至不同的线程中，然后使用Mutex<T>来允许不同的线程更新计算结果中与自己有关的那一部分。


◆ RefCell<T>/Rc<T>和Mutex<T>/Arc<T>之间的相似性
你可能会注意到，虽然counter本身不可变，但我们仍然能够获取其内部值的可变引用。这意味着，Mutex<T>与Cell系列类型有着相似的功能，它同样提供了内部可变性。我们在第15章使用了RefCell<T>来改变Rc<T>中的内容，而本节按照同样的方式使用Mutex<T>来改变Arc<T>中的内容。
另外还有一个值得注意的细节是，Rust并不能使你完全避免使用Mutex<T>过程中所有的逻辑错误。回顾第15章中讨论的内容，使用Rc<T>会有产生循环引用的风险。两个Rc<T>值在互相指向对方时会造成内存泄漏。与之类似，使用Mutex<T>也会有产生死锁（deadlock）的风险。当某个操作需要同时锁住两个资源，而两个线程分别持有其中一个锁并相互请求另外一个锁时，这两个线程就会陷入无穷尽的等待过程。如果你对死锁感兴趣，不妨试着编写一个可能导致死锁的Rust程序。然后，你还可以借鉴其他语言中规避互斥体死锁的策略，并在Rust中实现它们。标准库API文档的Mutex<T>和MutexGuard页面为此提供了许多有用的信息。



第一百五章 使用Sync trait和Send trait对并发进行扩展

◆ 使用Sync trait和Send trait对并发进行扩展

◆ 有趣的是，Rust语言本身内置的并发特性非常少。到目前为止，我们在本章讨论的几乎每一个并发特性都是标准库的一部分，而非语言本身内置的。你能够用来处理并发的解决方案也不仅仅只局限于语言本身或标准库。我们既可以编写自己的并发功能，也可以使用他人写好的并发框架。
但不管怎样，仍然有两个并发概念被内嵌在了Rust语言中，它们是std::marker模块内的Sync trait与Send trait。

◆ 允许线程间转移所有权的Send trait
只有实现了Send trait的类型才可以安全地在线程间转移所有权。除了Rc<T>等极少数的类型，几乎所有的Rust类型都实现了Send trait：如果你将克隆后的Rc<T>值的所有权转移到了另外一个线程中，那么两个线程就有可能同时更新引用计数值并进而导致计数错误。因此，Rc<T>只被设计在单线程场景中使用，它也无须为线程安全付出额外的性能开销。
因此，Rust的类型系统与trait约束能够阻止我们意外地跨线程传递Rc<T>实例。当我们在示例16-14中试图执行这类操作时立马触发了编译时错误：the trait Send is not implemented for Rc&t;Mutex<i32>>。而当我们切换到实现了Send的Arc<T>后，那段代码就顺利地编译通过了。
任何完全由Send类型组成的复合类型都会被自动标记为Send。除了我们在第19章将会讨论到的裸指针，几乎所有的原生类型都满足Send约束。
允许多线程同时访问的Sync trait
只有实现了Sync trait的类型才可以安全地被多个线程引用。换句话说，对于任何类型T，如果&T（也就是T的引用）满足约束Send，那么T就是满足Sync的。这意味着T的引用能够被安全地传递至另外的线程中。与Send类似，所有原生类型都满足Sync约束，而完全由满足Sync的类型组成的复合类型也都会被自动识别为满足Sync的类型。
智能指针Rc<T>同样不满足Sync约束，其原因与它不满足Send约束类似。在第15章讨论过的RefCell<T>类型及Cell<T>系列类型也不满足Sync约束。RefCell<T>实现的运行时借用检查并没有提供有关线程安全的保证。而正如“在多个线程间共享Mutex<T>”一节中讨论的那样，智能指针Mutex<T>是Sync的，可以被多个线程共享访问。
手动实现Send和Sync是不安全的
当某个类型完全由实现了Send与Sync的类型组成时，它就会自动实现Send与Sync。因此，我们并不需要手动地为此种类型实现相关trait。作为标签trait，Send与Sync甚至没有任何可供实现的方法。它们仅仅被用来强化与并发相关的不可变性。
手动实现这些trait涉及使用特殊的不安全Rust代码。我们将在第19章讨论这一概念，目前你需要注意的是，当你构建的自定义并发类型包含了没有实现Send或Sync的类型时，你必须要非常谨慎地确保设计能够满足线程间的安全性要求。Rust官方网站中的The Rustonomicon文档详细地讨论了此类安全性保证及如何满足安全性要求的具体技术。


第一百六章 总结

◆ Rust内置在语言中的并发特性相当少，几乎所有的并发解决方案都被实现为了不同的代码包。它们的迭代演化速度要远快于标准库，当你需要使用多线程时，请不要忘记到网络上搜索最新的、具有最高水准的第三方包。
Rust在标准库中提供了用于实现消息传递的通道，也提供了可以在并发场景中安全使用的智能指针：Mutex<T>与Arc<T>。类型系统与借用检查器则确保了使用这些组件的代码不会产生数据竞争或无效引用。只要我们的代码能够顺利通过编译，你就可以相信它能够正确地运行在多线程环境中，而不会出现其他语言中常见的那些难以解决的bug。并发编程在Rust中不再是一个令人望而生畏的概念：请无所畏惧地使用并发吧！


第一百七章 第17章 Rust的面向对象编程特性

◆ 第17章Rust的面向对象编程特性


第一百八章 面向对象语言的特性

◆ 我们认为面向对象的语言通常都包含以下这些特性：命名对象、封装及继承。

◆ impl AveragedCollection {￼    pub fn add(&mut self, value: i32) {￼        self.list.push(value);￼        self.update_average();￼    }￼￼    pub fn remove(&mut self) -> Option<i32> {￼        let result = self.list.pop();￼        match result {￼            Some(value) => {￼                self.update_average();￼                Some(value)￼            },￼            None => None,￼        }￼    }￼￼    pub fn average(&self) -> f64 {￼        self.average￼    }￼￼    fn update_average(&mut self) {￼        let total: i32 = self.list.iter().sum();￼        self.average = total as f64 / self.list.len() as f64;￼    }￼}

◆ 作为类型系统和代码共享机制的继承

◆ 选择使用继承有两个主要原因。其一是实现代码复用：你可以为某个类型实现某种行为，并接着通过继承来让另一个类型直接复用这一实现。作为替代解决方案，你可以使用Rust中的默认trait方法来进行代码共享。

◆ 我们曾经在示例10-14中演示过这一特性，示例中的代码为Summary trait的summarize方法提供了一个默认实现。任何实现了Summary trait的类型都会自动拥有这个summarize方法，而无须添加额外的重复代码。这与继承十分相似，父类中的实现方法可以被继承它的子类所拥有。另外，我们还可以在实现Summary trait时选择覆盖summarize方法的默认实现，正如子类覆盖父类中的方法一样。
另外一个使用继承的原因与类型系统有关：希望子类型能够被应用在一个需要父类型的地方。这也就是所谓的多态（polymorphism）：如果一些对象具有某些共同的特性，那么这些对象就可以在运行时相互替换使用。


◆ 许多人将“多态”视作“继承”的同义词。但实际上多态是一个更为通用的概念，它指代所有能够适应多种数据类型的代码。对于继承概念而言，这些类型就是所谓的子类。
你可以在Rust中使用泛型来构建不同类型的抽象，并使用trait约束来决定类型必须提供的具体特性。这一技术有时也被称作限定参数化多态（bounded parametric polymorphism）。

◆ 许多较为新潮的语言已经不太喜欢将继承作为内置的程序设计方案了，因为使用继承意味着你会在无意间共享出比所需内容更多的代码。子类并不应该总是共享父类的所有特性，但使用继承机制却会始终产生这样的结果，进而使程序设计缺乏灵活性。子类在继承的过程中有可能会引入一些毫无意义甚至根本就不适用于子类的方法。另外，某些语言强制要求子类只能继承自单个父类，这进一步限制了程序设计的灵活性。


◆ 考虑到这些弊端，Rust选择了trait对象来代替继承。让我们一起来看一看trait对象是如何在Rust中实现多态的。



第一百九章 使用trait对象来存储不同类型的值

◆ 使用trait对象来存储不同类型的值

◆ trait对象会执行动态派发
在第10章的“泛型代码的性能问题”一节中，我们曾经介绍过Rust编译器会在泛型使用trait约束时执行单态化：编译器会为每一个具体类型生成对应泛型函数和泛型方法的非泛型实现，并使用这些具体的类型来替换泛型参数。通过单态化生成的代码会执行静态派发（static dispatch），这意味着编译器能够在编译过程中确定你调用的具体方法。这个概念与动态派发（dynamic dispatch）相对应，动态派发下的编译器无法在编译过程中确定你调用的究竟是哪一个方法。在进行动态派发的场景中，编译器会生成一些额外的代码以便在运行时找出我们希望调用的方法。

◆ Rust必然会在我们使用trait对象时执行动态派发。因为编译器无法知晓所有能够用于trait对象的具体类型，所以它无法在编译时确定需要调用哪个类型的哪个具体方法。不过，Rust会在运行时通过trait对象内部的指针去定位具体调用哪个方法。该定位过程会产生一些不可避免的运行时开销，而这并不会出现在静态派发中。动态派发还会阻止编译器内联代码，进而使得部分优化操作无法进行。但不管怎么样，动态派发确实能够为示例17-5中的代码带来额外的灵活性，它同时支撑了示例17-9中的代码。你可以基于这些对项目的考虑来决定是否使用trait对象。


◆ trait对象必须保证对象安全
需要注意的是，你只能把满足对象安全（object-safe）的trait转换为trait对象。Rust采用了一套较为复杂的规则来决定某个trait是否对象安全。但在实际应用中，我们只需要关注其中两条规则即可。如果一个trait中定义的所有方法满足下面两条规则，那么这个trait就是对象安全的：
• 方法的返回类型不是Self。
• 方法中不包含任何泛型参数。
关键字Self是一个别名，它指向了实现当前trait或方法的具体类型。trait对象必须是对象安全的，因为Rust无法在我们使用trait对象时确定实现这个trait的具体类型究竟是什么。由于trait对象忘记了Self的具体类型，所以编译器无法在trait方法返回Self时使用原来的具体类型。同理，对于trait方法中的泛型参数而言，我们会在使用时将具体类型填入泛型所处的位置，这些具体类型会被视作当前类型的一部分。由于trait对象忘记了类型信息，所以我们无法确定被填入泛型参数处的类型究竟是哪一个。
标准库中的Clone trait就是一个不符合对象安全的例子。Clone trait中的clone方法拥有这样的签名：
pub trait Clone {￼    fn clone(&self) -> Self;￼}
由于String类型实现了Clone trait，所以我们可以在String实例上调用clone方法来获得一个新的String实例。类似地，我们也可以在Vec<T>实例上调用clone来获得新的Vec<T>实例。clone方法的签名需要知道Self究竟代表了哪一种具体类型，因为这是它作为结果返回的类型。
编译器会在你使用trait对象时，指出违反了对象安全规则的地方。以示例17-4中的代码为例，让我们在Screen结构体中存储实现了Clone trait的类型：
pub struct Screen {￼    pub components: Vec<Box<dyn Clone>>,￼}
编译这段代码会出现如下所示的错误：
error[E0038]: the trait `std::clone::Clone` cannot be made into an object￼ --> src/lib.rs:2:5￼  |￼2 |     pub components: Vec<Box<dyn Clone>>,￼  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` cannot be￼made into an object￼  |￼  = note: the trait cannot require that `Self : Sized`
上面的错误提示信息表明我们不能按照这种方式将Clone trait用作trait对象。如果你想了解更多有关对象安全的信息，请参考Rust官方网站的RFC 255文档。


第一百一十二章 第18章 模式匹配

◆ 第18章模式匹配



第一百一十三章 所有可以使用模式的场合

◆ 所有可以使用模式的场合

◆ match分支

◆ match 值 { ￼    模式 => 表达式,​​    模式 => 表达式,​​    模式 => 表达式,​​}

◆ if let条件表达式

◆ fn main() {￼    let favorite_color: Option<&str> = None;￼    let is_tuesday = false;￼    let age: Result<u8, _> = "34".parse();￼￼ ❶ if let Some(color) = favorite_color {￼     ❷ println!("Using your favorite color, {}, as the background", color);￼ ❸ } else if is_tuesday {￼     ❹ println!("Tuesday is green day!");￼ ❺ } else if let Ok(age) = age {￼     ❻ if age > 30 {￼         ❼ println!("Using purple as the background color");￼        } else {￼         ❽ println!("Using orange as the background color");￼        }￼ ❾ } else {￼     ❿ println!("Using blue as the background color");￼    }￼}
示例18-1：混合使用if let、else if、else if let和else

◆ 与match表达式不同，if let表达式的不利之处在于它不会强制开发者穷尽值的所有可能性。即便我们省略了随后可选的else块❾，并因此遗漏了某些需要处理的情形，编译器也不会在这里警告我们存在可能的逻辑性缺陷。


◆ while let条件循环

◆ et mut stack = Vec::new();￼￼stack.push(1);￼stack.push(2);￼stack.push(3);￼￼while let Some(top) = stack.pop() {￼    println!("{}", top);￼}

◆ for循环

◆ let v = vec!['a', 'b', 'c'];￼￼for (index, value) in v.iter().enumerate() {￼    println!("{} is at index {}", value, index);￼}

◆ let语句

◆ 函数的参数
函数的参数同样也是模式。

◆ 模式在不同上下文中的运作机制却不尽相同。在某些场合下，模式必须是不可失败的形式；而在另外一些场合下，模式却被允许是可失败的形式。


第一百一十四章 可失败性：模式是否会匹配失败

◆ 可失败性：模式是否会匹配失败

◆ 模式可以被分为不可失败（irrefutable）和可失败（refutable）两种类型。不可失败的模式能够匹配任何传入的值。例如，语句let x = 5;中的x便是不可失败模式，因为它能够匹配表达式右侧所有可能的返回值。可失败模式则可能因为某些特定的值而匹配失败。例如，表达式if let Some(x) = a_value中的Some(x)便是可失败模式。如果a_value变量的值是None而不是Some，那么表达式左侧的Some(x)模式就会发生不匹配的情况。
函数参数、let语句及for循环只接收不可失败模式，因为在这些场合下，我们的程序无法在值不匹配时执行任何有意义的行为。if let和while let表达式则只接收可失败模式，因为它们在被设计时就将匹配失败的情形考虑在内了：条件表达式的功能就是根据条件的成功与否执行不同的操作。
一般而言，我们不用在编写代码时过多地考虑模式的可失败性，但你还是需要熟悉可失败性这个概念本身，因为你需要能够识别出错误提示信息中有关它的描述，进而做出正确的应对。在遇到此类问题时，要么改变用于匹配的模式，要么改变被模式匹配的值的构造，这取决于代码期望实现的行为。


◆ 使用if let来代替涉及模式的那一部分let代码。新的代码能够在我们遇到模式不匹配时跳过花括号中的代码块，并给予程序一个合法的方式继续执行

◆ if let Some(x) = some_option_value {￼    println!("{}", x);￼}


第一百一十五章 模式语法

◆ 模式语法

◆ 匹配字面量

◆ let x = 1;￼￼match x {￼    1 => println!("one"),￼    2 => println!("two"),￼    3 => println!("three"),￼    _ => println!("anything"),￼}

◆ 匹配命名变量

◆ n main() {￼ ❶ let x = Some(5);￼ ❷ let y = 10;￼￼    match x {￼     ❸ Some(50) => println!("Got 50"),￼     ❹ Some(y) => println!("Matched, y = {:?}", y),￼     ❺ _ => println!("Default case, x = {:?}", x),￼    }￼￼ ❻ println!("at the end: x = {:?}, y = {:?}", x, y);￼}

◆ 示例18-11：match表达式的一个分支引入了一个覆盖变量y
让我们来逐步分析一下执行这段match表达式时究竟会发生些什么。由于第一个匹配分支❸的模式与x中的值❶不匹配，所以我们简单地跳过该分支即可。
第二个匹配分支❹的模式引入了新的变量y，它会匹配Some变体中携带的任意值。因为我们处在match表达式创建的新作用域中，所以这里的y是一个新的变量，而不是我们在程序起始处声明的那个存储了10的y❷。这个新的y的绑定能够匹配Some中的任意值，而x正是一个Some。因此，新的y会被绑定到x变量中Some内部的值。由于这个值是5，所以当前分支的表达式会在执行后打印出Matched, y = 5。
如果x不是Some(5)而是None，那么它会在前两个分支的模式匹配中匹配失败，进而与最后的那个下画线模式❺相匹配。由于我们没有在下画线模式的分支内引入x变量，所以这个表达式使用的x没有被任何变量所覆盖，它依然是外部作用域中的x。这个假想的match运行过程最终会打印出Default case, x = None。
match表达式创建出来的作用域会随着当前表达式的结束而结束，而它内部的y自然也无法幸免，代码最后的println! ❻会打印出at the end: x = Some(5), y = 10。
如果你希望在match表达式中比较外部的x与y，而不是引入新的覆盖变量，那么我们就需要使用带有条件的匹配守卫。本章随后的“使用匹配守卫添加额外条件”一节会详细介绍这一概念。


◆ 多重模式

◆ 你可以在match表达式的分支匹配中使用|来表示或（or）的意思，它可以被用来一次性地匹配多个模式。

◆ let x = 1;￼￼match x {￼    1 | 2 => println!("one or two"),￼    3 => println!("three"),￼    _ => println!("anything"),￼}
这段代码会打印出one or two。

◆ 使用...来匹配值区间

◆ let x = 5;￼￼match x {￼    1 ... 5 => println!("one through five"),￼    _ => println!("something else"),￼}

◆ 范围模式只被允许使用数值或char值来进行定义，因为编译器需要在编译时确保范围的区间不为空，而char和数值正是Rust仅有的可以判断区间是否为空的类型。

◆ let x = 'c';￼￼match x {￼    'a' ..= 'j' => println!("early ASCII letter"),￼    'k' ..= 'z' => println!("late ASCII letter"),￼    _ => println!("something else"),￼}
由于Rust判断出c位于第一个模式的区间内，所以它最终会打印出early ASCII letter。

◆ 使用解构来分解值
我们可以使用模式来分解结构体、枚举、元组或引用，从而使用这些值中的不同部分。

◆ struct Point {￼    x: i32,￼    y: i32,￼}￼￼fn main() {￼    let p = Point { x: 0, y: 7 };￼￼    let Point { x: a, y: b } = p;￼    assert_eq!(0, a);￼    assert_eq!(7, b);￼}

◆ 采用与字段名相同的变量名在实践中相当常见，为了避免写出类似于let Point { x: x, y: y } = p这样冗余的代码，Rust允许我们在使用模式匹配分解结构体字段时采用一种较为简便的写法：你只需要列出结构体字段中的名称，模式就会自动创建出拥有相同名称的变量

◆ struct Point {￼    x: i32,￼    y: i32,￼}￼￼fn main() {￼    let p = Point { x: 0, y: 7 };￼￼    let Point { x, y } = p;￼    assert_eq!(0, x);￼    assert_eq!(7, y);￼}

◆ 除了为所有字段创建变量，我们还可以在结构体模式中使用字面量来进行解构。这一技术使我们可以在某些字段符合要求的前提下再对其他字段进行解构。
示例18-14中展示的match表达式将Point值分为了3种不同的情况：位于x轴上的点（即y = 0）、位于y轴上的点（即x = 0），以及不在任意一个轴上的点。
src/main.rs
fn main() {￼    let p = Point { x: 0, y: 7 };￼￼    match p {￼        Point { x, y: 0 } => println!("On the x axis at {}", x),￼        Point { x: 0, y } => println!("On the y axis at {}", y),￼        Point { x, y } => println!("On neither axis: ({}, {})", x, y),￼    }￼}
示例18-14：对模式中的字面量进行解构和匹配

◆ 解构枚举
我们在本书前面的部分中已经完成过解构枚举的操作了，例如第6章中的示例6-5就曾经解构了Option<i32>。但仍有一个未被提及的细节需要注意：用于解构枚举的模式必须要对应枚举定义中存储数据的方式。

◆ enum Message {￼    Quit,￼    Move { x: i32, y: i32 },￼    Write(String),￼    ChangeColor(i32, i32, i32),￼}￼￼fn main() {￼ ❶ let msg = Message::ChangeColor(0, 160, 255);￼￼    match msg {￼     ❷ Message::Quit => {￼            println!("The Quit variant has no data to destructure.")￼        },￼     ❸ Message::Move { x, y } => {￼            println!(￼                "Move in the x direction {} and in the y direction {}",￼                x,￼                y￼            );￼        }￼     ❹ Message::Write(text) => println!("Text message: {}", text),￼     ❺ Message::ChangeColor(r, g, b) => {￼            println!(￼                "Change the color to red {}, green {}, and blue {}",￼                r,￼                g,￼                b￼            )￼        }￼    }￼}
示例18-15：解构含有不同种类值的枚举变体

◆ 解构嵌套的结构体和枚举
到目前为止，我们所有的示例都只匹配了单层的结构体或枚举，但匹配语法还可以被用于嵌套的结构中！


◆ enum Message {￼    Quit,￼    Move { x: i32, y: i32 },￼    Write(String),￼    ChangeColor(Color),￼}￼￼fn main() {￼    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));￼￼    match msg {￼        Message::ChangeColor(Color::Rgb(r, g, b)) => {￼            println!("Change the color to red {}, green {}, and blue {}", r, g, b)     ￼        },￼        Message::ChangeColor(Color::Hsv(h, s, v)) => {￼            println!("Change the color to hue {}, saturation {}, and value {}", h, s, v)￼        }￼        _ => ()￼    }￼}
示例18-16：匹配嵌套的枚举


◆ 解构结构体和元组
我们甚至可以按照某种更为复杂的方式来将模式混合、匹配或嵌套在一起。

◆ let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
这段代码能够将复杂的类型值分解为不同的组成部分，以便使我们可以分别使用自己感兴趣的值。

◆ 基于模式的解构使我们可以较为方便地将值分解为不同部分，比如结构体中不同的字段，并相对独立地使用它们。


◆ 忽略模式中的值
在某些场景下忽略模式中的值是有意义的，例如在match表达式的最后一个分支中，代码可以匹配剩余所有可能的值而又不需要执行什么操作。有几种不同的方法可以让我们在模式中忽略全部或部分值：使用_模式、在另一个模式中使用_模式、使用以下画线开头的名称，或者使用..来忽略值的剩余部分。

◆ 使用_忽略整个值

◆ 虽然_模式最常被用在match表达式的最后一个分支中，但实际上我们可以把它用于包括函数参数在内的一切模式中，

◆ fn foo(_: i32, y: i32) {￼    println!("This code only uses the y parameter: {}", y);￼}￼￼fn main() {￼    foo(3, 4);￼}
示例18-17：在函数签名中使用_


◆ 使用嵌套的_忽略值的某些部分

◆ let mut setting_value = Some(5);￼let new_setting_value = Some(10);￼￼match (setting_value, new_setting_value) {￼    (Some(_), Some(_)) => {￼        println!("Can't overwrite an existing customized value");￼    }￼    _ => {￼        setting_value = new_setting_value;￼    }￼}￼￼println!("setting is {:?}", setting_value);
示例18-18：当我们不需要使用Some中的值时，在模式中使用下画线来匹配Some变体

◆ 通过以_开头的名称来忽略未使用的变量
Rust会在你创建出一个变量却又没有使用过它时给出相应的警告，因为这有可能是程序中的bug。但在某些场景下，创建一个暂时不会用到的变量仍然是合理的，比如进行原型开发时或开始一个新的项目时。为了避免Rust在这些场景中因为某些未使用的变量而抛出警告，我们可以在这些变量的名称前添加下画线。

◆ fn main() {￼    let _x = 5;￼    let y = 10;￼}

◆ 示例18-20：以下画线开始的变量名可以避免触发变量未使用警告


◆ 值得注意的是，使用以下画线开头的变量名与仅仅使用_作为变量名存在一个细微的差别：_x语法仍然将值绑定到了变量上，而_则完全不会进行绑定。

◆ 使用..忽略值的剩余部分
对于拥有多个部分的值，我们可以使用..语法来使用其中的某一部分并忽略剩余的那些部分。这使我们不必为每一个需要忽略的值都添加对应的_模式来进行占位。..模式可以忽略一个值中没有被我们显式匹配的那些部分。

◆ struct Point {￼    x: i32,￼    y: i32,￼    z: i32,￼}￼￼let origin = Point { x: 0, y: 0, z: 0 };￼￼match origin {￼    Point { x, .. } => println!("x is {}", x),￼}
示例18-23：使用..忽略Point中除x之外的所有字段

◆ fn main() {￼    let numbers = (2, 4, 8, 16, 32);￼￼    match numbers {￼        (first, .., last) => {￼            println!("Some numbers: {}, {}", first, last);￼        },￼    }￼}
示例18-24：只匹配元组中的第一个值和最后一个值，而忽略其他值


◆ 使用匹配守卫添加额外条件
匹配守卫（match guard）是附加在match分支模式后的if条件语句，分支中的模式只有在该条件被同时满足时才能匹配成功。相比于单独使用模式，匹配守卫可以表达出更为复杂的意图。


◆ 匹配守卫的条件可以使用模式中创建的变量。示例18-26中的match表达式在使用模式Some(x)的同时附带了额外的匹配守卫if x < 5。
let num = Some(4);￼￼match num {￼    Some(x) if x < 5 => println!("less than five: {}", x),￼    Some(x) => println!("{}", x),￼    None => (),￼}

◆ 我们无法通过模式表达出类似于if x < 5这样的条件，匹配守卫增强了语句中表达相关逻辑的能力。

◆ 在示例18-11中，我们曾经提到匹配守卫可以用来解决模式中变量覆盖的问题。回忆一下当时的场景，那个match表达式在模式中创建了一个新的变量，而没有使用表达式外部的变量。这个新变量使我们无法在模式中使用外部变量的值来进行比较。示例18-27使用匹配守卫修复了这一问题。
src/main.rs
fn main() {￼    let x = Some(5);￼    let y = 10;￼￼    match x {￼        Some(50) => println!("Got 50"),￼        Some(n) if n == y => println!("Matched, n = {:?}", n),￼        _ => println!("Default case, x = {:?}", x),￼    }￼￼    println!("at the end: x = {:?}, y = {:?}", x, y);￼}
示例18-27：使用匹配守卫来测试Some变体内的值是否与外部变量相等

◆ 修改后的代码会打印出Default case, x = Some(5)。由于第二个分支的模式中没有引入新的变量y，所以随后的匹配守卫可以正常地在条件判断中使用外部变量y。这个分支使用了Some(n)而不是Some(y)来避免覆盖y变量。这里新创建出来的n变量不会覆盖外部的任何东西，因为match外部没有与n同名的变量。
匹配守卫if n == y不是一个模式，所以它不会引入新的变量。因为这个条件中的y就是来自表达式外部的y，而不是之前示例中覆盖后的y，所以我们才能够比较n和y的值是否相同。


◆ 我们同样可以在匹配守卫中使用或运算符|来指定多重模式。示例18-28演示了如何将匹配守卫及带有|的模式组合使用。另外，你还能从这个示例中观察到它们作用的优先级：if y匹配守卫同时作用于4、5及6这3个值，尽管你可能会误以为if y仅仅对6有效。
let x = 4;￼let y = false;￼￼match x {￼    4 | 5 | 6 if y => println!("yes"),￼    _ => println!("no"),￼}
示例18-28：将匹配守卫与多重模式组合使用
第一个分支中的匹配条件要求x的值等于4、5或6，并且要求y为true。当你运行这段代码时，虽然x存储的4满足第一个分支中的模式要求，但却无法满足匹配守卫的条件if y，所以第一个分支的匹配失败。接着，代码会在第二个分支处匹配成功，并打印出no。之所以会出现这样的结果，是因为if条件对于整个模式4 | 5 | 6都是有效的，而不仅仅只针对最后的那个值6。换句话说，匹配守卫与模式之间的优先级关系是：
(4 | 5 | 6) if y => ...
而不是：
4 | 5 | (6 if y) => ...
运行示例代码便能够观察到它们之间的优先级关系：假如匹配守卫只对|分隔的最后一个值有效，那么第一个分支就应当匹配成功并打印出yes。


◆ @绑定

◆ @运算符允许我们在测试一个值是否匹配模式的同时创建存储该值的变量

◆ 示例18-29中测试Message::Hello的id字段是否在区间3...7中。另外，我们还想要将这个字段中的值绑定到变量id_variable上，以便我们在随后的分支代码块中使用它。这个绑定变量可以被命名为id，与字段同名，但本例出于演示目的使用了一个不同的名称。
enum Message {￼    Hello { id: i32 },￼}￼￼let msg = Message::Hello { id: 5 };￼￼match msg {￼    Message::Hello { id: id_variable @ 3..=7 } => {￼        println!("Found an id in range: {}", id_variable)￼    },￼    Message::Hello { id: 10..=12 } => {￼        println!("Found an id in another range")￼    },￼    Message::Hello { id } => {￼        println!("Found some other id: {}", id)￼    },￼}


第一百一十七章 第19章 高级特性

◆ 第19章高级特性


◆ 本章将涉及以下内容：
• 不安全Rust：舍弃Rust的某些安全保障并负责手动维护相关规则。
• 高级trait：关联类型、默认类型参数、完全限定语法（fully qualified syntax）、超trait（supertrait），以及与trait相关的newtype模式。
• 高级类型：更多关于newtype模式的内容、类型别名、never类型和动态大小类型。
• 高级函数和闭包：函数指针与返回闭包。
• 宏：在编译期生成更多代码的方法。


第一百一十八章 不安全Rust

◆ 不安全Rust之所以存在是因为静态分析从本质上讲是保守的。当编译器在判断一段代码是否拥有某种安全保障时，它总是宁可错杀一些合法的程序也不会接受可能非法的代码。尽管某些代码也许是安全的，但目前的Rust编译器却可能会做出相反的结论！在这种情况下，你可以使用不安全代码来告知编译器：“相信我，我知道自己在干些什么。”这样做的缺点在于你需要为自己的行为负责：如果你错误地使用了不安全代码，那么就可能会引发不安全的内存问题，比如空指针解引用等。
另外一个需要不安全Rust的原因在于底层计算机硬件固有的不安全性。如果Rust不允许进行不安全的操作，那么某些底层任务可能根本就完成不了。Rust作为一门系统语言需要能够进行底层编程，它应当允许你直接与操作系统打交道甚至是编写你自己的操作系统，这正是Rust语言的目标之一。

◆ 你可以在代码块前使用关键字unsafe来切换到不安全模式，并在被标记后的代码块中使用不安全代码。不安全Rust允许你执行4种在安全Rust中不被允许的操作，而它们也就是所谓的不安全超能力（unsafe superpower）。这些能力包括：
• 解引用裸指针。
• 调用不安全的函数或方法。
• 访问或修改可变的静态变量。
• 实现不安全trait。
需要注意的是，unsafe关键字并不会关闭借用检查器或禁用任何其他Rust安全检查：如果你在不安全代码中使用引用，那么该引用依然会被检查。unsafe关键字仅仅让你可以访问这4种不会被编译器进行内存安全检查的特性。因此，即便是身处于不安全的代码块中，你也仍然可以获得一定程度的安全性。

◆ 为了尽可能地隔离不安全代码，你可以将不安全代码封装在一个安全的抽象中并提供一套安全的API

◆ 解引用裸指针
我们在第4章的“悬垂引用”一节中曾经提到过编译器会对引用的有效性做出保障。不安全Rust的世界里拥有两种类似于引用的新指针类型，它们都被叫作裸指针（raw pointer）。与引用类似，裸指针要么是可变的，要么是不可变的，它们分别被写作*const T和*mut T。这里的星号是类型名的一部分而不是解引用操作。在裸指针的上下文中，不可变意味着我们不能直接对解引用后的指针赋值。
裸指针与引用、智能指针的区别在于：
• 允许忽略借用规则，可以同时拥有指向同一个内存地址的可变和不可变指针，或者拥有指向同一个地址的多个可变指针。
• 不能保证自己总是指向了有效的内存地址。
• 允许为空。
• 没有实现任何自动清理机制。
在避免Rust强制执行某些保障后，你就能够以放弃安全保障为代价来换取更好的性能，或者换取与其他语言、硬件进行交互的能力（Rust的保障在这些领域本来就不起作用）。
示例19-1演示了如何从一个引用中同时创建出不可变的和可变的裸指针。
let mut num = 5;￼￼let r1 = &num as *const i32;￼let r2 = &mut num as *mut i32;
示例19-1：通过引用创建裸指针
注意，我们没有在这段代码中使用unsafe关键字。你可以在安全代码内合法地创建裸指针，但不能在不安全代码块外解引用裸指针

◆ 在创建裸指针的过程中，我们使用了as来分别将不可变引用和可变引用强制转换为了对应的裸指针类型。由于这两个裸指针来自有效的引用，所以我们能够确认它们的有效性。但要记住，这一假设并不是对任意一个裸指针都成立。
接下来，我们会创建一个无法确定其有效性的裸指针。示例19-2创建了一个指向内存中任意地址的裸指针。尝试使用任意内存地址的行为是未定义的：这个地址可能有数据，也可能没有数据，编译器可能会通过优化代码来去掉该次内存访问操作，否则程序可能会在运行时出现段错误（segmentation fault）。我们一般不会编写出如示例19-2所示的代码，但它确实是合法的语句。
let address = 0x012345usize;￼let r = address as *const i32;
示例19-2：创建一个指向任意内存地址的裸指针
刚刚提到，我们可以在安全代码中创建裸指针，但却不能通过解引用裸指针来读取其指向的数据。为了使用*解引用裸指针，我们需要添加一个unsafe块，如示例19-3所示。
let mut num = 5;￼￼let r1 = &num as *const i32;￼let r2 = &mut num as *mut i32;￼￼unsafe {￼    println!("r1 is: {}", *r1);￼    println!("r2 is: {}", *r2);￼}
示例19-3：在unsafe块中解引用裸指针
创建一个指针并不会产生任何危害，只有当我们试图访问它指向的值时才可能因为无效的值而导致程序异常。
值得注意的是：我们在示例19-1和示例19-3中同时创建出了指向同一个内存地址num的*const i32和*mut i32裸指针。如果我们尝试同时创建一个指向num的可变引用和不可变引用，那么就会因为Rust的所有权规则而导致编译失败。但在使用裸指针时，我们却可以创建同时指向同一地址的可变指针和不可变指针，并能够通过可变指针来修改数据。这一修改操作会导致潜在的数据竞争，请在使用时多加小心！


◆ 既然存在这些危险，那么为什么我们还需要使用裸指针呢？它的一个主要用途便是与C代码接口进行交互，我们会在下一节“调用不安全函数或方法”中看到。另外，它还可以被用来构造一些借用检查器无法理解的安全抽象

◆ 调用不安全函数或方法
第二种需要使用不安全代码块的操作便是调用不安全函数（unsafe function）。除了在定义前面要标记unsafe，不安全函数或方法看上去与正常的函数或方法几乎一模一样。此处的unsafe关键字意味着我们需要在调用该函数时手动满足并维护一些先决条件，因为Rust无法对这些条件进行验证。通过在unsafe代码块中调用不安全函数，我们向Rust表明自己确实理解并实现了相关的约定。
下面的示例中有一个不执行任何操作的dangerous函数：
unsafe fn dangerous() {}￼￼unsafe {￼    dangerous();￼}

◆ 函数中包含不安全代码并不意味着我们需要将整个函数都标记为不安全的。实际上，将不安全代码封装在安全函数中是一种十分常见的抽象。下面，让我们通过示例来观察标准库中使用了不安全代码的split_at_mut函数，并思考应该如何实现它。这个安全方法被定义在可变切片上：它接收一个切片并从给定的索引参数处将其分割为两个切片。示例19-4展示了split_at_mut的相关使用方法。
let mut v = vec![1, 2, 3, 4, 5, 6];￼￼let r = &mut v[..];￼￼let (a, b) = r.split_at_mut(3);￼￼assert_eq!(a, &mut [1, 2, 3]);￼assert_eq!(b, &mut [4, 5, 6]);
示例19-4：使用安全的split_at_mut函数
我们无法仅仅使用安全Rust来实现这个函数。示例19-5中展示了一个可能的尝试，但它却无法通过编译。为了简单起见，我们将split_at_mut实现为函数而不是方法，并只处理特定类型i32的切片而非泛型T的切片。
fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {￼    let len = slice.len();￼￼    assert!(mid <= len);￼￼    (&mut slice[..mid],￼     &mut slice[mid..])￼}
示例19-5：尝试仅仅使用安全Rust来实现split_at_mut
这个函数会首先取得整个切片的长度，并通过断言检查给定的参数是否小于或等于当前切片的长度。如果给定的参数大于切片的长度，那么函数就会在尝试使用该索引前触发panic。
接着，我们会返回一个包含两个可变切片的元组：一个从原切片的起始位置到mid索引的位置，另一个则从mid索引的位置到原切面的末尾。
尝试编译示例19-5中的代码会出现如下所示的错误：
error[E0499]: cannot borrow `*slice` as mutable more than once at a time￼ -->￼  |￼6 |     (&mut slice[..mid],￼  |           ----- first mutable borrow occurs here￼7 |      &mut slice[mid..])￼  |           ^^^^^ second mutable borrow occurs here￼8 | }￼  | - first borrow ends here
Rust的借用检查器无法理解我们正在借用一个切片的不同部分，它只知道我们借用了两次同一个切片。借用一个切片的不同部分从原理上来讲应该是没有任何问题的，因为两个切片并没有交叉的地方，但Rust并没有足够智能到理解这些信息。当我们能够确定某段代码的正确性而Rust却不能时，不安全代码就可以登场了。
示例19-6展示了如何使用unsafe代码块、裸指针及一些不安全函数来实现split_at_mut。
use std::slice;￼￼fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {￼ ❶ let len = slice.len();￼ ❷ let ptr = slice.as_mut_ptr();￼￼ ❸ assert!(mid <= len);￼￼ ❹ unsafe {￼     ❺ (slice::from_raw_parts_mut(ptr, mid),￼      ❻ slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))￼    }￼}
示例19-6：在实现split_at_mut函数时使用不安全代码

◆ 使用extern函数调用外部代码
在某些场景下，你的Rust代码可能需要与另外一种语言编写的代码进行交互。Rust为此提供了extern关键字来简化创建和使用外部函数接口（Foreign Function Interface，FFI）的过程。FFI是编程语言定义函数的一种方式，它允许其他（外部的）编程语言来调用这些函数。

◆ 示例19-8集成了C标准库中的abs函数。任何在extern块中声明的函数都是不安全的。因为其他语言并不会强制执行Rust遵守的规则，而Rust又无法对它们进行检查，所以在调用外部函数的过程中，保证安全的责任也同样落在了开发者的肩上。
src/main.rs
extern "C" {￼    fn abs(input: i32) -> i32;￼}￼￼fn main() {￼    unsafe {￼        println!("Absolute value of -3 according to C: {}", abs(-3));￼    }￼}
示例19-8：声明并调用在另外一种语言中定义的extern函数
这段代码在extern "C"块中列出了我们想要调用的外部函数名称及签名，其中的"C"指明了外部函数使用的应用二进制接口（Application Binary Interface，ABI）：它被用来定义函数在汇编层面的调用方式。我们使用的"C"ABI正是C编程语言的ABI，它也是最常见的ABI格式之一。
在其他语言中调用Rust函数
我们同样可以使用extern来创建一个允许其他语言调用Rust函数的接口。但不同于使用extern标注的代码块，我们需要将extern关键字及对应的ABI添加到函数签名的fn关键字前，并为该函数添加#[no_mangle]注解来避免Rust在编译时改变它的名称。Mangling是一个特殊的编译阶段，在这个阶段，编译器会修改函数名称来包含更多可用于后续编译步骤的信息，但通常也会使得函数名称难以阅读。几乎所有程序语言的编译器都会以稍微不同的方式来改变函数名称，为了让其他语言正常地识别Rust函数，我们必须要禁用Rust编译器的改名功能。
在下面的示例中，我们编写了一个可以在编译并链接后被C语言代码访问的call_from_c函数：
#[no_mangle]￼pub extern "C" fn call_from_c() {￼    println!("Just called a Rust function from C!");￼}
这一类型的extern功能不需要使用unsafe。

◆ 在Rust中，全局变量也被称为静态（static）变量。

◆ src/main.rs
static HELLO_WORLD: &str = "Hello, world!";￼￼fn main() {￼    println!("name is: {}", HELLO_WORLD);￼}
示例19-9：定义并使用一个不可变静态变量

◆ 静态变量类似于第3章的“变量与常量之间的不同”一节中讨论过的常量。静态变量的名称会约定俗成地被写作SCREAMING_SNAKE_CASE的形式，并且必须要标注变量的类型（也就是本例中的&'static str）。静态变量只能存储拥有'static生命周期的引用，这意味着Rust编译器可以自己计算出它的生命周期而无须手动标注。访问一个不可变静态变量是安全的。
常量和不可变静态变量看起来可能非常相似，但它们之间存在一个非常微妙的区别：静态变量的值在内存中拥有固定的地址，使用它的值总是会访问到同样的数据。与之相反的是，常量则允许在任何被使用到的时候复制其数据。
常量和静态变量之间的另外一个区别在于静态变量是可变的。需要注意的是，访问和修改可变的静态变量是不安全的。示例19-10展示了如何声明、访问与修改一个名为COUNTER的可变静态变量。
src/main.rs
static mut COUNTER: u32 = 0;￼￼fn add_to_count(inc: u32) {￼    unsafe {￼        COUNTER += inc;￼    }￼}￼￼fn main() {￼    add_to_count(3);￼￼    unsafe {￼        println!("COUNTER: {}", COUNTER);￼    }￼}
示例19-10：从一个可变静态变量中读或写都是不安全的
和正常变量一样，我们使用mut关键字来指定静态变量的可变性。任何读写COUNTER的代码都必须位于unsafe代码块中。上述代码可以顺利地通过编译并如期打印出COUNTER: 3，因为它是单线程的。当有多个线程同时访问COUNTER时，则可能会出现数据竞争。

◆ 实现不安全trait
最后一个只能在unsafe中执行的操作是实现某个不安全trait。当某个trait中存在至少一个方法拥有编译器无法校验的不安全因素时，我们就称这个trait是不安全的。你可以在trait定义的前面加上unsafe关键字来声明一个不安全trait，同时该trait也只能在unsafe代码块中实现，如示例19-11所示。
unsafe trait Foo {￼    // 某些方法​​}￼￼unsafe impl Foo for i32 {￼    // 对应的方法实现​​}

◆ 通过使用unsafe impl，我们向Rust保证我们会手动维护好那些编译器无法验证的不安全因素。
回忆一下我们在第16章的“使用Sync trait和Send trait对并发进行扩展”一节中讨论过的Sync与Send标签trait：当我们的类型完全由实现了Send与Sync的类型组成时，编译器会自动为它实现Send与Sync。假如我们的类型包含了某个没有实现Send或Sync的字段（比如裸指针等），而又希望把这个类型标记为Send或Sync，那么我们就必须使用unsafe。Rust无法验证我们的类型是否能够安全地跨线程传递，或安全地从多个线程中访问。因此，我们需要手动执行这些审查并使用unsafe关键字来实现这些trait。


第一百一十九章 高级trait

◆ 在trait的定义中使用关联类型指定占位类型
关联类型（associated type）是trait中的类型占位符，它可以被用于trait的方法签名中。trait的实现者需要根据特定的场景来为关联类型指定具体的类型。通过这一技术，我们可以定义出包含某些类型的trait，而无须在实现前确定它们的具体类型是什么。
我们在本章讨论的大部分高级主题都较少被用到，但关联类型却处于某种中间状态：虽然它比本书中介绍的其他特性用得更少一些，但却比本章中出现的诸多高级特性更为常用。
标准库中的Iterator就是一个带有关联类型的trait示例，它拥有一个名为Item的关联类型，并使用该类型来替代迭代中出现的值类型。我们在第13章的“Iterator trait和next方法”一节中曾经提到过，Iterator trait的定义如示例19-12所示。
pub trait Iterator {￼    type Item;￼￼    fn next(&mut self) -> Option<Self::Item>;￼}
示例19-12：含有关联类型Item的Iterator trait的定义
这里的类型Item是一个占位类型，而next方法的定义则表明它会返回类型为Option<Self::Item>的值。Iterator trait的实现者需要为Item指定具体的类型，并在实现的next方法中返回一个包含该类型值的Option。
关联类型看起来与泛型的概念有些类似，后者允许我们在不指定具体类型的前提下定义函数。那么我们为什么需要使用关联类型呢？
让我们通过一个在第13章出现过的例子来观察它们两者之间的区别，这个例子在Counter结构体上实现了Iterator trait。在示例13-21中，我们将Item类型指定为了u32：
src/lib.rs
impl Iterator for Counter {￼    type Item = u32;￼￼    fn next(&mut self) -> Option<Self::Item> {￼        // --略--
这里的语法似乎和泛型语法差不多，那么我们为什么不直接使用泛型来定义Iterator trait呢？如示例19-13所示。
pub trait Iterator<T> {￼    fn next(&mut self) -> Option<T>;￼}
示例19-13：一个使用泛型的假想Iterator trait定义
其中的区别在于，如果我们使用了示例19-13中的泛型版本，那么就需要在每次实现该trait的过程中标注类型；因为我们既可以实现Iterator<String> for Counter，也可以实现其他任意的迭代类型，从而使得Counter可以拥有多个不同版本的Iterator实现。换句话说，当trait拥有泛型参数时，我们可以为一个类型同时多次实现trait，并在每次实现中改变具体的泛型参数。那么当我们在Counter上使用next方法时，也必须提供类型标注来指明想要使用的Iterator实现。
借助关联类型，我们不需要在使用该trait的方法时标注类型，因为我们不能为单个类型多次实现这样的trait。对于示例19-12中使用了关联类型的trait定义，由于我们只能实现一次impl Iterator for Counter，所以Counter就只能拥有一个特定的Item类型。我们不需要在每次调用Counter的next方法时来显式地声明这是一个u32类型的迭代器。

◆ 默认泛型参数和运算符重载
我们可以在使用泛型参数时为泛型指定一个默认的具体类型。当使用默认类型就能工作时，该trait的实现者可以不用再指定另外的具体类型。你可以在定义泛型时通过语法<PlaceholderType=ConcreteType>来为泛型指定默认类型。
这个技术常常被应用在运算符重载中。运算符重载（operator overloading）使我们可以在某些特定的情形下自定义运算符（比如+）的具体行为。
虽然Rust不允许你创建自己的运算符及重载任意的运算符，但你可以实现std::ops中列出的那些trait来重载一部分相应的运算符。例如，在示例19-14中，我们为Point结构体实现的Add trait重载了+运算符，它允许代码对两个Point实例执行加法操作。
src/main.rs
use std::ops::Add;￼￼#[derive(Debug, PartialEq)]￼struct Point {￼    x: i32,￼    y: i32,￼}￼￼impl Add for Point {￼    type Output = Point;￼￼    fn add(self, other: Point) -> Point {￼        Point {￼            x: self.x + other.x,￼            y: self.y + other.y,￼        }￼    }￼}￼￼fn main() {￼    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },￼               Point { x: 3, y: 3 });￼}
示例19-14：通过实现Add trait来重载Point实例的+运算符

◆ 这里的Add trait使用了默认泛型参数，它的定义如下所示：
trait Add<RHS=Self> {￼    type Output;￼￼    fn add(self, rhs: RHS) -> Self::Output;￼}
你应该对这段代码中的大部分语法都较为熟悉，它定义的trait中带有一个方法和一个关联类型。那段新的语法RHS=Self就是所谓的默认类型参数（default type parameter）。泛型参数RHS（也就是“right-handle side”的缩写）定义了add方法中rhs参数的类型。假如我们在实现Add trait的过程中没有为RHS指定一个具体的类型，那么RHS的类型就会默认为Self，也就是我们正在为其实现Add trait的那个类型。


◆ 用于消除歧义的完全限定语法：调用相同名称的方法
Rust既不会阻止两个trait拥有相同名称的方法，也不会阻止你为同一个类型实现这样的两个trait。你甚至可以在这个类型上直接实现与trait方法同名的方法。
当你调用这些同名方法时，你需要明确地告诉Rust你期望调用的具体对象

◆ trait Pilot {￼    fn fly(&self);￼}￼￼trait Wizard {￼    fn fly(&self);￼}￼￼struct Human;￼￼impl Pilot for Human {￼    fn fly(&self) {￼        println!("This is your captain speaking.");￼    }￼}￼￼impl Wizard for Human {￼    fn fly(&self) {￼        println!("Up!");￼    }￼}￼￼impl Human {￼    fn fly(&self) {￼        println!("*waving arms furiously*");￼    }￼}
示例19-16：定义了两个拥有同名方法fly的trait，并为本就拥有fly方法的Human类型实现了这两个trait
当我们在Human的实例上调用fly时，编译器会默认调用直接实现在类型上的方法，如示例19-17所示。
src/main.rs
fn main() {￼    let person = Human;￼    person.fly();￼}
示例19-17：在Human实例上调用fly
运行这段代码会打印出*waving arms furiously*，它表明Rust调用了直接实现在Human类型上的fly方法。
为了调用实现在Pilot trait或Wizard trait中的fly方法，我们需要使用更加显式的语法来指定具体的fly方法，如示例19-18所示。
src/main.rs
fn main() {￼    let person = Human;￼    Pilot::fly(&person);￼    Wizard::fly(&person);￼    person.fly();￼}
示例19-18：指定我们想要调用哪个trait的fly方法
在方法名的前面指定trait名称向Rust清晰地表明了我们想要调用哪个fly实现。另外，你也可以使用类似的Human::fly(&person)语句，它与示例19-18中使用的person.fly()在行为上等价，但会稍微冗长一些。


◆ 运行这段代码会打印出如下所示的内容：
This is your captain speaking.￼Up!￼*waving arms furiously*
当你拥有两种实现了同一trait的类型时，对于fly等需要接收self作为参数的方法，Rust可以自动地根据self的类型推导出具体的trait实现。
然而，因为trait中的关联函数没有self参数，所以当在同一作用域下有两个实现了此种trait的类型时，Rust无法推导出你究竟想要调用哪一个具体类型，除非使用完全限定语法（fully qualified syntax）。例如，示例19-19中的Animal trait拥有关联函数baby_name，而示例中定义的Dog结构体在拥有独立关联函数baby_name的同时实现了Animal trait。
src/main.rs
trait Animal {￼    fn baby_name() -> String;￼}￼￼struct Dog;￼￼impl Dog {￼    fn baby_name() -> String {￼        String::from("Spot")￼    }￼}￼￼impl Animal for Dog {￼    fn baby_name() -> String {￼        String::from("puppy")￼    }￼}￼￼fn main() {￼    println!("A baby dog is called a {}", Dog::baby_name());￼}
示例19-19：一个带关联函数的trait和一个带同名关联函数的类型，并且这个类型还实现了该trait
使用这段代码的动物收容所希望将所有的小狗都叫作Spot，他们在Dog的关联函数baby_name中实现了这一需求。另外，Dog类型还同时实现了用于描述动物的通用trait：Animal。Dog在实现该trait的baby_name函数时将小狗称为puppy。
随后的代码在main函数中使用语句Dog::baby_name来直接调用了Dog的关联函数，它会打印出如下所示的内容：
A baby dog is called a Spot
这与我们预期的结果有些出入，我们希望的是调用在Dog上实现的Animal trait的baby_name函数来打印出A baby dog is called a puppy。示例19-18中指定trait名称的技术无法解决这一需求，将main函数修改为示例19-20中的代码会导致编译时错误。
src/main.rs
fn main() {￼    println!("A baby dog is called a {}", Animal::baby_name());￼}
示例19-20：尝试调用Animal trait中的baby_name函数，但Rust并不知道应该使用哪一个实现
由于Animal::baby_name是一个没有self参数的关联函数而不是方法，所以Rust无法推断出我们想要调用哪一个Animal::baby_name的实现。尝试编译这段代码会出现如下所示的错误：
error[E0283]: type annotations required: cannot resolve `_: Animal`￼  --> src/main.rs:20:43￼   |￼20 |     println!("A baby dog is called a {}", Animal::baby_name());￼   |                                           ^^^^^^^^^^^^^^^^^￼   |￼   = note: required by `Animal::baby_name`
为了消除歧义并指示Rust使用Dog为Animal trait实现的baby_name函数，我们需要使用完全限定语法。它在本例中的具体使用方法如示例19-21所示。
src/main.rs
fn main() {￼    println!("A baby dog is called a {}", <Dog as Animal>::baby_name());￼}
示例19-21：使用完全限定语法来调用Dog为Animal trait实现的baby_name函数

◆ 这段代码在尖括号中提供的类型标注表明我们希望将Dog类型视作Animal，并调用Dog为Animal trait实现的baby_name函数。修改后的代码能够打印出我们期望的结果了：
A baby dog is called a puppy
一般来说，完全限定语法被定义为如下所示的形式：
<Type as Trait>::function(receiver_if_method, next_arg, ...);
对于关联函数而言，上面的形式会缺少receiver而只保留剩下的参数列表。你可以在任何调用函数或方法的地方使用完全限定语法，而Rust允许你忽略那些能够从其他上下文信息中推导出来的部分。只有当代码中存在多个同名实现，且Rust也无法区分出你期望调用哪个具体实现时，你才需要使用这种较为烦琐的显式语法。

◆ 用于在trait中附带另外一个trait功能的超trait
有时，你会需要在一个trait中使用另外一个trait的功能。在这种情况下，我们需要使当前trait的功能依赖于另外一个同时被实现的trait。这个被依赖的trait也就是当前trait的超trait（supertrait）。

◆ use std::fmt;￼￼trait OutlinePrint: fmt::Display {￼    fn outline_print(&self) {￼        let output = self.to_string();￼        let len = output.len();￼        println!("{}", "*".repeat(len + 4));￼        println!("*{}*", " ".repeat(len + 2));￼        println!("* {} *", output);￼        println!("*{}*", " ".repeat(len + 2));￼        println!("{}", "*".repeat(len + 4));￼    }￼}
示例19-22：实现使用了Display功能的OutlinePrint trait

◆ 由于这段定义注明了OutlinePrint依赖于Display trait，所以我们能够在随后的方法中使用to_string函数，任何实现了Display trait的类型都会自动拥有这一函数。如果你尝试去掉trait名后的冒号与Display trait并继续使用to_string，那么Rust就会因为无法在当前作用域中找到&Self的to_string方法而抛出错误。


◆ 使用newtype模式在外部类型上实现外部trait
我们曾经在第10章的“为类型实现trait”一节中提到过孤儿规则：只有当类型和对应trait中的任意一个定义在本地包内时，我们才能够为该类型实现这一trait。但实际上，你还可以使用newtype模式来巧妙地绕过这个限制，它会利用元组结构体创建出一个新的类型（我们曾经在第5章的“使用不需要对字段命名的元组结构体来创建不同的类型”一节中讨论过元组结构体）。这个元组结构体只有一个字段，是我们想要实现trait的类型的瘦封装（thin wrapper）。由于封装后的类型位于本地包内，所以我们可以为这个壳类型实现对应的trait。newtype是一个来自Haskell编程语言的术语。值得注意的是，使用这一模式不会导致任何额外的运行时开销，封装后的类型会在编译过程中被优化掉。
例如，孤儿规则会阻止我们直接为Vec<T>实现Display，因为Display trait与Vec<T>类型都被定义在外部包中。为了解决这一问题，我们可以首先创建一个持有Vec<T>实例的Wrapper结构体。接着，我们便可以为Wrapper实现Display并使用Vec<T>值了，如示例19-23所示。
src/main.rs
use std::fmt;￼￼struct Wrapper(Vec<String>);￼￼impl fmt::Display for Wrapper {￼    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {￼        write!(f, "[{}]", self.0.join(", "))￼    }￼}￼￼fn main() {￼    let w = Wrapper(vec![String::from("hello"),￼String::from("world")]);￼    println!("w = {}", w);￼}
示例19-23：创建一个包含Vec<String>的Wrapper类型，并为其实现Display
这段代码在实现Display的过程中使用了self.0来访问内部的Vec<T>，因为Wrapper是一个元组结构体，而Vec<T>是元组中序号为0的那个元素。接着，我们就可以使用Wrapper中的Display功能了。
这项技术仍然有它的不足之处。因为Wrapper是一个新的类型，所以它没有自己内部值的方法。为了让Wrapper的行为与Vec<T>完全一致，我们需要在Wrapper中实现所有Vec<T>的方法，并将这些方法委托给self.0。假如我们希望新类型具有内部类型的所有方法，那么我们也可以为Wrapper实现Deref trait（在第15章的“通过Deref trait将智能指针视作常规引用”一节曾经讨论过这一技术）来直接返回内部的类型。假如我们不希望Wrapper类型具有内部类型的所有方法，比如在需要限制Wrapper类型的行为时，我们就只能手动实现需要的那部分方法了。
现在，你知道newtype模式是如何与trait配合使用的了；但即便不涉及trait概念，它也是一个非常有用的模式。接下来，让我们把焦点转移到一些更为高级的类型系统交互方式上来。



第一百二十章 高级类型

◆ 使用newtype模式实现类型安全与抽象

◆ newtype模式在一些我们还没有介绍过的任务中同样有用，它可以被用来静态地保证各种值之间不会被混淆及表明值使用的单位。

◆ newtype模式的另外一个用途是为类型的某些细节提供抽象能力。例如，新类型可以暴露出一个与内部私有类型不同的公共API，从而限制用户可以访问的功能。
newtype模式还可以被用来隐藏内部实现。

◆ 除了newtype模式，Rust还提供了创建类型别名（type alias）的功能，它可以为现有的类型生成另外的名称。这一特性需要用到type关键字。例如，我们可以像下面一样创建i32的别名Kilometers：
type Kilometers = i32;

◆ 现在，别名Kilometers被视作了i32的同义词；不同于我们在示例19-15中创建的Millimeters与Meters类型，Kilometers并不是一个独立的新类型。Kilometers类型的值实际上等价于i32类型的值

◆ 当你使用这种方式时，你就无法享有newtype模式附带的类型检查的便利。
类型别名最主要的用途是减少代码字符重复。

◆ 例如，我们可能会拥有一个如下所示的较长的类型：
Box<dyn Fn() + Send + 'static>
在函数签名中插入或在代码中通篇标注这样的类型不但令人生厌，也非常容易出错。与示例19-24类似的代码充斥着整个项目会是一幅怎样的场景？
let f: Box<dyn Fn() + Send + 'static> = Box::new(|| println!("hi"));￼￼fn takes_long_type(f: Box<dyn Fn() + Send + 'static>) {￼    // --略--￼}￼￼fn returns_long_type() -> Box<dyn Fn() + Send + 'static> {￼    // --略--￼#     Box::new(|| ())￼}
示例19-24：在多个地方使用长类型
类型别名通过减少字符重复可以使得代码更加易于管理。在示例19-25中，我们引入了一个别名Thunk来替换所有冗长的类型标注。
type Thunk = Box<dyn Fn() + Send + 'static>;￼￼let f: Thunk = Box::new(|| println!("hi"));￼￼fn takes_long_type(f: Thunk) {￼    // --略--￼}￼￼fn returns_long_type() -> Thunk {￼    // --略--￼#     Box::new(|| ())￼}

◆ Result<T, E>类型常常使用类型别名来减少代码重复。考虑一下标准库中的std::io模块，该模块下的I/O操作常常会返回Result<T, E>来处理操作失败时的情形。另外，该代码库使用了一个std::io::Error结构体来表示所有可能的I/O错误，而大部分std::io模块下的函数都会将返回类型Result<T, E>中的E替换为std::io::Error，比如Write trait中的这些函数：
use std::io::Error;￼use std::fmt;￼￼pub trait Write {￼    fn write(&mut self, buf: &[u8]) -> Result<usize, Error>;￼    fn flush(&mut self) -> Result<(), Error>;￼￼    fn write_all(&mut self, buf: &[u8]) -> Result<(), Error>;￼    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<(), Error>;￼}
这里重复出现了许多Result<..., Error>。为此，std::io有了如下所示的类型别名：
type Result<T> = Result<T, std::io::Error>;
由于该声明被放置在std::io模块中，所以我们可以使用完全限定别名std::io::Result<T>来指向它，即指向将std::io::Error填入E的Result<T, E>。简化后的Write trait函数如下所示：
pub trait Write {￼    fn write(&mut self, buf: &[u8]) -> Result<usize>;￼    fn flush(&mut self) -> Result<()>;￼￼    fn write_all(&mut self, buf: &[u8]) -> Result<()>;￼    fn write_fmt(&mut self, fmt: Arguments) -> Result<()>;￼}
使用类型别名可以从两个方面帮助我们：它让编写代码更加轻松，并且为整个std::io提供了一致的接口。另外，由于它仅仅是别名，也就是另外一个Result<T, E>，所以我们可以在它的实例上调用Result<T, E>拥有的任何方法，甚至是？运算符。


◆ 永不返回的Never类型
Rust有一个名为!的特殊类型，它在类型系统中的术语为空类型（empty type），因为它没有任何的值。我们倾向于叫它never类型，因为它在从不返回的函数中充当返回值的类型。例如：
fn bar() -> ! {￼    // --略--￼}
这段代码可以读作“函数bar永远不会返回值”。不会返回值的函数也被称作发散函数（diverging function）。我们不可能创建出类型为!的值来让bar返回。
但是一个不能创建值的类型究竟有什么用处呢？回忆一下示例2-5中的代码，我们将其中的部分代码重现在示例19-26中。
let guess: u32 = match guess.trim().parse() {￼    Ok(num) => num,￼    Err(_) => continue,￼};
示例19-26：拥有一个以continue结尾的分支的match语句
当时，我们略过了这段代码中的某些细节。随后，我们在第6章的“控制流运算符match”一节中指出所有的match分支都必须返回相同的类型。因此，类似于如下所示的代码是无法工作的：
let guess = match guess.trim().parse() {￼    Ok(_) => 5,￼    Err(_) => "hello",￼}
上面代码中guess的类型既可以是整数，也可以是字符串，而Rust则明确要求guess只能是单一的类型。那么示例19-26中的continue究竟返回了什么呢？我们为何可以在一个分支中返回u32，而在另一个分支中以continue结束呢？
正如你可能会猜到的，continue的返回类型是!。当Rust计算guess的类型时，它会发现在可用于匹配的两个分支中，前者的返回类型为u32而后者的返回类型为!。因为!无法产生一个可供返回的值，所以Rust采用了u32作为guess的类型。
对于此类行为，还有另外一种更加正式的说法：类型!的表达式可以被强制转换为其他的任意类型。我们之所以能够使用continue来结束match分支，是因为continue永远不会返回值；相反地，它会将程序的控制流转移至上层循环。因此，这段代码在输入值为Err的情况下不会对guess进行赋值。
panic! 宏的实现同样使用了never类型。还记得我们在Option<T>值上调用unwrap函数吗？它会生成一个值或触发panic。下面便是这个函数的定义：
impl<T> Option<T> {￼    pub fn unwrap(self) -> T {￼        match self {￼            Some(val) => val,￼            None => panic!("called `Option::unwrap()` on a `None` value"),￼        }￼    }￼}
这段代码中发生的行为类似于示例19-26中match的行为：Rust注意到val拥有类型T，而panic! 则拥有返回类型!，所以整个match表达式的返回类型为T。这段代码之所以可以正常工作，是因为panic! 只会中断当前的程序而不会产生值。因为我们不会在None的情况下为unwrap返回一个值，所以这段代码是合法的。

◆ 动态大小类型和Sized trait
通常而言，Rust需要在编译时获取一些特定的信息来完成自己的工作，比如应该为一个特定类型的值分配多少空间等。但Rust的类型系统中又同时存在这样一处令人疑惑的角落：动态大小类型（Dynamically Sized Type，DST）的概念，它有时也被称作不确定大小类型（unsized type），这些类型使我们可以在编写代码时使用只有在运行时才能确定大小的值。

◆ 让我们来深入研究一个叫作str的动态大小类型，这个类型几乎贯穿了本书的所有章节。没错，我们会在这里讨论str本身而不是&str，str正好是一个动态大小类型。我们只有在运行时才能确定字符串的长度，这也意味着我们无法创建一个str类型的变量，或者使用str类型来作为函数的参数。如下所示的代码无法正常工作：
let s1: str = "Hello there!";￼let s2: str = "How's it going?";
Rust需要在编译时确定某个特定类型的值究竟会占据多少内存，而同一类型的所有值都必须使用等量的内存。假如Rust允许我们写出上面这样的代码，那么这两个str的值就必须要占据等量的空间。但它们确实具有不同的长度：s1需要12字节的存储空间，而s2则需要15字节。这也是我们无法创建出动态大小类型变量的原因。
那么我们应该怎么处理类似的需求呢？你应该已经非常熟悉本例中出现的情形了：我们会把s1与s2的类型从str修改为&str。

◆ 回忆一下第4章的“字符串切片”一节，我们当时指出，切片的数据结构中会存储数据的起始位置及切片的长度。
因此，尽管&T被视作存储了T所在内存地址的单个值，但&str实际上是由两个值组成的：str的地址与它的长度。这也使我们可以在编译时确定&str值的大小：其长度为usize长度的两倍。换句话说，无论&str指向了什么样的字符串，我们总是能够知道&str的大小。这就是Rust中使用动态大小类型的通用方式：它们会附带一些额外的元数据来存储动态信息的大小。我们在使用动态大小类型时总是会把它的值放在某种指针的后面。
我们可以将str与所有种类的指针组合起来，例如Box<str>或Rc<str>等。事实上，你在之前的章节就已经见到过类似的用法了，只不过当时使用了另外一种动态大小类型：trait。每一个trait都是一个可以通过其名称来进行引用的动态大小类型。在第17章的“使用trait对象来存储不同类型的值”一节中曾经提到过，为了将trait用作trait对象，我们必须将它放置在某种指针之后，比如&dyn Trait或Box<dyn Trait>（Rc<dyn Trait>也可以）之后。
为了处理动态大小类型，Rust还提供了一个特殊的Sized trait来确定一个类型的大小在编译时是否可知。编译时可计算出大小的类型会自动实现这一trait。另外，Rust还会为每一个泛型函数隐式地添加Sized约束。也就是说，下面定义的泛型函数：
fn generic<T>(t: T) {￼    // --略--￼}
实际上会被隐式地转换为：
fn generic<T: Sized>(t: T) {￼    // --略--￼}
在默认情况下，泛型函数只能被用于在编译时已经知道大小的类型。但是，你可以通过如下所示的特殊语法来解除这一限制：
fn generic<T: ?Sized>(t: &T) {￼    // --略--￼}
?Sized trait约束表达了与Sized相反的含义，我们可以将它读作“T可能是也可能不是Sized的”。这个语法只能被用在Sized上，而不能被用于其他trait。
另外还需要注意的是，我们将t参数的类型由T修改为了&T。因为类型可能不是Sized的，所以我们需要将它放置在某种指针的后面。在本例中，我们选择使用引用。


第一百二十一章 高级函数与闭包

◆ fn类型也就是所谓的函数指针（function pointer），将参数声明为函数指针时使用的语法与闭包类似，如示例19-27所示。
src/main.rs
fn add_one(x: i32) -> i32 {￼    x + 1￼}￼￼fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {￼    f(arg) + f(arg)￼}￼￼fn main() {￼    let answer = do_twice(add_one, 5);￼￼    println!("The answer is: {}", answer);￼}

◆ 由于函数指针实现了全部3种闭包trait（Fn、FnMut以及FnOnce），所以我们总是可以把函数指针用作参数传递给一个接收闭包的函数。也正是出于这一原因，我们倾向于使用搭配闭包trait的泛型来编写函数，这样的函数可以同时处理闭包与普通函数。

◆ et list_of_numbers = vec![1, 2, 3];￼let list_of_strings: Vec<String> = list_of_numbers￼    .iter()￼    .map(|i| i.to_string())￼    .collect();

◆ et list_of_numbers = vec![1, 2, 3];￼let list_of_strings: Vec<String> = list_of_numbers￼    .iter()￼    .map(ToString::to_string)￼    .collect();

◆ enum Status {￼    Value(u32),￼    Stop,￼}￼￼let list_of_statuses: Vec<Status> =￼    (0u32..20)￼    .map(Status::Value)￼    .collect();

◆ 返回闭包
由于闭包使用了trait来进行表达，所以你无法在函数中直接返回一个闭包。在大多数希望返回trait的情形下，你可以将一个实现了该trait的具体类型作为函数的返回值。但你无法对闭包执行同样的操作，因为闭包没有一个可供返回的具体类型；例如，你无法把函数指针fn用作返回类型。

◆ 下面的代码试图直接返回一个闭包，但它却无法通过编译：
fn returns_closure() -> Fn(i32) -> i32 {￼    |x| x + 1￼}
编译后出现的错误如下所示：
error[E0277]: the trait bound `std::ops::Fn(i32) -> i32 + 'static:￼std::marker::Sized` is not satisfied￼ -->￼  |￼1 | fn returns_closure() -> Fn(i32) -> i32 {￼  |                         ^^^^^^^^^^^^^^ `std::ops::Fn(i32) -> i32 + 'static`￼  does not have a constant size known at compile-time￼  |￼  = help: the trait `std::marker::Sized` is not implemented for￼  `std::ops::Fn(i32) -> i32 + 'static`￼  = note: the return type of a function must have a statically known size
这段错误提示信息再次指向了Sized trait！Rust无法推断出自己需要多大的空间来存储此处返回的闭包。幸运的是，我们已经在之前的章节中接触过了解决这一问题的方法，那就是使用trait对象：
fn returns_closure() -> Box<dyn Fn(i32) -> i32> {￼    Box::new(|x| x + 1)￼}
现在的代码可以正常编译了。如果你想要了解更多有关trait对象的信息，请参考第17章的“使用trait对象来存储不同类型的值”一节。


第一百二十二章 宏

◆ 术语宏（macro）其实是Rust中的某一组相关功能的集合称谓，其中包括使用macro_rules! 构造的声明宏（declarative macro）及另外3种过程宏（procedural macro）

◆ • 用于结构体或枚举的自定义#[derive]宏，它可以指定随derive属性自动添加的代码。
• 用于为任意条目添加自定义属性的属性宏。
• 看起来类似于函数的函数宏，它可以接收并处理一段标记（token）序列。


◆ 宏与函数之间的差别
从根本上来说，宏是一种用于编写其他代码的代码编写方式，也就是所谓的元编程范式（metaprogramming）。附录C中会讨论的derive属性是一种宏，它会自动为你生成各种trait的实现。我们在本书中一直使用println! 宏与vec! 宏。这些宏会通过展开来生成比你手写代码更多的内容。
元编程可以极大程度地减少你需要编写和维护的代码数量，虽然这也是函数的作用之一，但宏却有一些函数所不具备的能力。

◆ 函数在定义签名时必须声明自己参数的个数与类型，而宏则能够处理可变数量的参数：我们可以使用单一参数调用println!("hello")，也可以使用两个参数调用println! ("hello {}", name)。另外，由于编译器会在解释代码前展开宏，所以宏可以被用来执行某些较为特殊的任务，比如为类型实现trait等。之所以函数无法做到这一点，是因为trait需要在编译时实现，而函数则是在运行时调用执行的。
编写一个宏来实现功能相较于函数也有它自己的缺点：宏的定义要比函数定义复杂得多，因为你需要编写的是用于生成Rust代码的Rust代码。正是由于这种间接性，宏定义通常要比函数定义更加难以阅读、理解及维护。
宏和函数间的最后一个重要区别在于：当你在某个文件中调用宏时，你必须提前定义宏或将宏引入当前作用域中，而函数则可以在任意位置定义并在任意位置使用。

◆ 用于通用元编程的macro_rules! 声明宏
Rust中最常用的宏形式是声明宏，它们有时也被称作“模板宏”（macros by example）“macro_rules! 宏”，或者直白的“宏”。从核心形式上来讲，声明宏要求你编写出类似于match表达式的东西。正如在第6章讨论过的那样，match表达式是一种接收其他表达式的控制结构，它会将表达式的结果值与模式进行比较，并在匹配成功时执行对应分支中的代码。类似地，宏也会将输入的值与带有相关执行代码的模式进行比较：此处的值是传递给宏的字面Rust源代码，而此处的模式则是可以用来匹配这些源代码的结构。当某个模式匹配成功时，该分支下的代码就会被用来替换传入宏的代码。所有的这一切都会发生在编译时期。
为了定义一个宏，你需要用到macro_rules!。接下来，让我们学习vec! 宏的定义方式来了解如何使用macro_rules!。在第8章提到过，vec! 宏可以被用来创建一个具有特定元素的动态数组。例如，下面的宏创建出了一个包含3个整数的动态数组：
let v: Vec<u32> = vec![1, 2, 3];
当然，我们也可以使用vec! 宏来创建出包含2个整数的动态数组或包含5个字符串切片的动态数组。而函数则无法完成同样的事情，因为我们无法提前确定值的类型与数量。
示例19-28展示了一个稍微简化后的vec! 宏定义。
src/lib.rs
❶#[macro_export]￼❷macro_rules! vec {￼ ❸ ( $( $x:expr ),* ) => {￼        {￼            let mut temp_vec = Vec::new();￼         ❹ $(￼             ❺ temp_vec.push($x❻);￼            )*￼         ❼ temp_vec￼        }￼    };￼}
示例19-28：vec! 宏定义的简化版本


◆ 由于大多数Rust程序员都只是单纯地使用宏，而不会编写宏，所以我们就不再深入讨论macro_rules! 了。如果你想要学习更多有关编写宏的知识，请参考在线文档或其他资源，比如The Little Book of Rust Macros等。

◆ 基于属性创建代码的过程宏
第二种形式的宏更像函数（某种形式的过程）一些，所以它们被称为过程宏。过程宏会接收并操作输入的Rust代码，并生成另外一些Rust代码作为结果，这与声明宏根据模式匹配来替换代码的行为有所不同。
虽然过程宏存在3种不同的类型（自定义派生宏、属性宏及函数宏），但它们都具有非常类似的工作机制。
当创建过程宏时，宏的定义必须单独放在它们自己的包中，并使用特殊的包类型。这完全是因为技术上的原因，我们希望未来能够消除这种限制。

◆ 使用过程宏的代码如示例19-29所示，其中的some_attribute是一个用来指定过程宏类型的占位符。
src/lib.rs
use proc_macro;￼￼#[some_attribute]￼pub fn some_name(input: TokenStream) -> TokenStream {￼}
示例19-29：使用过程宏的一个例子


◆ 当包的用户在某个类型上标注#[derive(HelloMacro)]时，hello_macro_derive函数就会被自动调用。之所以会发生这样的操作，是因为我们在hello_macro_derive函数上标注了proc_macro_derive，并在该属性中指定了可以匹配到trait的名称HelloMacro；这是大多数过程宏都需要遵循的编写惯例。

◆ 属性宏与自定义派生宏类似，它们允许你创建新的属性，而不是为derive属性生成代码。属性宏在某种程度上也更加灵活：derive只能被用于结构体和枚举，而属性则可以同时被用于其他条目，比如函数等。下面便是一个使用了属性宏的例子，即假设你拥有一个名为route的属性，那么就可以在编写Web应用框架时为函数添加标记：
#[route(GET, "/")]￼fn index() {
这个#[route]属性是由框架本身作为一个过程宏来定义的，这个宏定义的函数签名如下所示：
#[proc_macro_attribute]￼pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream￼{

◆ 函数宏可以定义出类似于函数调用的宏，但它们远比普通函数更为灵活。例如，与macro_rules! 宏类似，函数宏也能接收未知数量的参数。但是，macro_rules! 宏只能使用类似于match的语法来进行定义，而函数宏则可以接收一个TokenStream作为参数，并与另外两种过程宏一样在定义中使用Rust代码来操作TokenStream。 例如，我们可能会这样调用一个名为sql! 的函数宏：
let sql = sql!(SELECT * FROM posts WHERE id=1);
这个宏会解析圆括号内的SQL语句并检验它在语法上的正确性，这一处理过程所做的比macro_rules! 宏可以完成的任务要复杂得多。此处的sql! 可以被定义为如下所示的样子：
#[proc_macro]￼pub fn sql(input: TokenStream) -> TokenStream {
这里的定义与自定义派生宏的签名十分类似：我们接收括号内的标记序列作为参数，并返回一段执行相应功能的生成代码。


第一百二十四章 第20章 最后的项目：构建多线程Web服务器

◆ 第20章最后的项目：构建多线程Web服务器


第一百二十九章 附录A 关键字

◆ 附录A关键字
￼
下面的列表包含了Rust当前正在使用或将来可能会使用的关键字。也正是因为如此，它们通常不能被用作标识符出现在函数、变量、参数、结构体字段、模块、包、常量、宏、静态变量、属性、类型、trait或生命周期的名称中。稍后的“原始标识符”一节会讨论一种使用这些关键字作为标识符的特殊方法。


第一百三十章 当前正在使用的关键字

◆ 当前正在使用的关键字
下面的关键字目前可以完成对应描述中的功能。
• as：执行基础类型转换，消除包含条目的指定trait的歧义，在use与extern crate语句中对条目进行重命名。
• break：立即退出一个循环。
• const：定义常量元素或不可变裸指针。
• continue：继续下一次循环迭代。
• crate：连接一个外部包或一个代表了当前包的宏变量。
• dyn：表示trait对象可以进行动态分发。
• else：if和if let控制流结构的回退分支。
• enum：定义一个枚举。
• extern：连接外部包、函数或变量。
• false：字面量布尔假。
• fn：定义一个函数或函数指针类型。
• for：在迭代器元素上进行迭代，实现一个trait，指定一个高阶生命周期。
• if：基于条件表达式结果的分支。
• impl：实现类型自有的功能或trait定义的功能。
• in：for循环语法的一部分。
• let：绑定一个变量。
• loop：无条件循环。
• match：用模式匹配一个值。
• mod：定义一个模块。
• move：让一个闭包获得全部捕获变量的所有权。
• mut：声明引用、裸指针或模式绑定的可变性。
• pub：声明结构体字段、impl块或模块的公共性。
• ref：通过引用绑定。
• return：从函数中返回。
• Self：指代正在其上实现trait的类型别名。
• self：指代方法本身或当前模块。
• static：全局变量或持续整个程序执行过程的生命周期。
• struct：定义一个结构体。
• super：当前模块的父模块。
• trait：定义一个trait。
• true：字面量布尔真。
• type：定义一个类型别名或关联类型。
• unsafe：声明不安全的代码、函数、trait或实现。
• use：把符号引入作用域中。
• where：声明一个用于约束类型的从句。
• while：基于一个表达式结果的条件循环。


第一百三十一章 将来可能会使用的保留关键字

◆ 将来可能会使用的保留关键字
下面的关键字目前还没有任何功能，但它们被Rust保留下来以备将来使用。
• abstract
• async
• become
• box
• do
• final
• macro
• override
• priv
• try
• typeof
• unsized
• virtual
• yield


第一百三十二章 原始标识符

◆ 原始标识符
原始标识符（raw identifier）作为一种特殊的语法，允许我们使用那些通常不被允许使用的关键字作为标识符。这一语法需要为关键字添加前缀r#。
比如，match是一个关键字。假如你尝试编译下面这个以match作为名称的函数：
src/main.rs
fn match(needle: &str, haystack: &str) -> bool {￼    haystack.contains(needle)￼}
你将会得到如下所示的错误：
error: expected identifier, found keyword `match`￼ --> src/main.rs:4:4￼  |￼4 | fn match(needle: &str, haystack: &str) -> bool {￼  |    ^^^^^ expected identifier, found keyword
这个错误表明你不能将关键字match用作函数标识符。为了使用match作为函数名称，我们需要使用原始标识符语法，如下所示：
src/main.rs
fn r#match(needle: &str, haystack: &str) -> bool {￼    haystack.contains(needle)￼}￼￼fn main() {￼    assert!(r#match("foo", "foobar"));￼}
这段代码可以毫无问题地通过编译。注意，函数名称的前缀r#同样也出现在了调用这个函数的地方。
原始标识符允许我们使用任意的单词作为标识符，即便这个单词恰好是保留的关键字。另外，原始标识符也使我们能够调用基于不同Rust版本编写的外部库。例如，try在2018版本中作为新关键字被引入Rust。假设你所依赖的库基于2015版本并正好拥有一个名为try的函数，那么你就需要用到原始标识符语法，也就是r#try，以便在2018版本的代码中调用这个函数。你可以在附录E中找到有关版本差异的更多信息。


第一百三十三章 附录B 运算符和符号

◆ 附录B运算符和符号
￼
本附录中给出了Rust语法的术语表，它们包括运算符与其他符号。这些符号要么单独出现，要么出现在路径、泛型、trait约束、宏、属性、注释、元组或括号中。


第一百三十四章 运算符

◆ 运算符
表B-1包含了Rust中的所有运算符，每一行分别包含运算符本身、运算符出现在上下文中的示例、一个简短的说明及当前运算符是否可重载。如果运算符是可重载的，我们还会列出重载运算符所涉及的trait。
表B-1　运算符
￼
￼
￼


第一百三十五章 非运算符符号

◆ 非运算符符号
接下来的列表包含了所有非运算符符号，换句话说，这些符号的行为不同于函数或方法调用。
表B-2展示了可以独立出现的符号，以及它们在不同场景下合法出现时的样子。
表B-2　独立语法
￼
表B-3展示了出现在路径上下文（从模块层级到具体条目）中的所有符号。
表B-3　与路径相关的语法
￼
表B-4展示了出现在泛型参数上下文中的符号。
表B-4　泛型
￼
表B-5展示了使用trait约束来限制泛型参数时可能出现的符号。
表B-5　trait约束
￼
表B-6展示了在调用宏、定义宏或在条目上指定属性时可能出现的符号。
表B-6　宏和属性
￼
表B-7展示了创建注释时可能出现的符号。
表B-7：注释
￼
表B-8展示了出现在元组上下文中的符号
表B-8　元组
￼
表B-9展示了使用花括号时的上下文。
表B-9　花括号
￼
表B-10展示了使用方括号时的上下文。
表B-10：方括号
￼


第一百三十六章 附录C 可派生trait

◆ 附录C可派生trait
￼
我们在本书中的许多地方都提到过derive属性，它可以被用在一个结构体或枚举定义上。当你在某个类型中声明derive属性时，它会为你在当前derive语法中声明的trait自动生成一份默认实现。
本附录会列举出标准库中所有可用于配合derive使用的trait作为参考。其中每一节都会涉及以下几个方面：
• 派生trait会重载哪些运算符或提供哪些方法。
• derive为trait提供了什么样的默认实现。
• trait的实现对目标类型意味着什么。
• 是否允许实现trait的相关条件。
• 使用这个trait的操作示例。
假如你需要的行为不同于derive属性的默认实现，那么你可以参考标准库文档中相关trait的细节来了解如何手动实现它们。
标准库中余下的那些trait无法通过derive来基于你的类型实现，它们通常都不存在有意义的默认行为。因此，你需要基于所处的具体环境来手动选择有意义的实现方式。
Display就是一个典型的不可派生trait，它被用来实现面向终端用户的文本格式化。你应该总是考虑为终端用户选择适当的方式来显示类型。类型中的哪些部分能够允许被终端用户看到？哪些部分可能会对终端用户起到作用？哪种格式对于终端用户最为友好？Rust编译器可没有这样的洞察力，它在这种场景下无法为你提供一个合适的默认行为。
本附录中并没有列出所有可以被派生的trait：代码库可以为它们自己的trait实现derive功能，这使得能够使用derive的trait实际上是无穷无尽的。实现derive会用到第19章的“宏”一节中介绍的过程宏。


第一百三十七章 面向程序员格式化输出的Debug

◆ 面向程序员格式化输出的Debug
Debug trait被用于在格式化字符串中提供用于调试的格式，你可以在{}占位符中添加:?来指定使用这一格式。
Debug trait允许我们为了调试来打印出某个类型的实例，这也就意味着使用该类型的开发者可以在程序执行的某个特定时间点上查看实例。
例如，使用assert_eq! 宏时需要用到Debug trait。这个宏会在相等性检查失败时打印出参数中实例的值，从而使得程序员可以观察到实例不相等的具体原因。


第一百三十八章 用于相等性比较的PartialEq和Eq

◆ 用于相等性比较的PartialEq和Eq
PartialEq trait允许我们比较类型实例的相等性，并允许我们使用==与!=运算符。
派生的PartialEq实现了eq方法。当在某个结构体上派生PartialEq时，两个结构体实例在所有字段都相等时相等。换句话说，只要存在任意不相等的字段，两个实例都会被视作不相等。当在某个枚举上派生时，每个变体都只与自身相等，而和其余变体不相等。
例如，assert_eq! 宏需要使用PartialEq trait来比较类型的两个实例是否相等。
Eq trait本身没有方法，它的作用在于表明被标记类型的每一个值都与自身相等。Eq trait只能被应用在同时实现了PartialEq的类型上，尽管并不是所有实现了PartialEq的类型都能够实现Eq。一个典型的例子就是浮点数类型：浮点数类型的实现规范里明确指出两个非数（not-a-number，Nan）值的实例是互不相等的。
例如，HashMap<K, V>中的键需要实现Eq trait，从而使得HashMap<K, V>可以判定两个键是否相同。



第一百三十九章 使用PartialOrd和Ord进行次序比较

◆ 使用PartialOrd和Ord进行次序比较
PartialOrd trait允许我们对类型实例进行次序比较。任何实现了PartialOrd的类型都可以使用<、>、<=与>=运算符。PartialOrd trait只能被应用在同时实现了PartialEq的类型上。
派生的PartialOrd实现了一个返回Option<Ordering>作为结果的partial_cmp方法，它会在给定值无法分出次序时返回None。一个无法给定比较次序的例子就是浮点数中的非数，尽管浮点数中的大部分值都是可以比较的。使用一个浮点数和一个Nan浮点数调用partial_cmp会返回None。
当我们在结构体上派生PartialOrd时，为了比较两个实例的次序，PartialOrd会按照字段出现在结构体定义中的顺序逐个对比字段的值。而当我们在枚举上派生它时，变体在枚举中的排列次序决定了不同变体之间的大小关系，在枚举定义中，声明在前的变体要小于声明在后的变体。
例如，rand包中的gen_range方法需要用到PartialOrd trait，这个方法在指定低值和高值的区间内产生随机数。
Ord trait表明被标注类型的任意两个值都存在一个有效的次序。它所实现的方法cmp会返回一个Ordering而不是Option<Ordering>，因为总是存在一个有效的次序。Ord trait只能被应用在同时实现了PartialOrd和Eq（并且，要实现Eq，必须先实现PartialEq）的类型上。当我们在结构体或枚举上派生它时，cmp与PartialOrd的partial_cmp方法拥有相同的行为。
例如，BTreeSet<T>在存储值时会用到Ord trait，这一数据结构需要基于值的次序来存储数据。


第一百四十章 使用Clone和Copy复制值

◆ 使用Clone和Copy复制值
Clone trait允许我们显式地创建一个值的深度拷贝，这一过程可能包含执行任意的代码及复制堆数据。你可以查阅第4章的“变量和数据交互的方式：克隆”一节来获得更多关于Clone的信息。
当我们在完整类型上派生Clone时，它会实现相应的clone方法来依次克隆类型中的每一部分。这也意味着派生Clone需要类型中所有的字段或值都同样实现了Clone。
例如，当我们在切片上调用to_vec方法时就会用到Clone。因为切片本身并不拥有它内部类型实例的所有权，但to_vec返回的动态数组却拥有它的实例，所以执行to_vec会在每一个元素上调用clone。因此，存储在切片中的类型必须要实现Clone（才拥有to_vec方法）。
Copy trait允许我们通过复制存储在栈上的位数据来创建一个值的浅度拷贝，这一过程不会涉及其他的任意代码。你可以查阅第4章的“栈上数据的复制”一节来获得更多关于Copy的信息。
由于Copy trait没有定义任何可供程序员重载的方法，所以不会有任何额外的代码在这一过程中得到执行。这也就是说，所有的开发者都可以假设复制值会非常快。
你可以在所有内部元素都实现了Copy的类型上派生Copy。另外，Copy trait只能被应用在同样实现了Clone的类型上，因为实现了Copy的类型总是存在一个Clone的实现来执行与Copy相同的任务。
很少有地方会强制要求使用Copy trait。一个实现了Copy的类型是可以优化的，这意味着你不需要显式调用clone，从而使代码更加简捷。
每一个需要使用Copy的地方都可以使用Clone来代替完成，但代码可能会损失一些性能或需要在适当的位置调用clone。


第一百四十一章 用于将值映射到另外一个长度固定的值的Hash

◆ 用于将值映射到另外一个长度固定的值的Hash
Hash trait允许我们使用哈希函数将一个任意大小的类型实例映射至一个固定大小的值对应的实例。派生Hash会实现对应的hash方法，hash方法的派生实现会逐次对类型的每个部分求hash结果，并将这些结果组合起来作为最终映射值。这也就意味着，派生Hash类型的所有字段或值也必须同样实现了Hash。
例如，HashMap<K, V>为了有效地存储数据会要求自己的键实现Hash。


第一百四十二章 用于提供默认值的Default

◆ 用于提供默认值的Default
Default trait允许我们为某个类型创建默认值。派生的Default实现了一个default函数，它会对类型的每个部分依次调用相应的default函数。这也就意味着，派生Default类型的所有字段或值也必须同样实现了Default。
Default::default函数常常被组合用于结构体更新语法中（第5章的“使用结构体更新语法根据其他实例创建新实例”一节中有详细介绍）。你可以自定义结构体中某一小部分字段的值，然后再使用..Default::default()为剩余部分的字段提供默认值。
例如，Option<T>实例的unwrap_or_default方法需要用到Default trait。当Option<T>为None时，unwrap_or_default方法就会调用Option<T>中类型T的Default::default方法，并将这一方法的返回值作为自己的结果。


第一百四十三章 附录D 有用的开发工具

◆ 附录D有用的开发工具
￼
本附录会介绍一些由Rust项目提供的有用的开发工具，它们包括自动格式化、警告的快速修复、代码分析及IDE的集成。



第一百四十四章 使用rustfmt自动格式化代码

◆ 使用rustfmt自动格式化代码
rustfmt工具会根据社区约定的风格来重新将你的代码格式化。许多协作完成的项目都会选择使用rustfmt来避免产生对于Rust代码风格的争论：所有人都使用统一的工具来将代码格式化。
你可以通过如下所示的命令来安装rustfmt：
$ rustup component add rustfmt
上面的命令会同时安装rustfmt与cargo-fmt，与Rust为你安装rustc与cargo时类似。你可以通过如下所示的命令来格式化任意的Cargo项目：
$ cargo fmt
运行这条命令会格式化当前包中的所有Rust代码。当然，这只会修改代码风格而不会导致代码语义产生变化。你可以在Rust官方网站阅读rustfmt的文档来获得更多信息。


第一百四十五章 使用rustfix修复代码

◆ 使用rustfix修复代码
rustfix工具被包含在Rust安装包中，它可以自动地修复一些编译器警告。假如你编写过Rust代码，那么你应该见识过编译器警告了。例如，考虑如下所示的代码：
src/main.rs
fn do_something() {}￼￼fn main() {￼    for i in 0..100 {￼        do_something();￼    }￼}
我们在上面的代码中试图调用do_something函数100次，但是我们实际上并没有在for循环体中用到变量i。Rust会给出如下所示的警告：
$ cargo build​​   Compiling myprogram v0.1.0 (file:///projects/myprogram)￼warning: unused variable: `i`￼ --> src/main.rs:4:9￼  |￼4 |     for i in 1..100 {￼  |         ^ help: consider using `_i` instead￼  |￼  = note: #[warn(unused_variables)] on by default￼￼    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
这段警告建议使用_i作为替代名称：变量名前方的下划线会表明我们是故意不使用该变量的。我们可以通过执行cargo fix来调用rustfix工具自动地采用这一建议：
$ cargo fix​​    Checking myprogram v0.1.0 (file:///projects/myprogram)￼      Fixing src/main.rs (1 fix)￼    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
再次观察src/main.rs，我们会发现cargo fix确实改变了代码：
src/main.rs
fn do_something() {}￼￼fn main() {￼    for _i in 0..100 {￼        do_something();￼    }￼}
for循环中的变量被重命名为了_i，警告不会再出现了。
你也同样可以使用cargo fix命令来将代码翻译为不同的Rust版本，有关版本的更多信息可以参见附录E。



第一百四十六章 使用Clippy完成更多的代码分析

◆ 使用Clippy完成更多的代码分析
Clippy工具中包含了一系列的代码分析工具（lint），它被用来捕捉常见的错误并提升Rust代码质量。
你可以通过如下所示的命令安装Clippy：
$ rustup component add clippy
并通过如下所示的命令在任意Cargo项目中运行Clippy来进行代码分析：
$ cargo clippy
例如，假设你的程序中使用了一个与数学常量pi近似的值，如下所示：
src/main.rs
fn main() {￼    let x = 3.1415;￼    let r = 8.0;￼    println!("the area of the circle is {}", x * r * r);￼}
在这个项目中执行cargo clippy会产生如下所示的错误：
error: approximate value of `f{32, 64}::consts::PI` found. Consider using it directly￼ --> src/main.rs:2:13￼  |￼2 |     let x = 3.1415;￼  |             ^^^^^^￼  |￼  = note: #[deny(clippy::approx_constant)] on by default￼  = help: for further information visit￼https://rust-lang-nursery.github.io/rust-clippy/master/index.html#approx_constant
这个错误指出Rust中存在更为精确的常量定义，你可以通过替换常量来获得更为准确的代码执行结果。当你将代码修改为使用PI常量后就不会产生任何来自Clippy的错误和警告了：
src/main.rs
fn main() {￼    let x = std::f64::consts::PI;￼    let r = 8.0;￼    println!("the area of the circle is {}", x * r * r);￼}
你可以在Rust官方网站阅读Clippy的文档来获得更多信息。



第一百四十七章 使用Rust语言服务器来集成IDE

◆ 使用Rust语言服务器来集成IDE
为了帮助开发者实现IDE集成，Rust项目提供了自己的Rust语言服务器（Rust Language Server，rls）。这一工具实现了语言服务器协议（Language Server Protocol），该协议作为一份通用规范被用于IDE与编程语言的相互通信。这也意味着rls可以被用于不同的客户端来完成IDE集成，比如用于Visual Studio Code的Rust插件（https://marketplace.visualstudio. com/items?itemName=rust-lang.rust）。
你可以通过如下所示的命令安装rls：
$ rustup component add rls
接着安装特定IDE中的语言服务器支持。随后你就可以获得诸如自动补全、定义跳转、内联错误提示等功能。
你可以在Rust官方网站上阅读rls的文档来获得更多信息。


第一百四十八章 附录E 版本

◆ 附录E版本
￼
当你在第1章中使用cargo new创建项目时，你应该已经在Cargo.toml文件中见到过有关版本的元数据了。本附录会更加深入地讨论它所蕴含的意义！
Rust语言与编译器以6周作为一个发布循环，这意味着用户可以持续稳定地获得功能更新。某些编程语言选择在更长的时间周期后发布大规模修改，但Rust则选择了更为频繁地发布小规模更新。在一段时间后，所有这些小更新会日积月累地增多。随着版本的迭代，普通用户将会越来越难以回顾并发出类似于这样的感叹：“哇，Rust 1.10到Rust 1.31的变化可真大！”
每隔两到三年，Rust团队都会生成一个新的Rust版本。每个版本都会将当前已经落地至对应包中的功能集合到一起，这些功能都拥有完善的文档与工具。新版本会作为6周发布循环中的一部分被提交给用户。
版本对于不同的人群拥有不同的意义：
• 对于活跃的Rust用户而言，一个新的版本会将增加的修改引入易于理解的包中。
• 对于还没有开始使用Rust的用户而言，一个新的版本表明我们发布了某些重大的进展，此时的Rust可能值得一试。
• 对于Rust本身的开发者而言，一个新的版本提供了整个项目的里程碑。
在编写本书时，Rust已经提供了两个可用的版本：Rust 2015与Rust 2018。本书基于Rust 2018编写而成。
Cargo.toml文件中的edition表明代码应该使用哪个版本的编译器。当这个字段不存在时，Rust会出于向后兼容目的默认采用2015作为编译版本。
每个项目都可以自由地选择版本，而无须拘泥于默认的2015版本。版本与版本之间会包含一些不兼容的修改，比如引入一个会与当前标识符冲突的新关键字等。但不管怎样，除非你主动选择新的版本来兼容这些修改，否则你之前的代码都应当能够继续通过编译，即便你升级了系统中的Rust编译器版本。
所有的Rust编译器都会兼容之前存在的任意版本，并能够链接采用这些支持版本的包。版本之间产生的变化仅仅会影响到编译器最初解析代码时的过程。因此，即便你正在使用Rust 2015编写代码，也可以将一个使用Rust 2018的包作为依赖，项目不会在编译时出现任何问题。相反，当你使用Rust 2018编写代码时，你也可以依赖于Rust 2015的包。
需要注意的是，大部分功能在所有的版本中都是可用的。使用任何Rust版本的开发者都应该能够持续地接收稳定版本中的改进。但在某些情况下，主要是当某些新关键字被引入时，某些新功能将只会在较新的版本中可用。你需要切换到新的版本才能体验到这些功能。
请在Rust官方网站查阅Edition Guide来获得更多相关信息，它被专门用于介绍版本及版本之间的差异，并解释了如何利用cargo fix来自动地将你的代码升级至新的版本。

